// This file was generated by TemplateEngine from template source 'Quaternion'
// using template 'Quaterniond. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Text;
using SharpMedia.Math.Matrix;
using SharpMedia.Testing;

namespace SharpMedia.Math
{
    /// <summary>
    /// Quaternion is a class that can be used to represent rotations and
    /// scaling. It is actually a hyper complex number with one real and
    /// three imagionary coefficients.
    /// </summary>
    [Serializable]
    public struct Quaterniond : IEquatable<Quaterniond>, IComparable, IComparable<Quaterniond>
    {
        #region Public Members

        /// <summary>
        /// Real part of quaternion.
        /// </summary>
        public double Re;

        /// <summary>
        /// Imagionary part of quaternion.
        /// </summary>
        public Vector3d Im;

        #endregion

        #region Properties

        //#ifdef Vector3ClassName


        /// <summary>
        /// Is quaternion real (no imagionary part).
        /// </summary>
        public bool IsReal
        {
            get { return Im == Vector3d.Zero; }
        }

        //#endif

        /// <summary>
        /// The first imagionary part.
        /// </summary>
        public double Im1
        {
            get { return Im.X; }
            set { Im.X = value; }
        }

        /// <summary>
        /// The second imagionary part.
        /// </summary>
        public double Im2
        {
            get { return Im.Y; }
            set { Im.Y = value; }
        }

        /// <summary>
        /// The third imagionary part.
        /// </summary>
        public double Im3
        {
            get { return Im.Z; }
            set { Im.Z = value; }
        }

        /// <summary>
        /// The length squared of quaternion.
        /// </summary>
        public double Length2
        {
            get { return Re * Re + Im * Im; }
        }

        //#ifdef Sqrt


        /// <summary>
        /// Length of quaternion.
        /// </summary>
        public double Length
        {
            get { return MathHelper.Sqrt(Re * Re + Im * Im); }
        }

        /// <summary>
        /// The normal of quaternion.
        /// </summary>
        public Quaterniond Normal
        {
            get
            {
                return this / Length;
            }
        }

        //#endif

        //#ifdef NearEqual


        /// <summary>
        /// Checks if quaternion is normalized.
        /// </summary>
        public bool IsNormalized
        {
            get { return MathHelper.NearEqual(Length2, 1.0); }
        }

        //#endif

        /// <summary>
        /// The element accessor.
        /// </summary>
        public double this[uint index]
        {
            get
            {
                switch (index)
                {
                    case 0: return Re;
                    case 1: return Im1;
                    case 2: return Im2;
                    case 3: return Im3;
                    default: throw new ArgumentException("Invalid index accessor.");
                }
            }
            set
            {
                switch (index)
                {
                    case 0: Re = value; break;
                    case 1: Im1 = value; break;
                    case 2: Im2 = value; break;
                    case 3: Im3 = value; break;
                    default: throw new ArgumentException("Invalid index accessor.");
                }
            }
        }

        /// <summary>
        /// Conjugate of quaterion.
        /// </summary>
        public Quaterniond Conjugate
        {
            get
            {
                return new Quaterniond(Re, -Im);
            }
        }

        /// <summary>
        /// Inverse of quaternion.
        /// </summary>
        public Quaterniond Inverse
        {
            get
            {
                return Conjugate / Length2;
            }
        }

        /// <summary>
        /// Inverse if quaternion is normalized.
        /// </summary>
        public Quaterniond NormInverse
        {
            get
            {
                return Conjugate;
            }
        }

        /// <summary>
        /// Exponent of quaternion.
        /// </summary>
        public Quaterniond Exp
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        /// <summary>
        /// Logarithm of quaternion.
        /// </summary>
        public Quaterniond Log
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        //#ifdef Atan


        /// <summary>
        /// Roll represented by quaternion.
        /// </summary>
        public double Roll
        {
            get
            {
                return MathHelper.ATan(
                    2 * (Im.X * Im.Y + Re * Im.Z),
                    Re * Re + Im.X * Im.X - Im.Y * Im.Y - Im.Z * Im.Z);
            }
        }

        /// <summary>
        /// Pitch represented by quaternion.
        /// </summary>
        public double Pitch
        {
            get
            {
                return MathHelper.ATan(
                    2 * (Im.Y * Im.Z + Re * Im.X),
                    Re * Re - Im.X * Im.X - Im.Y * Im.Y + Im.Z * Im.Z);
            }
        }

        //#endif

        //#ifdef Asin


        /// <summary>
        /// Yaw represented by quaternion.
        /// </summary>
        public double Yaw
        {
            get
            {
                return MathHelper.ASin((-2 * (Im.X * Im.Z - Re * Im.Y)));
            }
        }

        //#endif

        //#ifdef Vector3ClassName


        /// <summary>
        /// The X axis of quaternion.
        /// </summary>
        public Vector3d AxisX
        {
            get
            {
                double fTy = 2 * Im.Y;
                double fTz = 2 * Im.Z;
                double fTwy = fTy * Re;
                double fTwz = fTz * Re;
                double fTxy = fTy * Im.X;
                double fTxz = fTz * Im.X;
                double fTyy = fTy * Im.Y;
                double fTzz = fTz * Im.Z;

                return new Vector3d(1.0 - (fTyy + fTzz), fTxy + fTwz, fTxz - fTwy);
            }
        }

        /// <summary>
        /// The Y axis of quaternion.
        /// </summary>
        public Vector3d AxisY
        {
            get
            {
                double fTx = 2 * Im.X;
                double fTy = 2 * Im.Y;
                double fTz = 2 * Im.Z;
                double fTwx = fTx * Re;
                double fTwz = fTz * Re;
                double fTxx = fTx * Im.X;
                double fTxy = fTy * Im.X;
                double fTyz = fTz * Im.Y;
                double fTzz = fTz * Im.Z;

                return new Vector3d(fTxy - fTwz, 1.0 - (fTxx + fTzz), fTyz + fTwx);
            }
        }

        /// <summary>
        /// The Z axis of quaternion.
        /// </summary>
        public Vector3d AxisZ
        {
            get
            {
                double fTx = 2 * Im.X;
                double fTy = 2 * Im.Y;
                double fTz = 2 * Im.Z;
                double fTwx = fTx * Re;
                double fTwy = fTy * Re;
                double fTxx = fTx * Im.X;
                double fTxz = fTz * Im.X;
                double fTyy = fTy * Im.Y;
                double fTyz = fTz * Im.Y;

                return new Vector3d(fTxz + fTwy, fTyz - fTwx, 1.0 - (fTxx + fTyy));
            }
        }

        //#endif

        #endregion

        #region Overrides

        public override bool Equals(object obj)
        {
            if (obj is Quaterniond)
            {
                return this == (Quaterniond)obj;
            }
            return false;
        }

        public override string ToString()
        {
            StringBuilder builder = new StringBuilder(4 * 3 + 8);
            builder.Append("( ");
            builder.Append(Re);
            builder.Append(", ");
            builder.Append(Im.X);
            builder.Append(", ");
            builder.Append(Im.Y);
            builder.Append(", ");
            builder.Append(Im.Z);
            builder.Append(")");
            return builder.ToString();
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #endregion

        #region Constants

        /// <summary>
        /// A zero quaternion.
        /// </summary>
        public static Quaterniond Zero
        {
            get
            {
                return new Quaterniond(0.0, 0.0, 0.0, 0.0);
            }
        }

        /// <summary>
        /// A multiplication identity.
        /// </summary>
        public static Quaterniond Identity
        {
            get
            {
                return new Quaterniond(1.0, 0.0, 0.0, 0.0);
            }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Real part and imagionary part vector constructor.
        /// </summary>
        /// <param name="r">The real part.</param>
        /// <param name="i">The imagionary part.</param>
        public Quaterniond(double r, Vector3d i)
        {
            Re = r;
            Im = i;
        }

        /// <summary>
        /// Real part and imagionary part vector constructor.
        /// </summary>
        /// <param name="r">The real part.</param>
        /// <param name="i">The imagionary part.</param>
        public Quaterniond(double r, double i1, double i2, double i3)
        {
            Re = r;
            Im = new Vector3d(i1, i2, i3);
        }

        #endregion

        #region Static Members

        //#ifdef Sqrt Matrix3x3ClassName


        /// <summary>
        /// Converts quaterion from 3x3 rotational matrix.
        /// </summary>
        /// <param name="m">The matrix.</param>
        /// <returns>The quaternion representing rotations of 3x3 matrix.</returns>
        public static Quaterniond FromMatrix(Matrix3x3d m)
        {
            double m00 = m[0, 0];
            double m11 = m[1, 1];
            double m22 = m[2, 2];
            double T = 4 * (1.0 - m00 * m00 - m11 * m11 - m22 * m22);

            if (T > 0.0)
            {
                double S = (double)0.5 / MathHelper.Sqrt(T);

                return new Quaterniond((double)0.25 / S,
                    (m[2, 1] - m[1, 2]) * S,
                    (m[0, 2] - m[2, 0]) * S,
                    (m[1, 0] - m[0, 1]) * S);
            }
            else
            {
                if (m00 > m11 && m00 > m22)
                {
                    double S = (double)2.0 * MathHelper.Sqrt(1.0 + m00 - m11 - m22);
                    double S_inv = 1.0 / S;
                    return new Quaterniond(
                        (m[1, 2] + m[2, 1]) * S_inv,
                        (double)0.5 * S_inv,
                        (m[0, 1] + m[1, 0]) * S_inv,
                        (m[0, 2] + m[2, 0]) * S_inv);


                }
                else if (m11 > m00 && m11 > m22)
                {
                    double S = (double)2.0 * MathHelper.Sqrt(1.0 + m11 - m00 - m22);
                    double S_inv = 1.0 / S;

                    return new Quaterniond(
                        (m[0, 2] + m[2, 0]) * S_inv,
                        (m[0, 1] + m[1, 0]) * S_inv,
                        (double)0.5 * S_inv,
                        (m[1, 2] + m[2, 1]) * S_inv);
                }
                else
                {
                    double S = (double)2.0 * MathHelper.Sqrt(1.0 + m22 - m00 - m11);
                    double S_inv = 1.0 / S;

                    return new Quaterniond(
                        (m[0, 1] + m[1, 0]) * S_inv,
                        (m[0, 2] + m[2, 0]) * S_inv,
                        (m[1, 2] + m[2, 1]) * S_inv,
                        (double)0.5 * S_inv);
                }
            }
        }

        //#endif

        //#ifdef Sqrt Sin


        /// <summary>
        /// Constructs quaterion from axis and angle.
        /// </summary>
        /// <param name="axis">The axis.</param>
        /// <param name="angle">The angle around axis.</param>
        /// <returns>Quaternion representing transform.</returns>
        public static Quaterniond FromAxis(Vector3d axis, double angle)
        {
            double sin = MathHelper.Sin(angle * (double)0.5);
            double cos = MathHelper.Sqrt(1.0 - sin * sin);

            return (new Quaterniond(cos, axis * sin)).Normal;
        }

        //#endif

        //#ifdef Matrix3x3ClassName


        /// <summary>
        /// Conversion of quaternion to matrix.
        /// </summary>
        /// <returns>Immutable converted matrix.</returns>
        public Matrix3x3d ToMatrix()
        {
            Vector3d im_2 = Vector3d.ComponentMultiply(Im, Im);

            return new Matrix3x3d(
                1.0 - 2 * (im_2.Y + im_2.Z), 2 * (Im.X * Im.Y - Im.Z * Re), 2 * (Im.X * Im.Z + Im.Y * Re),
                2 * (Im.X * Im.Y + Im.Z * Re), 1.0 - 2 * (im_2.X + im_2.Z), 2 * (Im.Y * Im.Z - Im.X * Re),
                2 * (Im.X * Im.Z - Im.Y * Re), 2 * (Im.Y * Im.Z + Im.Y * Re), 1.0 - 2 * (im_2.X + im_2.Y));
        }

        //#endif

        //#ifdef Acos Sqrt


        /// <summary>
        /// Conversion of quaternion to axis and angle.
        /// </summary>
        /// <param name="angle">The angle in radians.</param>
        /// <param name="axis">The axis.</param>
        public void ToAxisAngle(out double angle, out Vector3d axis)
        {
            // We calculate the imagionary length, just to make sure
            // to handle special case (0,0,0,0)
            double l2 = Im * Im;
            if (l2 > 0.0)
            {
                angle = 2 * MathHelper.ACos(Re);
                double l_inv = 1.0 / MathHelper.Sqrt(l2);
                axis = Im * l_inv;
            }
            else
            {
                // Any axis is ok.
                angle = 0;
                axis = Vector3d.AxisX;
            }
        }

        //#endif

        //#ifdef NearEqual


        /// <summary>
        /// Are vectors nearly equal.
        /// </summary>
        /// <param name="q1">The quaternion to compare.</param>
        /// <param name="q2">The other quaternion.</param>
        public static bool NearEqual(Quaterniond q1, Quaterniond q2)
        {
            return MathHelper.NearEqual(q2.Re, q1.Re)
                   && Vector3d.NearEqual(q1.Im, q2.Im);

        }

        /// <summary>
        /// Are vectors nearly equal.
        /// </summary>
        /// <param name="q1">The quaternion to compare.</param>
        /// <param name="q2">The other quaternion.</param>
        /// <param name="eps">Maximum difference.</param>
        public static bool NearEqual(Quaterniond q1, Quaterniond q2, double eps)
        {
            return MathHelper.NearEqual(q2.Re, q1.Re, eps)
                   && Vector3d.NearEqual(q1.Im, q2.Im, eps);

        }

        //#endif


        #endregion

        #region Operations

        /// <summary>
        /// Are quaternions equal.
        /// </summary>
        public static bool operator ==(Quaterniond q1, Quaterniond q2)
        {
            return q1.Re == q2.Re && q1.Im == q2.Im;
        }

        /// <summary>
        /// Are quaternions not equal.
        /// </summary>
        public static bool operator !=(Quaterniond q1, Quaterniond q2)
        {
            return !(q1 == q2);
        }

        /// <summary>
        /// Quaternion added to real.
        /// </summary>
        public static Quaterniond operator +(Quaterniond q, double r)
        {
            return new Quaterniond(q.Re + r, q.Im);
        }

        /// <summary>
        /// Quaternion added to real.
        /// </summary>
        public static Quaterniond operator +(double r, Quaterniond q)
        {
            return q + r;
        }

        //#ifdef ComplexClassName


        /// <summary>
        /// Quaternion added to complex.
        /// </summary>
        /// <param name="q">The quaternion.</param>
        /// <param name="c">The complex.</param>
        /// <returns>Quaternion result.</returns>
        public static Quaterniond operator +(Quaterniond q, Complexd c)
        {
            return new Quaterniond(q.Re + c.Re, q.Im1 + c.Im, q.Im2, q.Im3);
        }

        /// <summary>
        /// Quaternion added to complex.
        /// </summary>
        /// <param name="q">The quaternion.</param>
        /// <param name="c">The complex.</param>
        /// <returns>Quaternion result.</returns>
        public static Quaterniond operator +(Complexd c, Quaterniond q)
        {
            return new Quaterniond(q.Re + c.Re, q.Im1 + c.Im, q.Im2, q.Im3);
        }

        //#endif

        /// <summary>
        /// Adds two quaternions.
        /// </summary>
        /// <param name="q1">First quaterion.</param>
        /// <param name="q2">Second quaterion.</param>
        /// <returns></returns>
        public static Quaterniond operator +(Quaterniond q1, Quaterniond q2)
        {
            return new Quaterniond(q1.Re + q2.Re, q1.Im + q2.Im);
        }

        /// <summary>
        /// Quaternion substracted by real.
        /// </summary>
        public static Quaterniond operator -(Quaterniond q, double r)
        {
            return new Quaterniond(q.Re - r, q.Im);
        }

        //#ifdef ComplexClassName


        /// <summary>
        /// Quaternion substracted by complex.
        /// </summary>
        /// <param name="q">The quaternion.</param>
        /// <param name="c">The complex.</param>
        /// <returns>Quaternion result.</returns>
        public static Quaterniond operator -(Quaterniond q, Complexd c)
        {
            return new Quaterniond(q.Re - c.Re, q.Im1 - c.Im, q.Im2, q.Im3);
        }

        //#endif

        /// <summary>
        /// Substracts two quaternions.
        /// </summary>
        /// <param name="q1">First quaterion.</param>
        /// <param name="q2">Second quaterion.</param>
        /// <returns></returns>
        public static Quaterniond operator -(Quaterniond q1, Quaterniond q2)
        {
            return new Quaterniond(q1.Re - q2.Re, q1.Im - q2.Im);
        }

        /// <summary>
        /// Multiplication by scalar.
        /// </summary>
        /// <param name="q">The quaternions.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Quaternion scaled.</returns>
        public static Quaterniond operator *(Quaterniond q, double f)
        {
            return new Quaterniond(q.Re * f, q.Im * f);
        }

        /// <summary>
        /// Multiplication by scalar.
        /// </summary>
        /// <param name="q">The quaternions.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Quaternion scaled.</returns>
        public static Quaterniond operator *(double f, Quaterniond q)
        {
            return q * f;
        }

        /// <summary>
        /// Division by scalar.
        /// </summary>
        /// <param name="q">The quaternions.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Quaternion scaled.</returns>
        public static Quaterniond operator /(Quaterniond q, double f)
        {
            return q * (1.0 / f);
        }

        /// <summary>
        /// Quaternion multiplication.
        /// </summary>
        /// <param name="q1">The first quaternion.</param>
        /// <param name="q2">The second quaternion.</param>
        /// <returns>Resulting quaterion.</returns>
        public static Quaterniond operator *(Quaterniond q1, Quaterniond q2)
        {
            Vector3d d1 = q2.Re * q1.Im;
            Vector3d d2 = q1.Re * q2.Im;
            Vector3d d3 = q1.Im ^ q2.Im;

            return new Quaterniond(q1.Re * q2.Re - q1.Im * q2.Im,
                 d1 + d2 + d3);
        }

        /// <summary>
        /// Quaternion division. If quaternions aRe unit, use q1*q2.Conjugate because
        /// it is faster.
        /// </summary>
        /// <param name="q1">The first quaternion.</param>
        /// <param name="q2">The second quaternion.</param>
        /// <returns></returns>
        public static Quaterniond operator /(Quaterniond q1, Quaterniond q2)
        {
            return q1 * q2.Inverse;
        }

        /// <summary>
        /// Transforms vector as quaternion.
        /// </summary>
        /// <param name="q1">The quaternion</param>
        /// <param name="v">Vector, treatet as quaternion with real component of 0.0
        /// and imaginary component of vector.</param>
        /// <returns>Transformed vector</returns>
        public static Vector3d operator *(Quaterniond q1, Vector3d v)
        {
            // Transformation of vector.
            Vector3d uv, uuv;
            uv = q1.Im ^ v;
            uuv = q1.Im ^ uv;
            uv *= (2 * q1.Re);
            uuv *= 2;

            return v + uv + uuv;
        }


        #endregion

        #region Interpolations

        /// <summary>
        /// Spherical interpolation between two quaternions. Both must be unit quaternions.
        /// </summary>
        /// <param name="q1">The first quaternion.</param>
        /// <param name="q2">The seconst quaternion.</param>
        /// <param name="t">The weighting factor, in range [0,1].</param>
        /// <returns>Interpolated quaternion.</returns>
        public static Quaterniond Slerp(Quaterniond q1, Quaterniond q2, double t)
        {
            // We always want the shortest path.
            throw new NotImplementedException();
        }

        /// <summary>
        /// A linear interpolation. May be a bit jerky.
        /// </summary>
        /// <param name="q1">The first quaternion.</param>
        /// <param name="q2">The second quaternion.</param>
        /// <param name="t">The path between them.</param>
        /// <returns>Quaternion in between.</returns>
        public static Quaterniond Linear(Quaterniond q1, Quaterniond q2, double t)
        {
            return (q1 * (1.0 - t) + q2 * t).Normal;
        }

        /// <summary>
        /// A cubic interpolation, using 4 rotation weights.
        /// </summary>
        /// <param name="q1">The first quaternion (t=0).</param>
        /// <param name="q2">The second quaternion (t=0.33).</param>
        /// <param name="q3">The third quaternion (t=0.66).</param>
        /// <param name="q4">The last quaternion (t=1.0).</param>
        /// <param name="t">Position, in range [0,1].</param>
        /// <returns>Quaternion matching orientation.</returns>
        public static Quaterniond Cubic(Quaterniond q1, Quaterniond q2, Quaterniond q3, Quaterniond q4, double t)
        {
            throw new NotImplementedException();
        }


        #endregion

        #region IEquatable<Quaterniond> Members

        public bool Equals(Quaterniond other)
        {
            return this == other;
        }

        #endregion

        #region IComparable Members

        public int CompareTo(object obj)
        {
            if (obj is Quaterniond)
            {
                return this.CompareTo((Quaterniond)obj);
            }
            throw new ArgumentException("Invalid argument.");
        }

        #endregion

        #region IComparable<Quaterniond> Members

        public int CompareTo(Quaterniond other)
        {
            return (Re + Im.X + Im.Y + Im.Z).CompareTo(
                other.Re + other.Im.X + other.Im.Y + other.Im.Z);
        }

        #endregion
    }


#if SHARPMEDIA_TESTSUITE
    [TestSuite]
    internal class Test_Quaterniond
    {
        [CorrectnessTest]
        public void Properites()
        {
            Quaterniond q = new Quaterniond(1.0, 2, 3, (double)0.5);
            Assert.IsTrue(q.Conjugate.Equals(new Quaterniond(1.0, -2, -3, (double)-0.5)));
            Quaterniond q2 = q * Quaterniond.Identity;
            Assert.IsTrue(q2 == q);
            Assert.IsTrue(q.Im == new Vector3d(2, 3, (double)0.5));
            Assert.AreEqual(1.0, q.Re);
            Assert.AreEqual(1.0, q.Normal.Length);
            Assert.AreEqual(false, q.IsReal);
            Assert.IsTrue(q.NormInverse == q.Conjugate);
        }

        [CorrectnessTest]
        public void Mul()
        {
            Quaterniond q = new Quaterniond(1.0, 2, 3, (double)15.5);
            Assert.IsTrue(Quaterniond.NearEqual(q * q.Inverse, Quaterniond.Identity));
        }

        [CorrectnessTest]
        public void Add()
        {
            Quaterniond q = new Quaterniond(3, 2, 1.0, 7);
            Assert.IsTrue(q + Quaterniond.Zero == q);
            Assert.IsTrue(q + q == 2 * q);
        }


        [CorrectnessTest]
        public void Transform()
        {
            Quaterniond q2 = Quaterniond.FromAxis(new Vector3d(0, 1, 0), 0.0);
            Assert.IsTrue(q2 == Quaterniond.Identity);
            Quaterniond q = Quaterniond.FromAxis(new Vector3d(0, 0, 1), (double)(global::System.Math.PI / 2.0));
            Matrix3x3d m = q.ToMatrix();
            Assert.IsTrue(Vector3d.NearEqual(m * Vector3d.AxisY, new Vector3d(-1, 0, 0)));
            Assert.IsTrue(Vector3d.NearEqual(q * Vector3d.AxisY, new Vector3d(-1, 0, 0)));
        }
        
    }
#endif
}
