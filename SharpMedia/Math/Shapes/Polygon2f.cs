// This file was generated by TemplateEngine from template source 'Polygon'
// using template 'Polygon2f. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.Testing;
using SharpMedia.Math.Matrix;

namespace SharpMedia.Math.Shapes
{


    /// <summary>
    /// Polygon in 2D space.
    /// </summary>
    [Serializable]
    public sealed class Polygon2f :
        IArea2f, IOutline2f, IControlPoints2f, IContainsPoint2f, ITransformable2f,
        IEquatable<Polygon2f>, IComparable<Polygon2f>,
        IEnumerable<Vector2f>, ICloneable<Polygon2f>
    {
        #region Public Members

        /// <summary>
        /// The points of polygon.
        /// </summary>
        public Vector2f[] Points;

        #endregion

        #region Private Helpers

        /// <summary>
        /// Splits line, by adding beginning and possibly middle point, but omitting last point.
        /// </summary>
        /// <param name="v1"></param>
        /// <param name="v2"></param>
        /// <param name="resolution"></param>
        /// <param name="data"></param>
        void SplitLine(Vector2f v1, Vector2f v2, float resolution, List<Vector2f> data)
        {
            if ((v1 - v2).Length2 > resolution * resolution)
            {
                float count = MathHelper.Floor((v1 - v2).Length / resolution);

                for (float i = 1; i < count; i += 1.0f)
                {
                    float t = (float)(i - 1) / (float)count;
                    data.Add((1.0f - t) * v1 + t * v2);
                }
            }
            else
            {
                data.Add(v1);
            }

        }

        #endregion

        #region Properties

        /// <summary>
        /// An array accessor.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public Vector2f this[uint index]
        {
            get
            {
                return Points[(int)index];
            }
            set
            {
                Points[(int)index] = value;
            }
        }

        /// <summary>
        /// The center point.
        /// </summary>
        public Vector2f Center
        {
            get
            {
                Vector2f center = Vector2f.Zero;
                for (int i = 0; i < Points.Length; i++)
                {
                    center += Points[i];
                }

                center /= (float)Points.Length;
                return center;
            }
        }

        /// <summary>
        /// Is the polygon convex.
        /// </summary>
        public bool IsConvex
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        /// <summary>
        /// Is the polygon clockwise.
        /// </summary>
        public bool IsClockwise
        {
            get
            {
                // We check winding order.
                float area = 0.0f;
                for (int j = 1; j < Points.Length; j++)
                {
                    // FIXME: this is Z projection assumed.
                    area += Points[j - 1].X * Points[j].Y - Points[j - 1].Y * Points[j].X;
                }

                return area <= 0.0f;
            }
        }

        /// <summary>
        /// Is the polygon anticlockwise.
        /// </summary>
        public bool IsAntiClockwise
        {
            get
            {
                return !IsClockwise;
            }
        }

        /// <summary>
        /// The bounding region.
        /// </summary>
        public Region2f BoundingRegion
        {
            get
            {
                return Region2f.MinMax(Points);
            }
        }


        #endregion

        #region Public Members

        /// <summary>
        /// Reverses the order of control points, e.g. 
        /// the converts clockwise to anticlockwise and vice versa.
        /// </summary>
        public void Reverse()
        {
            int n = Points.Length / 2;
            for (int i = 0; i < n; i++)
            {
                Vector2f t = Points[i];
                Points[i] = Points[n - i - 1];
                Points[n - i - 1] = t;
            }
        }

        /// <summary>
        /// Converts a polygon to line list, given a resolution.
        /// </summary>
        /// <param name="resolution">The resolution, negative means adaptive.</param>
        /// <returns></returns>
        public Vector2f[] ConvertToList(float resolution)
        {
            return ConvertToList(resolution, false);
        }

        /// <summary>
        /// Converts a polygon to line list, given a resolution.
        /// </summary>
        /// <param name="resolution">The resolution, negative means adaptive.</param>
        /// <param name="duplicateFirst">Is the first point duplicated.</param>
        /// <returns></returns>
        public Vector2f[] ConvertToList(float resolution, bool duplicateFirst)
        {
            Vector2f[] points = Points;

            if (resolution > 0.0f)
            {
                List<Vector2f> list = new List<Vector2f>(Points.Length);

                for (int i = 1; i < Points.Length; i++)
                {
                    SplitLine(Points[i - 1], Points[i], resolution, list);
                }
                SplitLine(Points[Points.Length - 1], Points[0], resolution, list);

                if (duplicateFirst)
                {
                    list.Add(Points[0]);
                }

                points = list.ToArray();
            }
            else if(duplicateFirst)
            {
                points = new Vector2f[Points.Length + 1];
                Points.CopyTo(points, 0);
                points[points.Length - 1] = points[0];
            }

            return points;
        }

        /// <summary>
        /// Obtains a line length.
        /// </summary>
        /// <param name="index">The line index, from control point 'index' to 'index+1'.</param>
        /// <returns></returns>
        public float GetLineLength(uint index)
        {
            if (index >= Points.Length) throw new ArgumentException("Index out of range.");
            uint nextIndex = index + 1 >= Points.Length ? 0 : index + 1;
            return (Points[nextIndex] - Points[index]).Length;
        }

        //#ifdef 2D


        /// <summary>
        /// Tesselates outline.
        /// </summary>
        /// <param name="resolution"></param>
        /// <param name="?"></param>
        public void TesselateOutline(float resolution, Algorithms.OutlineTesselation.TesselationOptionsf options,
            Storage.Builders.ITriangleBuilder2f builder)
        {

            // We tesselate.
            Algorithms.OutlineTesselation.Tesselate(ConvertToList(resolution, true), options, builder);
        }

        //#endif

        #endregion

        #region Constructors

        /// <summary>
        /// Polygon constructor.
        /// </summary>
        /// <param name="points">Points of polygon.</param>
        public Polygon2f(params Vector2f[] points)
        {
            this.Points = points;
        }

        #endregion

        #region Overrides

        public override string ToString()
        {
            StringBuilder builder = new StringBuilder(100);
            builder.Append("Polygon : {");
            for (int i = 0; i < Points.Length; i++)
            {
                builder.AppendLine(Points[i].ToString());
            }
            builder.Append("}");
            return builder.ToString();
        }

        public override bool Equals(object obj)
        {
            if (obj is Polygon2f)
            {
                return this.Equals((Polygon2f)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #endregion

        #region IArea2f Members

        public float Area
        {
            get
            {
                return float.NaN;
            }
        }

        public void Tesselate(float resolution, Storage.Builders.ITriangleBuilder2f builder)
        {
            Vector2f[] points = this.ConvertToList(resolution);

            // We now tesselate points.
            List<Vector2f[]> polygons = new List<Vector2f[]>();
            polygons.Add(points);

            Algorithms.PolygonTesselation.Tesselate(polygons, builder);
        }

        #endregion

        #region IOutline2f Members

        public Vector2f Sample(float t)
        {
            uint point = (uint)(t * (float)Points.Length);

            // We calculate interpolation ratio.
            float intRatio = t * Points.Length - t * (float)point;

            uint nextPoint = point + 1 >= Points.Length ? 0 : point + 1;

            // We return linear interpolation.
            return (1.0f - intRatio) * Points[point] + intRatio * Points[nextPoint];

        }

        public void Sample(float resolution, Storage.Builders.ILineBuilder2f builder)
        {
            Vector2f[] points = this.ConvertToList(resolution);

            if (points.Length == 0) return;

            builder.AddLineStrip(true, points);
        }

        #endregion

        #region IOutlinef Members

        public float OutlineLength
        {
            get
            {
                float length = 0.0f;
                for (int i = 1; i < Points.Length; i++)
                {
                    length += (Points[i - 1] - Points[i]).Length;
                }
                length += (Points[Points.Length - 1] - Points[0]).Length;
                return length;
            }

        }

        #endregion

        #region IControlPoints2f Members

        public Vector2f[] ControlPoints
        {
            get
            {
                return Points;
            }
            set
            {
                Points = value;
            }
        }

        public void SetControlPoints(uint index, Vector2f cp)
        {
            Points[(int)index] = cp;
        }

        public Vector2f GetControlPoint(uint index)
        {
            return Points[(int)index];
        }

        #endregion

        #region IControlPointsf Members

        public uint ControlPointCount
        {
            get { return (uint)Points.Length; }
        }

        #endregion

        #region IContainsPoint2f Members

        public bool ContainsPoint(Vector2f point)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region ITransformable2f

        public void Transform(Matrix.Matrix3x3f matrix)
        {
            for (int i = 0; i < Points.Length; i++)
            {
                Points[i] = matrix * Points[i];
            }
        }

        #endregion

        #region IEnumerable<Vector2f> Members

        public IEnumerator<Vector2f> GetEnumerator()
        {
            for (int i = 0; i < Points.Length; i++)
            {
                yield return Points[i];
            }
        }

        #endregion

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            for (int i = 0; i < Points.Length; i++)
            {
                yield return Points[i];
            }
        }

        #endregion

        #region IEquatable<Polygon2f> Members

        public bool Equals(Polygon2f other)
        {
            for (int i = 0; i < Points.Length; i++)
            {
                if (!Vector2f.NearEqual(this.Points[i], other.Points[i])) return false;
            }
            return true;
        }

        #endregion

        #region ICloneable Members

        public Polygon2f Clone()
        {
            return new Polygon2f(Points.Clone() as Vector2f[]);
        }

        #endregion

        #region IComparable<Triangled> Members

        public int CompareTo(Polygon2f other)
        {
            int cmp = Points.Length.CompareTo(other.Points.Length);
            if (cmp != 0) return cmp;

            for (int i = 0; i < Points.Length; i++)
            {
                cmp = Points[i].CompareTo(other.Points[i]);
                if (cmp != 0) return cmp;
            }
            return 0;
        }

        #endregion
    }


#if SHARPMEDIA_TESTSUITE
    [TestSuite]
    internal class Test_Polygon2f
    {
        [CorrectnessTest]
        public void Construction()
        {
            
        }

       

    }
#endif
}
