// This file was generated by TemplateEngine from template source 'AABox'
// using template 'AABoxd. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;

namespace SharpMedia.Math.Shapes.Volumes
{

    /// <summary>
    /// An axis aligned box.
    /// </summary>
    public sealed class AABoxd :
        IVolumed, IAABoxBoundabled, ISphereBoundabled,
        IArea3d, IContainsPoint3d,
        IEquatable<AABoxd>, IComparable<AABoxd>, ICloneable<AABoxd>
    {
        #region Public Members

        /// <summary>
        /// The minimum components of box.
        /// </summary>
        public Vector3d Min;

        /// <summary>
        /// The maximum components of box.
        /// </summary>
        public Vector3d Max;

        #endregion

        #region Properties

        /// <summary>
        /// Gets or sets the dimension.
        /// </summary>
        /// <value>The dimensions.</value>
        public Vector3d Dimension
        {
            get
            {
                return Max - Min;
            }
            set
            {
                if (!value.AllPositive) throw new ArgumentException("Dimensions must be positive.");
                Max = Min + value;
            }
        }

        /// <summary>
        /// The center.
        /// </summary>
        public Vector3d Center
        {
            get
            {
                return (double)0.5 * (Max + Min);
            }
        }

        /// <summary>
        /// The side X's length.
        /// </summary>
        public double SideX
        {
            get
            {
                return Max.X - Min.X;
            }
        }

        /// <summary>
        /// The side Y's length.
        /// </summary>
        public double SideY
        {
            get
            {
                return Max.Y - Min.Y;
            }
        }

        /// <summary>
        /// The side Z' length.
        /// </summary>
        public double SideZ
        {
            get
            {
                return Max.Z - Min.Z;
            }
        }

        #endregion

        #region Static Members

        /// <summary>
        /// Constructor box from points.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public static AABoxd FromPoints(params Vector3d[] data)
        {
            if (data.Length == 0) throw new ArgumentException("At least on point must be provided.");

            Vector3d Max = data[0];
            Vector3d Min = data[1];

            for (int i = 1; i < data.Length; i++)
            {
                Vector3d v = data[i];

                // Update min.
                Min.X = v.X < Min.X ? v.X : Min.X;
                Min.Y = v.Y < Min.Y ? v.Y : Min.Y;
                Min.Z = v.Z < Min.Z ? v.Z : Min.Z;

                // Update max.
                Max.X = v.X > Max.X ? v.X : Max.X;
                Max.Y = v.Y > Max.Y ? v.Y : Max.Y;
                Max.Z = v.Z > Max.Z ? v.Z : Max.Z;
            }

            return new AABoxd(Min, Max);
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Default constructor.
        /// </summary>
        public AABoxd()
        {
        }

        /// <summary>
        /// Constructor with minimum and maximum components.
        /// </summary>
        /// <param name="min">The minimum component.</param>
        /// <param name="max">The maximum component.</param>
        public AABoxd(Vector3d min, Vector3d max)
        {
            if (!(max - min).AllPositive) throw new ArgumentException("Dimensions must be positive.");
            this.Max = max;
            this.Min = min;
        }

        #endregion

        #region IArea3d Members

        public double Area
        {
            get
            {
                Vector3d dim = Dimension;

                return (double)2.0 * dim.X * dim.Y +
                    (double)2.0 * dim.Y * dim.Z +
                    (double)2.0 * dim.X * dim.Z;
            }
        }

        public void Tesselate(double resolution, Storage.Builders.ITriangleBuilder3d builder)
        {
            if (resolution < 0.0 ||
                (resolution > SideX && resolution > SideX && resolution > SideX))
            {
                if (!builder.IsIndexed)
                {
                    // Non indexed really isnt the best practice here ...
                    throw new NotImplementedException();
                }
                else
                {

                    // We simply append vertices and proceed.
                    uint indexBase = builder.AddControlPoints(
                        new Vector3d(Min.X, Min.Y, Min.Z),
                        new Vector3d(Max.X, Min.Y, Min.Z),
                        new Vector3d(Max.X, Min.Y, Max.Z),
                        new Vector3d(Min.X, Min.Y, Max.Z),
                        new Vector3d(Min.X, Max.Y, Min.Z),
                        new Vector3d(Max.X, Max.Y, Min.Z),
                        new Vector3d(Max.X, Max.Y, Max.Z),
                        new Vector3d(Min.X, Max.Y, Max.Z));

                    // We also need indices if indexed.

                    builder.AddIndexedTriangles(
                        new uint[] { 
                        indexBase, indexBase + 1, indexBase + 2,
                        indexBase, indexBase + 2, indexBase + 3,
                        indexBase, indexBase + 5, indexBase + 1,
                        indexBase, indexBase + 4, indexBase + 5,
                        indexBase + 1, indexBase + 6, indexBase + 2,
                        indexBase+1, indexBase + 5, indexBase + 6,
                        indexBase, indexBase + 3, indexBase + 7,
                        indexBase, indexBase + 7, indexBase + 4,
                        indexBase + 3, indexBase + 2, indexBase + 6,
                        indexBase + 3, indexBase + 6, indexBase + 7,
                        indexBase + 4, indexBase + 6, indexBase + 5,
                        indexBase + 4, indexBase + 7, indexBase + 6 
                    
                    }
                    );
                }
                
            }
            else
            {
                throw new NotImplementedException();
            }

        }

        #endregion

        #region IContainsPoint3d Members

        public bool ContainsPoint(Vector3d point)
        {
            return (point - Min).AllPositive && (Max - point).AllPositive;
        }

        #endregion

        #region IAABoxBoundabled Members

        public AABoxd BoundingAABox
        {
            get { return Clone(); }
        }

        #endregion

        #region ISphereBoundabled Members

        public Sphered BoundingSphere
        {
            get
            {
                Vector3d dim2 = Dimension / (double)2;
                double radius = dim2.Length;

                return new Sphered(Center, radius);
            }
        }

        #endregion

        #region IVolumed

        public double Volume
        {
            get
            {
                Vector3d dim = Dimension;
                return dim * dim;
            }
        }

        #endregion

        #region Transforms

        public void Transform(Vector3d scale, Vector3d transform)
        {
            Vector3d dim = Dimension;
            Vector3d center = Center;

            center = center + transform;
            dim = Vector3d.ComponentMultiply(scale, dim);

            Min = center - dim * (double)0.5;
            Max = center + dim * (double)0.5;
        }

        #endregion

        #region IEquatable<AABoxd> Members

        public bool Equals(AABoxd other)
        {
            if (Vector3d.NearEqual(Min, other.Min) &&
                Vector3d.NearEqual(Max, other.Max))
            {
                return true;
            }
            return false;
        }

        #endregion

        #region ICloneable Members

        public AABoxd Clone()
        {
            return new AABoxd(Min, Max);
        }

        #endregion

        #region IComparable<AABoxd> Members

        public int CompareTo(AABoxd other)
        {
            int cmp = Min.CompareTo(other.Min);
            if (cmp != 0) return cmp;
            return Max.CompareTo(other.Max);
        }

        #endregion
    }
}
