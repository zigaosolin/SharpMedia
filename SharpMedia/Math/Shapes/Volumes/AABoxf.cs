// This file was generated by TemplateEngine from template source 'AABox'
// using template 'AABoxf. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;

namespace SharpMedia.Math.Shapes.Volumes
{

    /// <summary>
    /// An axis aligned box.
    /// </summary>
    public sealed class AABoxf :
        IVolumef, IAABoxBoundablef, ISphereBoundablef,
        IArea3f, IContainsPoint3f,
        IEquatable<AABoxf>, IComparable<AABoxf>, ICloneable<AABoxf>
    {
        #region Public Members

        /// <summary>
        /// The minimum components of box.
        /// </summary>
        public Vector3f Min;

        /// <summary>
        /// The maximum components of box.
        /// </summary>
        public Vector3f Max;

        #endregion

        #region Properties

        /// <summary>
        /// Gets or sets the dimension.
        /// </summary>
        /// <value>The dimensions.</value>
        public Vector3f Dimension
        {
            get
            {
                return Max - Min;
            }
            set
            {
                if (!value.AllPositive) throw new ArgumentException("Dimensions must be positive.");
                Max = Min + value;
            }
        }

        /// <summary>
        /// The center.
        /// </summary>
        public Vector3f Center
        {
            get
            {
                return (float)0.5 * (Max + Min);
            }
        }

        /// <summary>
        /// The side X's length.
        /// </summary>
        public float SideX
        {
            get
            {
                return Max.X - Min.X;
            }
        }

        /// <summary>
        /// The side Y's length.
        /// </summary>
        public float SideY
        {
            get
            {
                return Max.Y - Min.Y;
            }
        }

        /// <summary>
        /// The side Z' length.
        /// </summary>
        public float SideZ
        {
            get
            {
                return Max.Z - Min.Z;
            }
        }

        #endregion

        #region Static Members

        /// <summary>
        /// Constructor box from points.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public static AABoxf FromPoints(params Vector3f[] data)
        {
            if (data.Length == 0) throw new ArgumentException("At least on point must be provided.");

            Vector3f Max = data[0];
            Vector3f Min = data[1];

            for (int i = 1; i < data.Length; i++)
            {
                Vector3f v = data[i];

                // Update min.
                Min.X = v.X < Min.X ? v.X : Min.X;
                Min.Y = v.Y < Min.Y ? v.Y : Min.Y;
                Min.Z = v.Z < Min.Z ? v.Z : Min.Z;

                // Update max.
                Max.X = v.X > Max.X ? v.X : Max.X;
                Max.Y = v.Y > Max.Y ? v.Y : Max.Y;
                Max.Z = v.Z > Max.Z ? v.Z : Max.Z;
            }

            return new AABoxf(Min, Max);
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Default constructor.
        /// </summary>
        public AABoxf()
        {
        }

        /// <summary>
        /// Constructor with minimum and maximum components.
        /// </summary>
        /// <param name="min">The minimum component.</param>
        /// <param name="max">The maximum component.</param>
        public AABoxf(Vector3f min, Vector3f max)
        {
            if (!(max - min).AllPositive) throw new ArgumentException("Dimensions must be positive.");
            this.Max = max;
            this.Min = min;
        }

        #endregion

        #region IArea3f Members

        public float Area
        {
            get
            {
                Vector3f dim = Dimension;

                return (float)2.0 * dim.X * dim.Y +
                    (float)2.0 * dim.Y * dim.Z +
                    (float)2.0 * dim.X * dim.Z;
            }
        }

        public void Tesselate(float resolution, Storage.Builders.ITriangleBuilder3f builder)
        {
            if (resolution < 0.0f ||
                (resolution > SideX && resolution > SideX && resolution > SideX))
            {
                if (!builder.IsIndexed)
                {
                    // Non indexed really isnt the best practice here ...
                    throw new NotImplementedException();
                }
                else
                {

                    // We simply append vertices and proceed.
                    uint indexBase = builder.AddControlPoints(
                        new Vector3f(Min.X, Min.Y, Min.Z),
                        new Vector3f(Max.X, Min.Y, Min.Z),
                        new Vector3f(Max.X, Min.Y, Max.Z),
                        new Vector3f(Min.X, Min.Y, Max.Z),
                        new Vector3f(Min.X, Max.Y, Min.Z),
                        new Vector3f(Max.X, Max.Y, Min.Z),
                        new Vector3f(Max.X, Max.Y, Max.Z),
                        new Vector3f(Min.X, Max.Y, Max.Z));

                    // We also need indices if indexed.

                    builder.AddIndexedTriangles(
                        new uint[] { 
                        indexBase, indexBase + 1, indexBase + 2,
                        indexBase, indexBase + 2, indexBase + 3,
                        indexBase, indexBase + 5, indexBase + 1,
                        indexBase, indexBase + 4, indexBase + 5,
                        indexBase + 1, indexBase + 6, indexBase + 2,
                        indexBase+1, indexBase + 5, indexBase + 6,
                        indexBase, indexBase + 3, indexBase + 7,
                        indexBase, indexBase + 7, indexBase + 4,
                        indexBase + 3, indexBase + 2, indexBase + 6,
                        indexBase + 3, indexBase + 6, indexBase + 7,
                        indexBase + 4, indexBase + 6, indexBase + 5,
                        indexBase + 4, indexBase + 7, indexBase + 6 
                    
                    }
                    );
                }
                
            }
            else
            {
                throw new NotImplementedException();
            }

        }

        #endregion

        #region IContainsPoint3f Members

        public bool ContainsPoint(Vector3f point)
        {
            return (point - Min).AllPositive && (Max - point).AllPositive;
        }

        #endregion

        #region IAABoxBoundablef Members

        public AABoxf BoundingAABox
        {
            get { return Clone(); }
        }

        #endregion

        #region ISphereBoundablef Members

        public Spheref BoundingSphere
        {
            get
            {
                Vector3f dim2 = Dimension / (float)2;
                float radius = dim2.Length;

                return new Spheref(Center, radius);
            }
        }

        #endregion

        #region IVolumef

        public float Volume
        {
            get
            {
                Vector3f dim = Dimension;
                return dim * dim;
            }
        }

        #endregion

        #region Transforms

        public void Transform(Vector3f scale, Vector3f transform)
        {
            Vector3f dim = Dimension;
            Vector3f center = Center;

            center = center + transform;
            dim = Vector3f.ComponentMultiply(scale, dim);

            Min = center - dim * (float)0.5;
            Max = center + dim * (float)0.5;
        }

        #endregion

        #region IEquatable<AABoxf> Members

        public bool Equals(AABoxf other)
        {
            if (Vector3f.NearEqual(Min, other.Min) &&
                Vector3f.NearEqual(Max, other.Max))
            {
                return true;
            }
            return false;
        }

        #endregion

        #region ICloneable Members

        public AABoxf Clone()
        {
            return new AABoxf(Min, Max);
        }

        #endregion

        #region IComparable<AABoxf> Members

        public int CompareTo(AABoxf other)
        {
            int cmp = Min.CompareTo(other.Min);
            if (cmp != 0) return cmp;
            return Max.CompareTo(other.Max);
        }

        #endregion
    }
}
