// This file was generated by TemplateEngine from template source 'Bezier'
// using template 'Bezier2d. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.Testing;
using SharpMedia.AspectOriented;
using SharpMedia.Math.Shapes.Volumes;

namespace SharpMedia.Math.Shapes
{


    /// <summary>
    /// A bezier curve, using 3 control points to make the curve.
    /// </summary>
    public sealed class Bezier2d :
        IOutline2d, IControlPoints2d, IContainsPoint2d, ITransformable2d,
        IEquatable<Bezier2d>, IComparable<Bezier2d>,
        IEnumerable<Vector2d>, ICloneable<Bezier2d>
        
    {
        #region Public Members

        /// <summary>
        /// The first control point.
        /// </summary>
        public Vector2d A;

        /// <summary>
        /// The middle control point.
        /// </summary>
        public Vector2d B;

        /// <summary>
        /// The end control point.
        /// </summary>
        public Vector2d C;

        #endregion

        #region Properties

        /// <summary>
        /// Is it closed shape.
        /// </summary>
        public bool IsClosed
        {
            get
            {
                return Vector2d.NearEqual(A, C);
            }
        }

        #endregion

        #region Public Members

        /// <summary>
        /// Are two bezier curves connected to each other.
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool IsConnected(Bezier2d other)
        {
            return Vector2d.NearEqual(this.A, other.A) ||
                   Vector2d.NearEqual(this.A, other.C) ||
                   Vector2d.NearEqual(this.C, other.A) ||
                   Vector2d.NearEqual(this.C, other.C);
        }

        #endregion

        #region Static Members

        /// <summary>
        /// Creates bezier curve from 3 points (not control points).
        /// </summary>
        /// <param name="p0">Beginning point of bezier curve.</param>
        /// <param name="p1">Middle point </param>
        /// <returns>Bezier curve.</returns>
        public static Bezier2d Approximate(Vector2d p0, Vector2d p1, Vector2d p2)
        {
            return null;
        }

        /// <summary>
        /// Approximates the points by bezier curve. Points must be close to the line,
        /// first and last points are fixed.
        /// </summary>
        /// <param name="ps">The points that represent it.</param>
        /// <param name="maxBeziers">Maximum number of curves returned.</param>
        /// <returns>Bezier curves.</returns>
        public static Bezier2d[] Approximate([NotEmptyArray] Vector2d[] ps, uint maxBeziers)
        {
            return null;
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Default constructor.
        /// </summary>
        public Bezier2d()
        {
        }

        /// <summary>
        /// Constructor with all three points.
        /// </summary>
        /// <param name="p1">First control point.</param>
        /// <param name="p2">Second control point.</param>
        /// <param name="p3">Third control point.</param>
        public Bezier2d(Vector2d p1, Vector2d p2, Vector2d p3)
        {
            A = p1;
            B = p2;
            C = p3;
        }

        #endregion

        #region Overrides

        public override string ToString()
        {
            StringBuilder builder = new StringBuilder(100);
            builder.Append("Bezier : {");
            builder.Append(A.ToString());
            builder.Append(", ");
            builder.Append(B.ToString());
            builder.Append(", ");
            builder.Append(C.ToString());
            builder.Append("}");
            return builder.ToString();
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Bezier2d) return this.Equals((Bezier2d)obj);
            return false;
        }

        #endregion

        #region IContainsPoint2d Members

        public bool ContainsPoint(Vector2d p)
        {
            // We solve quadratic equation for t.
            // p0.x = a.x * (1-t)^2 + b.x * t * (1-t) + c.x * t^2

            double t1, t2;

            // If first is non-linear.
            if (!MathHelper.NearEqual(A.X - (double)2.0 * B.X + C.X, 0.0))
            {
                // If no real solutions, this is not true.
                if (!Functions.Polynomial.Roots(A.X - (double)2.0 * B.X + C.X, (double)2.0 * B.X - (double)2.0 * A.X, A.X - p.X,
                                                out t1, out t2)) return false;
            }
            else if (!MathHelper.NearEqual(A.Y - (double)2.0 * B.Y + C.Y, 0.0))
            {
                // If no real solutions, this is not true.
                if (!Functions.Polynomial.Roots(A.Y - (double)2.0 * B.Y + C.Y, (double)2.0 * B.Y - (double)2.0 * A.Y, A.Y - p.Y,
                                                out t1, out t2)) return false;

            }
            
            else
            {
                return false;
            }

            // We check if any of parameters satisfies:
            if (t1 >= 0.0 && t1 <= 1.0)
            {
                if (Vector2d.NearEqual(p, Sample(t1))) return true;
            }
            if (t2 >= 0.0 && t2 <= 1.0)
            {
                if (Vector2d.NearEqual(p, Sample(t2))) return true;
            }
            return false;
        }

        #endregion

        #region IOutline2d Members

        public Vector2d Sample(double t)
        {
            double t1 = 1.0 - t;
            return t1 * t1 * A + (double)2 * t1 * t * B + t * t * C;
        }

        public void Sample(double resolution, Storage.Builders.ILineBuilder2d builder)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region IOutlined Members

        public double OutlineLength
        {
            get
            {
                // Those parameters can be changed for "section" length.
                double t1 = 0.0, t2 = 1.0;

                Vector2d spec;
                //#ifdef 2D

                spec = new Vector2d(1, 1);
                //#endif

                // We solve the equation. We first compute coefficients for first derivate.
                Vector2d M = (double)2.0 * (-(double)2.0 * Vector2d.ComponentMultiply(A, B) + C);
                Vector2d N = (double)2.0 * (Vector2d.ComponentMultiply(A, B) - A);

                // Now we must compute integral( sqrt((dx/dt)^2 + (dy/dt)^2 + (dz/dt)^2)), we fit in to the
                // formula and compute new coeficients of sqrt(polinomial) to integrate.
                double C0 = M * M;
                double C1 = (double)2.0 * M * N;
                double C2 = N * N;

                // We now compute the actual length by solving the integral:
                return (C1 + (double)2.0 * C0 * t1) / ((double)4.0 * C0) * MathHelper.Sqrt(t1 * (C1 + t1 * C0) + C2) -
                       (C1 + (double)2.0 * C0 * t2) / ((double)4.0 * C0) * MathHelper.Sqrt(t2 * (C1 + t2 * C0) + C2) +
                       ((double)4.0 * C0 * C2 - C1 * C1) / ((double)8.0 * MathHelper.Sqrt(C0 * C0 * C0)) *
                       MathHelper.Ln(((double)2.0 * C0 * t1 + C1 + (double)2.0 * MathHelper.Sqrt(C0 * (t1 * (-C1 + C0 * t1) + C2))) /
                                     ((double)2.0 * C0 * t2 + C1 + (double)2.0 * MathHelper.Sqrt(C0 * (t2 * (-C1 + C0 * t2) + C2))));
            }
        }

        #endregion

        #region IControlPoints2d Members

        public Vector2d[] ControlPoints
        {
            get
            {
                return new Vector2d[] { A, B, C };
            }
            set
            {
                if (value.Length != 3) throw new ArgumentException("Three control points expected for bezier curve.");
                A = value[0];
                B = value[1];
                C = value[2];
            }
        }

        public void SetControlPoints(uint index, Vector2d cp)
        {
            switch (index)
            {
                case 0:
                    A = cp;
                    break;
                case 1:
                    B = cp;
                    break;
                case 2:
                    C = cp;
                    break;
                default:
                    throw new ArgumentException("Index out of range, must be 0-2 for bezier curve.");
            }
        }

        public Vector2d GetControlPoint(uint index)
        {
            switch (index)
            {
                case 0:
                    return A;
                case 1:
                    return B;
                case 2:
                    return C;
                default:
                    throw new ArgumentException("Index out of range, must be 0-2 for bezier curve.");
            }
        }

        #endregion

        #region IControlPointsd Members

        public uint ControlPointCount
        {
            get { return 3; }
        }

        #endregion

        #region ITransformable2d

        public void Transform(Matrix.Matrix3x3d matrix)
        {
            A = matrix * A;
            B = matrix * B;
            C = matrix * C;
        }

        #endregion

        

        #region ICloneable<Bezier2d> Members

        public Bezier2d Clone()
        {
            return new Bezier2d(A, B, C);
        }

        #endregion

        #region IEquatable<Bezier2d> Members

        public bool Equals(Bezier2d other)
        {
            if (Vector2d.NearEqual(this.A, other.A) &&
                Vector2d.NearEqual(this.B, other.B) &&
                Vector2d.NearEqual(this.C, other.C)) return true;
            return false;
        }
        #endregion

        #region IComparable<ClassName> Members

        public int CompareTo(Bezier2d other)
        {
            int cmp = A.CompareTo(other.A);
            if (cmp != 0) return cmp;
            cmp = B.CompareTo(other.B);
            if (cmp != 0) return cmp;
            return C.CompareTo(other.C);

        }

        #endregion

        #region IEnumerable<Vector2d> Members

        public IEnumerator<Vector2d> GetEnumerator()
        {
            yield return A;
            yield return B;
            yield return C;
        }

        #endregion

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            yield return A;
            yield return B;
            yield return C;
        }

        #endregion


    }

#if SHARPMEDIA_TESTSUITE
    [TestSuite]
    internal class Test_Bezier2d
    {
        /*
        [CorrectnessTest]
        public void Properties()
        {
            Bezier2d b = new Bezier2d(new Vector2d(0, 0, 0),
                                    new Vector2d(1, 1, 0),
                                    new Vector2d(2, 0, 0));

            Assert.AreEqual(false, b.IsClosed);
            Assert.AreEqual(new Vector2d(0, 0, 0), b.A);
            Assert.AreEqual(new Vector2d(1, 1, 0), b.B);
            Assert.AreEqual(new Vector2d(2, 0, 0), b.C);
            Assert.AreEqual(new Vector2d(0, 0, 0), b.Sample(0.0));
            Assert.AreEqual(new Vector2d(2, 0, 0), b.Sample(1.0));
        }

        [CorrectnessTest]
        public void Contains()
        {
            Bezier2d b = new Bezier2d(new Vector2d(0, 0, 0),
                                    new Vector2d(1, 1, 0),
                                    new Vector2d(2, 0, 0));

            Vector2d p = b.Sample(0.3);
            Assert.IsTrue(b.ContainsPoint(p));
            Assert.IsFalse(b.ContainsPoint(p + new Vector2d(0, 0, 1)));
        }

        [CorrectnessTest]
        public void Intersections()
        {


        }*/
    }
#endif
}
