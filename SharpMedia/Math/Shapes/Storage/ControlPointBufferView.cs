// This file was generated by TemplateEngine from template source 'ControlPointBufferView'
// using template 'ControlPointBufferView. Do not modify this file directly, modify it from template source.

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using SharpMedia.AspectOriented;
using System.Runtime.InteropServices;
using SharpMedia.Math.Matrix;

namespace SharpMedia.Math.Shapes.Storage
{

    /// <summary>
    /// A control point buffer view over a mappable buffer. The buffer is mapped 
    /// </summary>
    /// <remarks>It must be mapped before any operations that require mapping are used.</remarks>
    [Serializable]
    public class ControlPointBufferView : IDisposable, IMapable<byte[]>
    {
        #region Private Members
        object syncRoot = new object();
        ulong offset = 0;
        MapOptions mapOptions;
        ControlPointFormat format;
        IMapable<byte[]> mappable;
        byte[] mappedData;
        UpdateFrequency updateFrequency;
        uint updateCount;
        #endregion

        #region Private Members

        ~ControlPointBufferView()
        {
            if (mappedData != null)
            {
                UnMap();
            }
        }

        void AssertMapped()
        {
            if (mappedData == null) throw new InvalidOperationException("The buffer is not mapped, operation invalid.");
        }

        void AssertUnMapped()
        {
            if (mappedData != null) throw new InvalidOperationException("The buffer is mapped, operation invalid.");
        }

        void AssertReadable()
        {
            if (mappedData == null || mapOptions == MapOptions.Write)
            {
                throw new InvalidOperationException("Buffer must be mapped with read access.");
            }
        }

        void AssertWritable()
        {
            if (mappedData == null || mapOptions == MapOptions.Read)
            {
                throw new InvalidOperationException("Buffer must be mapped with write access.");
            }
        }

        void AssertIndex(uint index)
        {
            if ((index + 1) * format.ByteSize > mappedData.Length)
            {
                throw new InvalidOperationException("Trying to access index out of range.");
            }
        }

        #endregion

        #region Constructor

        /// <summary>
        /// A constructor with format and mapping buffer.
        /// </summary>
        /// <param name="format"></param>
        /// <param name="mappable"></param>
        /// <param name="offset"></param>
        public ControlPointBufferView(ControlPointFormat format,
            IMapable<byte[]> mappable, ulong offset, UpdateFrequency freq, uint updateCount)
        {
            this.format = format;
            this.mappable = mappable;
            this.offset = offset;
            this.updateFrequency = freq;
            this.updateCount = updateCount;
        }

        /// <summary>
        /// A constructor with format and mapping buffer.
        /// </summary>
        /// <param name="format"></param>
        /// <param name="mappable"></param>
        /// <param name="offset"></param>
        public ControlPointBufferView(ControlPointFormat format,
            IMapable<byte[]> mappable, ulong offset)
            : this(format, mappable, offset, UpdateFrequency.PerVertex, 1)
        {
        }

        /// <summary>
        /// A constructor with format and mapping buffer
        /// </summary>
        /// <param name="format"></param>
        /// <param name="mappable"></param>
        public ControlPointBufferView(ControlPointFormat format, IMapable<byte[]> mappable)
            : this(format, mappable, 0)
        {
        }

        #endregion

        #region IMapable<byte[]> Members

        public byte[] Map(MapOptions op)
        {
            Monitor.Enter(syncRoot);

            try
            {
                AssertUnMapped();
                mappedData = mappable.Map(op);
                mapOptions = op;
            }
            catch (Exception)
            {
                Monitor.Exit(syncRoot);
                throw;
            }
            return mappedData;
        }

        public void UnMap()
        {
            AssertMapped();
            try
            {
                mappable.UnMap();
            }
            finally
            {
                mappedData = null;
                Monitor.Exit(syncRoot);
            }
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns mapped data.
        /// </summary>
        public byte[] MappedData
        {
            get
            {
                return mappedData;
            }
        }

        /// <summary>
        /// Maximum number of control points.
        /// </summary>
        public uint MaxControlPoints
        {
            get
            {
                if (mappedData == null)
                {
                    throw new InvalidOperationException(
                        "Buffer must be mapped to be able to obtain control points.");
                }
                return (uint)(mappedData.Length / format.ByteSize);
            }
        }

        /// <summary>
        /// Returns whether it is mapped.
        /// </summary>
        public bool IsMapped
        {
            get { return mappedData != null; }
        }

        /// <summary>
        /// Mapping options.
        /// </summary>
        public MapOptions MapOptions
        {
            get
            {
                return mapOptions;
            }
        }

        /// <summary>
        /// The format of buffer.
        /// </summary>
        public ControlPointFormat Format
        {
            get
            {
                return format;
            }
        }

        /// <summary>
        /// The underlaying buffer.
        /// </summary>
        public IMapable<byte[]> UnderlayingBuffer
        {
            get
            {
                return mappable;
            }
        }

        /// <summary>
        /// Offset of buffer.
        /// </summary>
        public ulong Offset
        {
            get
            {
                return offset;
            }
        }

        /// <summary>
        /// Update frequency.
        /// </summary>
        public UpdateFrequency UpdateFrequency
        {
            get
            {
                return updateFrequency;
            }
        }

        /// <summary>
        /// Update count.
        /// </summary>
        public uint UpdateCount
        {
            get
            {
                return updateCount;
            }
        }

        #endregion

        #region Data Manipulation

        /// <summary>
        /// Maps buffers, sets data and unmaps it.
        /// </summary>
        /// <param name="offset">The element offset.</param>
        public unsafe void SetData<T>([NotNull] T[] data) where T : struct
        {
            lock (syncRoot)
            {
                AssertWritable();

                // Validate T.
                ulong structSize = (ulong)Marshal.SizeOf(typeof(T));

                if (structSize != format.ByteSize)
                {
                    throw new ArgumentException("The T is not compatible with vertex format.");
                }


                fixed (byte* p = mappedData)
                {
                    Common.Memcpy(data, p, (ulong)data.LongLength);
                }


            }

        }

        /// <summary>
        /// Reads data to buffer.
        /// </summary>
        public unsafe T[] GetData<T>(ulong offset, ulong count) where T : struct
        {
            lock (syncRoot)
            {
                AssertReadable();

                // Validate T.
                ulong structSize = (ulong)Marshal.SizeOf(typeof(T));

                if (structSize != format.ByteSize)
                {
                    throw new ArgumentException("The T is not compatible with vertex format.");
                }

                T[] data = new T[count];


                fixed (byte* p = mappedData)
                {
                    Common.Memcpy(p, data, (ulong)data.LongLength);
                }


                return data;
            }


        }

        #endregion

        #region Read Queries


        
		//#foreach instanced to 'Byte'


        /// <summary>
        /// Obtains a byte.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe byte Getb(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(byte))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(byte)));
            }

            fixed (byte* p = mappedData)
            {
                byte* fp = (byte*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of byte.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, byte[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(byte))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(byte)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((byte*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of byte.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, byte[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(byte))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(byte)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((byte*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of byte.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, byte[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of byte.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe byte[] Getb(string component, uint baseOffset, uint count)
        {
            byte[] data = new byte[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of byte
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe byte[] Getb(string component, uint[] indices)
        {
            byte[] data = new byte[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Byte'

		//#foreach instanced to 'Double'


        /// <summary>
        /// Obtains a double.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe double Getd(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(double))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(double)));
            }

            fixed (byte* p = mappedData)
            {
                double* fp = (double*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of double.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, double[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(double))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(double)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((double*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of double.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, double[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(double))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(double)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((double*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of double.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, double[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of double.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe double[] Getd(string component, uint baseOffset, uint count)
        {
            double[] data = new double[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of double
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe double[] Getd(string component, uint[] indices)
        {
            double[] data = new double[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Double'

		//#foreach instanced to 'Float'


        /// <summary>
        /// Obtains a float.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe float Getf(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(float))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(float)));
            }

            fixed (byte* p = mappedData)
            {
                float* fp = (float*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of float.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, float[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(float))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(float)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((float*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of float.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, float[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(float))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(float)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((float*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of float.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, float[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of float.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe float[] Getf(string component, uint baseOffset, uint count)
        {
            float[] data = new float[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of float
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe float[] Getf(string component, uint[] indices)
        {
            float[] data = new float[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Float'

		//#foreach instanced to 'Half'


        /// <summary>
        /// Obtains a Half.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Half Geth(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Half))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Half)));
            }

            fixed (byte* p = mappedData)
            {
                Half* fp = (Half*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Half.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Half[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Half))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Half)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Half*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Half.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Half[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Half))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Half)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Half*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Half.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Half[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Half.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Half[] Geth(string component, uint baseOffset, uint count)
        {
            Half[] data = new Half[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Half
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Half[] Geth(string component, uint[] indices)
        {
            Half[] data = new Half[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Half'

		//#foreach instanced to 'Integer'


        /// <summary>
        /// Obtains a int.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe int Geti(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(int))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(int)));
            }

            fixed (byte* p = mappedData)
            {
                int* fp = (int*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of int.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, int[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(int))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(int)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((int*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of int.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, int[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(int))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(int)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((int*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of int.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, int[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of int.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe int[] Geti(string component, uint baseOffset, uint count)
        {
            int[] data = new int[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of int
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe int[] Geti(string component, uint[] indices)
        {
            int[] data = new int[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Integer'

		//#foreach instanced to 'Short'


        /// <summary>
        /// Obtains a short.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe short Gets(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(short))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(short)));
            }

            fixed (byte* p = mappedData)
            {
                short* fp = (short*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of short.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, short[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(short))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(short)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((short*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of short.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, short[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(short))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(short)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((short*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of short.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, short[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of short.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe short[] Gets(string component, uint baseOffset, uint count)
        {
            short[] data = new short[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of short
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe short[] Gets(string component, uint[] indices)
        {
            short[] data = new short[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Short'

		//#foreach instanced to 'Vector2d'


        /// <summary>
        /// Obtains a Vector2d.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector2d Get2d(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector2d)));
            }

            fixed (byte* p = mappedData)
            {
                Vector2d* fp = (Vector2d*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector2d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector2d[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector2d)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector2d*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector2d[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector2d)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector2d*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector2d[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector2d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector2d[] Get2d(string component, uint baseOffset, uint count)
        {
            Vector2d[] data = new Vector2d[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector2d
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector2d[] Get2d(string component, uint[] indices)
        {
            Vector2d[] data = new Vector2d[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector2d'

		//#foreach instanced to 'Vector2f'


        /// <summary>
        /// Obtains a Vector2f.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector2f Get2f(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector2f)));
            }

            fixed (byte* p = mappedData)
            {
                Vector2f* fp = (Vector2f*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector2f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector2f[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector2f)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector2f*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector2f[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector2f)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector2f*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector2f[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector2f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector2f[] Get2f(string component, uint baseOffset, uint count)
        {
            Vector2f[] data = new Vector2f[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector2f
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector2f[] Get2f(string component, uint[] indices)
        {
            Vector2f[] data = new Vector2f[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector2f'

		//#foreach instanced to 'Vector2i'


        /// <summary>
        /// Obtains a Vector2i.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector2i Get2i(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector2i)));
            }

            fixed (byte* p = mappedData)
            {
                Vector2i* fp = (Vector2i*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector2i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector2i[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector2i)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector2i*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector2i[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector2i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector2i)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector2i*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector2i[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector2i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector2i[] Get2i(string component, uint baseOffset, uint count)
        {
            Vector2i[] data = new Vector2i[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector2i
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector2i[] Get2i(string component, uint[] indices)
        {
            Vector2i[] data = new Vector2i[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector2i'

		//#foreach instanced to 'Vector3d'


        /// <summary>
        /// Obtains a Vector3d.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector3d Get3d(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector3d)));
            }

            fixed (byte* p = mappedData)
            {
                Vector3d* fp = (Vector3d*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector3d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector3d[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector3d)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector3d*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector3d[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector3d)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector3d*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector3d[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector3d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector3d[] Get3d(string component, uint baseOffset, uint count)
        {
            Vector3d[] data = new Vector3d[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector3d
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector3d[] Get3d(string component, uint[] indices)
        {
            Vector3d[] data = new Vector3d[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector3d'

		//#foreach instanced to 'Vector3f'


        /// <summary>
        /// Obtains a Vector3f.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector3f Get3f(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector3f)));
            }

            fixed (byte* p = mappedData)
            {
                Vector3f* fp = (Vector3f*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector3f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector3f[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector3f)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector3f*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector3f[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector3f)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector3f*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector3f[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector3f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector3f[] Get3f(string component, uint baseOffset, uint count)
        {
            Vector3f[] data = new Vector3f[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector3f
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector3f[] Get3f(string component, uint[] indices)
        {
            Vector3f[] data = new Vector3f[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector3f'

		//#foreach instanced to 'Vector3i'


        /// <summary>
        /// Obtains a Vector3i.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector3i Get3i(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector3i)));
            }

            fixed (byte* p = mappedData)
            {
                Vector3i* fp = (Vector3i*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector3i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector3i[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector3i)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector3i*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector3i[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector3i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector3i)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector3i*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector3i[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector3i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector3i[] Get3i(string component, uint baseOffset, uint count)
        {
            Vector3i[] data = new Vector3i[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector3i
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector3i[] Get3i(string component, uint[] indices)
        {
            Vector3i[] data = new Vector3i[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector3i'

		//#foreach instanced to 'Vector4d'


        /// <summary>
        /// Obtains a Vector4d.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector4d Get4d(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector4d)));
            }

            fixed (byte* p = mappedData)
            {
                Vector4d* fp = (Vector4d*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector4d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector4d[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector4d)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector4d*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector4d[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4d))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector4d)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector4d*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector4d[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector4d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector4d[] Get4d(string component, uint baseOffset, uint count)
        {
            Vector4d[] data = new Vector4d[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector4d
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector4d[] Get4d(string component, uint[] indices)
        {
            Vector4d[] data = new Vector4d[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector4d'

		//#foreach instanced to 'Vector4f'


        /// <summary>
        /// Obtains a Vector4f.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector4f Get4f(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector4f)));
            }

            fixed (byte* p = mappedData)
            {
                Vector4f* fp = (Vector4f*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector4f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector4f[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector4f)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector4f*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector4f[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4f))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector4f)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector4f*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector4f[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector4f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector4f[] Get4f(string component, uint baseOffset, uint count)
        {
            Vector4f[] data = new Vector4f[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector4f
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector4f[] Get4f(string component, uint[] indices)
        {
            Vector4f[] data = new Vector4f[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector4f'

		//#foreach instanced to 'Vector4i'


        /// <summary>
        /// Obtains a Vector4i.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public unsafe Vector4i Get4i(string component, uint index)
        {
            AssertReadable();
            AssertIndex(index);

            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'", 
                    element.Type, typeof(Vector4i)));
            }

            fixed (byte* p = mappedData)
            {
                Vector4i* fp = (Vector4i*)(p + offset + index * format.ByteSize + element.Offset);
                return *fp;
            }
        }

        /// <summary>
        /// Obtains an array of Vector4i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Get(string component, uint[] indices, Vector4i[] data)
        {
            AssertReadable();
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector4i)));
            }

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    data[i] = *((Vector4i*)(p + offset + indices[i] * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Get(string component, uint baseOffset, uint count, Vector4i[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertReadable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            if (element.Type != typeof(Vector4i))
            {
                throw new InvalidOperationException(
                    string.Format("Type in format is not compatible, expected '{0}', got '{1}'",
                    element.Type, typeof(Vector4i)));
            }

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    data[i] = *((Vector4i*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset));
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Get(string component, uint baseOffset, Vector4i[] data)
        {
            Get(component, baseOffset, (uint)data.Length, data);
        }

        /// <summary>
        /// Obtains array of Vector4i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">Base offset</param>
        /// <param name="count">The length of array</param>
        /// <returns></returns>
        public unsafe Vector4i[] Get4i(string component, uint baseOffset, uint count)
        {
            Vector4i[] data = new Vector4i[count];
            Get(component, baseOffset, data);
            return data;
        }

        /// <summary>
        /// Obtains array of Vector4i
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices.</param>
        /// <returns></returns>
        public unsafe Vector4i[] Get4i(string component, uint[] indices)
        {
            Vector4i[] data = new Vector4i[indices.Length];
            Get(component, indices, data);
            return data;
        }

        //#endfor instanced to 'Vector4i'


        // TODO: add matrix queries

        #endregion

        #region Write Queries

        
		//#foreach instanced to 'Byte'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, byte data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                byte* fp = (byte*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of byte.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, byte[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((byte*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of byte.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, byte[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((byte*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of byte.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, byte[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Byte'

		//#foreach instanced to 'Double'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, double data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                double* fp = (double*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of double.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, double[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((double*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of double.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, double[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((double*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of double.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, double[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Double'

		//#foreach instanced to 'Float'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, float data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                float* fp = (float*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of float.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, float[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((float*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of float.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, float[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((float*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of float.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, float[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Float'

		//#foreach instanced to 'Half'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Half data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Half* fp = (Half*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Half.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Half[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Half*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Half.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Half[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Half*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Half.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Half[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Half'

		//#foreach instanced to 'Integer'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, int data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                int* fp = (int*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of int.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, int[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((int*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of int.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, int[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((int*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of int.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, int[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Integer'

		//#foreach instanced to 'Short'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, short data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                short* fp = (short*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of short.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, short[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((short*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of short.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, short[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((short*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of short.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, short[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Short'

		//#foreach instanced to 'Vector2d'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector2d data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector2d* fp = (Vector2d*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector2d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector2d[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector2d*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector2d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector2d[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector2d*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector2d[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector2d'

		//#foreach instanced to 'Vector2f'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector2f data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector2f* fp = (Vector2f*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector2f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector2f[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector2f*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector2f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector2f[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector2f*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector2f[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector2f'

		//#foreach instanced to 'Vector2i'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector2i data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector2i* fp = (Vector2i*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector2i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector2i[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector2i*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector2i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector2i[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector2i*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector2i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector2i[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector2i'

		//#foreach instanced to 'Vector3d'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector3d data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector3d* fp = (Vector3d*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector3d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector3d[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector3d*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector3d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector3d[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector3d*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector3d[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector3d'

		//#foreach instanced to 'Vector3f'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector3f data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector3f* fp = (Vector3f*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector3f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector3f[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector3f*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector3f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector3f[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector3f*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector3f[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector3f'

		//#foreach instanced to 'Vector3i'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector3i data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector3i* fp = (Vector3i*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector3i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector3i[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector3i*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector3i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector3i[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector3i*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector3i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector3i[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector3i'

		//#foreach instanced to 'Vector4d'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector4d data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector4d* fp = (Vector4d*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector4d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector4d[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector4d*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector4d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector4d[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector4d*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4d.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector4d[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector4d'

		//#foreach instanced to 'Vector4f'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector4f data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector4f* fp = (Vector4f*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector4f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector4f[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector4f*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector4f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector4f[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector4f*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4f.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector4f[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector4f'

		//#foreach instanced to 'Vector4i'


        /// <summary>
        /// Sets one data to component at specific index.
        /// </summary>
        /// <param name="component"></param>
        /// <param name="index"></param>
        /// <param name="data"></param>
        public unsafe void Set(string component, uint index, Vector4i data)
        {
            AssertWritable();
            AssertIndex(index);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                Vector4i* fp = (Vector4i*)(p + offset + index * format.ByteSize + element.Offset);
                *fp = data;
            }
        }

        /// <summary>
        /// Sets an array of Vector4i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="indices">Indices that must be addressed, no checks are made for in range.</param>
        /// <param name="data">The data where data will be set.</param>
        public unsafe void Set(string component, uint[] indices, Vector4i[] data)
        {
            AssertWritable();
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    *((Vector4i*)(p + offset + indices[i] * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Sets an array of Vector4i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data that will be filled.</param>
        public unsafe void Set(string component, uint baseOffset, uint count, Vector4i[] data)
        {
            if (count > data.Length) throw new ArgumentException("Cannot transfer more data than there is space.");
            AssertWritable();
            AssertIndex(baseOffset + count - 1);
            ControlPointFormat.Element element = format.GetElement(component);

            fixed (byte* p = mappedData)
            {
                for (uint i = 0; i < count; i++)
                {
                    *((Vector4i*)(p + offset + (baseOffset + i) * format.ByteSize + element.Offset)) = data[i];
                }
            }
        }

        /// <summary>
        /// Obtains an array of Vector4i.
        /// </summary>
        /// <param name="component">The component name.</param>
        /// <param name="baseOffset">The base index offset, vertices from baseOffset 
        /// to baseOffset + data.Length-1 will be transfered.</param>
        /// <param name="data">The data.</param>
        public unsafe void Set(string component, uint baseOffset, Vector4i[] data)
        {
            Set(component, baseOffset, (uint)data.Length, data);
        }


        //#endfor instanced to 'Vector4i'


        // TODO: add matrix queries

        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            lock (syncRoot)
            {
                if (mappable == null) return;
                if (IsMapped)
                {
                    mappable.UnMap();
                    mappedData = null;
                    mappable = null;
                }
            }
        }

        #endregion
    }
}
