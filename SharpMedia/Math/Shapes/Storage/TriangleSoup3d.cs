// This file was generated by TemplateEngine from template source 'TriangleSoup'
// using template 'TriangleSoup3d. Do not modify this file directly, modify it from template source.

using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.AspectOriented;
using SharpMedia.Math.Shapes.Storage.Builders;

namespace SharpMedia.Math.Shapes.Storage
{

    /// <summary>
    /// Represents a collection of triangles, in native format.
    /// </summary>
    /// <remarks>This is processing oriented format with 'builder and accessor' in one.
    /// </remarks>
    [Serializable]
    public class TriangleSoup3d : ITriangleAccess3d, ITriangleBuilder3d
    {
        #region Private Members
        List<Vector3d> vertices = new List<Vector3d>();
        List<uint> indices;
        #endregion

        #region Constructors

        /// <summary>
        /// Default constructor.
        /// </summary>
        public TriangleSoup3d()
            : this(false)
        {
        }

        /// <summary>
        /// Constructor setting wheteher soup is indexed or not.
        /// </summary>
        /// <param name="indexed"></param>
        public TriangleSoup3d(bool indexed)
        {
            if (indexed)
            {
                indices = new List<uint>();
            }
            else
            {
                indices = null;
            }
        }

        #endregion

        #region Properties

        /// <summary>
        /// A list of vertices.
        /// </summary>
        /// <remarks>Appending/removing vertices is dangerous.</remarks>
        public List<Vector3d> Vertices
        {
            get { return vertices; }
        }

        /// <summary>
        /// A list of indices.
        /// </summary>
        /// <remarks>Appending/removing indices is dangerous.</remarks>
        public List<uint> Indices
        {
            get { return indices; }
        }

        #endregion

        #region Public Members

        /// <summary>
        /// Number of shapes.
        /// </summary>
        public uint ShapeCount
        {
            get
            {
                return (uint)indices.Count / 3;
            }
        }

        #endregion

        #region Triangle Access

        /// <summary>
        /// Obtains a triangle at index.
        /// </summary>
        /// <param name="index">The index.</param>
        /// <returns>A trinagle at index.</returns>
        public Triangle3d Get(uint index)
        {
            int idx = (int)index;
            if (IsIndexed)
            {
                return new Triangle3d(vertices[(int)indices[idx * 3]], vertices[(int)indices[idx * 3 + 1]],
                                     vertices[(int)indices[idx * 3 + 2]]);
            }
            else
            {
                return new Triangle3d(vertices[idx * 3], vertices[idx * 3 + 1], vertices[idx * 3 + 2]);
            }
        }

        /// <summary>
        /// Fills a triangle at index.
        /// </summary>
        /// <param name="index">The index.</param>
        /// <param name="triangle">The triangle to be filled.</param>
        public void Get(uint index, [NotNull] Triangle3d triangle)
        {
            int idx = (int)index;

            if (IsIndexed)
            {
                triangle.A = vertices[(int)indices[idx * 3]];
                triangle.B = vertices[(int)indices[idx * 3 + 1]];
                triangle.C = vertices[(int)indices[idx * 3 + 2]];
            }
            else
            {
                triangle.A = vertices[3 * idx];
                triangle.B = vertices[3 * idx + 1];
                triangle.C = vertices[3 * idx + 2];
            }
        }

        /// <summary>
        /// Obtains a collection of triangles.
        /// </summary>
        /// <param name="index">The base index.</param>
        /// <param name="count">Number of triangles.</param>
        /// <returns>The triangle collection.</returns>
        public Triangle3d[] Get(uint index, uint count)
        {
            Triangle3d[] data = new Triangle3d[count];
            Get(index, data);
            return data;
        }

        /// <summary>
        /// Obtains triangles.
        /// </summary>
        /// <param name="index">The triangle index.</param>
        /// <param name="triangles">Data to be filled.</param>
        public void Get(uint index, Triangle3d[] triangles)
        {
            for (int i = 0; i < triangles.Length; i++)
            {
                triangles[i] = Get((uint)(index + i));
            }
        }

        #endregion

        #region ITriangleBuilder3d Members

        public bool IsIndexed 
        { 
            get 
            { 
                return indices != null; 
            } 
        }

        public uint AddControlPoints(params Vector3d[] data)
        {
            if (!IsIndexed && data.Length % 3 != 0)
            {
                throw new ArgumentException("Number of control points must be multiple of 3 if non-indexed soup is used.");
            }

            uint baseIndex = (uint)vertices.Count;
            vertices.AddRange(data);
            return baseIndex;

        }

        public void AddIndexedTriangles(params uint[] indices)
        {
            if (!IsIndexed) throw new InvalidOperationException("Invalid operation exception.");
            if (indices.Length % 3 != 0)
            {
                throw new ArgumentException("Number of indices must be a multiple of 3.");
            }

            this.indices.AddRange(indices);
        }

        #endregion

    }
}
