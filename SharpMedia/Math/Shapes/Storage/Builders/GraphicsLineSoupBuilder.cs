// This file was generated by TemplateEngine from template source 'GraphicsLineSoupBuilder'
// using template 'GraphicsLineSoupBuilder. Do not modify this file directly, modify it from template source.

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace SharpMedia.Math.Shapes.Storage.Builders
{

    /// <summary>
    /// A triangle soup builder.
    /// </summary>
    public class GraphicsLineSoupBuilder : BaseTopologySet, ITopologySetBuilder<GraphicsLineSoup>,
        ILineBuilder2f, ILineBuilder2d, ILineBuilder3f, ILineBuilder3d
    {
        #region Private Members
        uint vertexCount = 0;
        bool isMapped = false;
        #endregion

        #region Helper Methods

        void AssertMapped()
        {
            AssertNotDisposed();
            if (!isMapped) throw new InvalidOperationException("Method expects buffers to be mapped.");
        }

        void AssertUnMapped()
        {
            AssertNotDisposed();
            if (isMapped) throw new InvalidOperationException("Method expects buffers to be un-mapped.");
        }

        void AssertNotDisposed()
        {
            if (query == null) throw new ObjectDisposedException("Object was already 'disposed' using finish, invalid call.");
        }

        #endregion

        #region ITopologySetBuilder<GraphicsTriangleSoup> Members

        public uint MaxControlPoints
        {
            get
            {
                AssertMapped();
                return query.MaxControlPoints;
            }
        }

        public GraphicsLineSoup Finish()
        {
            AssertUnMapped();
            ControlPointQuery q = query;
            ShapeIndexBufferView i = indexBuffer;
            query = null;
            return new GraphicsLineSoup(q, i, shapeCount);
        }

        #endregion

        #region ITopologySet Members

        public override uint ControlPointsPerShape
        {
            get { return 2; }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="query"></param>
        /// <param name="indexBuffer"></param>
        public GraphicsLineSoupBuilder(ControlPointQuery query, ShapeIndexBufferView indexBuffer)
        {
            this.query = query;
            this.indexBuffer = indexBuffer;
        }

        #endregion

        #region Vertex Control

        
		//#foreach instanced to 'Vector2d'


        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="controlPoint">The control point position.</param>
        /// <remarks>This is not performance-wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(Vector2d controlPoint)
        {
            return AddControlPoint(CommonComponents.Position, controlPoint);
        }

        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="positionComponent">The position component.</param>
        /// <param name="controlPoint">The control point position</param>
        /// <remarks>This is not performance wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(string positionComponent, Vector2d controlPoint)
        {
            AssertMapped();

            query.Set(positionComponent, vertexCount, controlPoint);
            return vertexCount++;
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(params Vector2d[] controlPoints)
        {
            return AddControlPoints(CommonComponents.Position, controlPoints);
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(string positionComponent, params Vector2d[] controlPoints)
        {
            AssertMapped();

            uint tmp = vertexCount;
            query.Set(positionComponent, vertexCount, controlPoints);
            vertexCount += (uint)controlPoints.Length;

            return tmp;
        }

        //#endfor instanced to 'Vector2d'

		//#foreach instanced to 'Vector2f'


        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="controlPoint">The control point position.</param>
        /// <remarks>This is not performance-wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(Vector2f controlPoint)
        {
            return AddControlPoint(CommonComponents.Position, controlPoint);
        }

        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="positionComponent">The position component.</param>
        /// <param name="controlPoint">The control point position</param>
        /// <remarks>This is not performance wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(string positionComponent, Vector2f controlPoint)
        {
            AssertMapped();

            query.Set(positionComponent, vertexCount, controlPoint);
            return vertexCount++;
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(params Vector2f[] controlPoints)
        {
            return AddControlPoints(CommonComponents.Position, controlPoints);
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(string positionComponent, params Vector2f[] controlPoints)
        {
            AssertMapped();

            uint tmp = vertexCount;
            query.Set(positionComponent, vertexCount, controlPoints);
            vertexCount += (uint)controlPoints.Length;

            return tmp;
        }

        //#endfor instanced to 'Vector2f'

		//#foreach instanced to 'Vector3d'


        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="controlPoint">The control point position.</param>
        /// <remarks>This is not performance-wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(Vector3d controlPoint)
        {
            return AddControlPoint(CommonComponents.Position, controlPoint);
        }

        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="positionComponent">The position component.</param>
        /// <param name="controlPoint">The control point position</param>
        /// <remarks>This is not performance wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(string positionComponent, Vector3d controlPoint)
        {
            AssertMapped();

            query.Set(positionComponent, vertexCount, controlPoint);
            return vertexCount++;
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(params Vector3d[] controlPoints)
        {
            return AddControlPoints(CommonComponents.Position, controlPoints);
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(string positionComponent, params Vector3d[] controlPoints)
        {
            AssertMapped();

            uint tmp = vertexCount;
            query.Set(positionComponent, vertexCount, controlPoints);
            vertexCount += (uint)controlPoints.Length;

            return tmp;
        }

        //#endfor instanced to 'Vector3d'

		//#foreach instanced to 'Vector3f'


        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="controlPoint">The control point position.</param>
        /// <remarks>This is not performance-wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(Vector3f controlPoint)
        {
            return AddControlPoint(CommonComponents.Position, controlPoint);
        }

        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="positionComponent">The position component.</param>
        /// <param name="controlPoint">The control point position</param>
        /// <remarks>This is not performance wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(string positionComponent, Vector3f controlPoint)
        {
            AssertMapped();

            query.Set(positionComponent, vertexCount, controlPoint);
            return vertexCount++;
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(params Vector3f[] controlPoints)
        {
            return AddControlPoints(CommonComponents.Position, controlPoints);
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(string positionComponent, params Vector3f[] controlPoints)
        {
            AssertMapped();

            uint tmp = vertexCount;
            query.Set(positionComponent, vertexCount, controlPoints);
            vertexCount += (uint)controlPoints.Length;

            return tmp;
        }

        //#endfor instanced to 'Vector3f'

		//#foreach instanced to 'Vector4d'


        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="controlPoint">The control point position.</param>
        /// <remarks>This is not performance-wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(Vector4d controlPoint)
        {
            return AddControlPoint(CommonComponents.Position, controlPoint);
        }

        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="positionComponent">The position component.</param>
        /// <param name="controlPoint">The control point position</param>
        /// <remarks>This is not performance wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(string positionComponent, Vector4d controlPoint)
        {
            AssertMapped();

            query.Set(positionComponent, vertexCount, controlPoint);
            return vertexCount++;
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(params Vector4d[] controlPoints)
        {
            return AddControlPoints(CommonComponents.Position, controlPoints);
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(string positionComponent, params Vector4d[] controlPoints)
        {
            AssertMapped();

            uint tmp = vertexCount;
            query.Set(positionComponent, vertexCount, controlPoints);
            vertexCount += (uint)controlPoints.Length;

            return tmp;
        }

        //#endfor instanced to 'Vector4d'

		//#foreach instanced to 'Vector4f'


        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="controlPoint">The control point position.</param>
        /// <remarks>This is not performance-wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(Vector4f controlPoint)
        {
            return AddControlPoint(CommonComponents.Position, controlPoint);
        }

        /// <summary>
        /// Adds a control point at new index.
        /// </summary>
        /// <param name="positionComponent">The position component.</param>
        /// <param name="controlPoint">The control point position</param>
        /// <remarks>This is not performance wise function call.</remarks>
        /// <returns>The index of control point.</returns>
        public uint AddControlPoint(string positionComponent, Vector4f controlPoint)
        {
            AssertMapped();

            query.Set(positionComponent, vertexCount, controlPoint);
            return vertexCount++;
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(params Vector4f[] controlPoints)
        {
            return AddControlPoints(CommonComponents.Position, controlPoints);
        }

        /// <summary>
        /// Adds control points.
        /// </summary>
        /// <param name="controlPoints">Control points.</param>
        /// <returns>The index of first control points, all others follow.</returns>
        public uint AddControlPoints(string positionComponent, params Vector4f[] controlPoints)
        {
            AssertMapped();

            uint tmp = vertexCount;
            query.Set(positionComponent, vertexCount, controlPoints);
            vertexCount += (uint)controlPoints.Length;

            return tmp;
        }

        //#endfor instanced to 'Vector4f'


        #endregion

        #region Shape Control

        
		//#foreach instanced to 'Byte'


        /// <summary>
        /// Adds an indexed triangle.
        /// </summary>
        /// <param name="id1">First control point index.</param>
        /// <param name="id2">Second control point index.</param>
        public void AddIndexedLine(byte id1, byte id2)
        {
            AssertMapped();
            if (indexBuffer == null)
            {
                throw new InvalidOperationException("Index buffer not bound, cannot add indexed triangle.");
            }

            indexBuffer.Set(shapeCount * 2, new byte[] { id1, id2 });
            shapeCount++;
        }

        /// <summary>
        /// Adds indexed triangles.
        /// </summary>
        /// <param name="indices">The indices to use.</param>
        public void AddIndexedLines(params byte[] indices)
        {
            AssertMapped();
            if (indexBuffer == null)
            {
                throw new InvalidOperationException("Index buffer not bound, cannot add indexed triangle.");
            }

            if (indices.Length % 2 != 0)
            {
                throw new ArgumentException("Indices count must be multiple of 2 in order to use line segment.");
            }

            indexBuffer.Set(shapeCount * 2, indices);
            shapeCount += (uint)indices.Length / 2;
        }

        //#endfor instanced to 'Byte'

		//#foreach instanced to 'UInt16'


        /// <summary>
        /// Adds an indexed triangle.
        /// </summary>
        /// <param name="id1">First control point index.</param>
        /// <param name="id2">Second control point index.</param>
        public void AddIndexedLine(ushort id1, ushort id2)
        {
            AssertMapped();
            if (indexBuffer == null)
            {
                throw new InvalidOperationException("Index buffer not bound, cannot add indexed triangle.");
            }

            indexBuffer.Set(shapeCount * 2, new ushort[] { id1, id2 });
            shapeCount++;
        }

        /// <summary>
        /// Adds indexed triangles.
        /// </summary>
        /// <param name="indices">The indices to use.</param>
        public void AddIndexedLines(params ushort[] indices)
        {
            AssertMapped();
            if (indexBuffer == null)
            {
                throw new InvalidOperationException("Index buffer not bound, cannot add indexed triangle.");
            }

            if (indices.Length % 2 != 0)
            {
                throw new ArgumentException("Indices count must be multiple of 2 in order to use line segment.");
            }

            indexBuffer.Set(shapeCount * 2, indices);
            shapeCount += (uint)indices.Length / 2;
        }

        //#endfor instanced to 'UInt16'

		//#foreach instanced to 'UInt32'


        /// <summary>
        /// Adds an indexed triangle.
        /// </summary>
        /// <param name="id1">First control point index.</param>
        /// <param name="id2">Second control point index.</param>
        public void AddIndexedLine(uint id1, uint id2)
        {
            AssertMapped();
            if (indexBuffer == null)
            {
                throw new InvalidOperationException("Index buffer not bound, cannot add indexed triangle.");
            }

            indexBuffer.Set(shapeCount * 2, new uint[] { id1, id2 });
            shapeCount++;
        }

        /// <summary>
        /// Adds indexed triangles.
        /// </summary>
        /// <param name="indices">The indices to use.</param>
        public void AddIndexedLines(params uint[] indices)
        {
            AssertMapped();
            if (indexBuffer == null)
            {
                throw new InvalidOperationException("Index buffer not bound, cannot add indexed triangle.");
            }

            if (indices.Length % 2 != 0)
            {
                throw new ArgumentException("Indices count must be multiple of 2 in order to use line segment.");
            }

            indexBuffer.Set(shapeCount * 2, indices);
            shapeCount += (uint)indices.Length / 2;
        }

        //#endfor instanced to 'UInt32'


        #endregion

        #region Strip Control

        
		//#foreach instanced to 'Vector2d'


        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(bool linkFirstToLast, params Vector2d[] data)
        {
            AddLineStrip(CommonComponents.Position, linkFirstToLast, data);
        }

        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="positionComponent">The position component name.</param>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(string positionComponent, bool linkFirstToLast, params Vector2d[] data)
        {
            int length = linkFirstToLast ? data.Length * 2 : data.Length * 2 - 2;

            if (IsIndexed)
            {
                uint baseIndex = AddControlPoints(positionComponent, data);

                // We create indices.
                uint[] indices = new uint[length];

                // We set them.
                for (int i = 0; i < data.Length - 1; i++)
                {
                    indices[2 * i] = (uint)(baseIndex + i);
                    indices[2 * i] = (uint)(baseIndex + i + 1);
                }

                if (linkFirstToLast)
                {
                    indices[indices.Length - 2] = (uint)(baseIndex + data.Length - 1);
                    indices[indices.Length - 1] = baseIndex;
                }

                AddIndexedLines(indices);
            }
            else
            {
                // We need to convert.
                Vector2d[] newData = new Vector2d[length];

                for (int i = 0; i < data.Length - 1; i++)
                {
                    newData[2*i] = data[i];
                    newData[2 * i + 1] = data[i + 1];
                }

                if (linkFirstToLast)
                {
                    newData[newData.Length - 2] = data[data.Length - 1];
                    newData[newData.Length - 1] = data[0];
                }

                AddControlPoints(newData);
            }
        }

        //#endfor instanced to 'Vector2d'

		//#foreach instanced to 'Vector2f'


        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(bool linkFirstToLast, params Vector2f[] data)
        {
            AddLineStrip(CommonComponents.Position, linkFirstToLast, data);
        }

        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="positionComponent">The position component name.</param>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(string positionComponent, bool linkFirstToLast, params Vector2f[] data)
        {
            int length = linkFirstToLast ? data.Length * 2 : data.Length * 2 - 2;

            if (IsIndexed)
            {
                uint baseIndex = AddControlPoints(positionComponent, data);

                // We create indices.
                uint[] indices = new uint[length];

                // We set them.
                for (int i = 0; i < data.Length - 1; i++)
                {
                    indices[2 * i] = (uint)(baseIndex + i);
                    indices[2 * i] = (uint)(baseIndex + i + 1);
                }

                if (linkFirstToLast)
                {
                    indices[indices.Length - 2] = (uint)(baseIndex + data.Length - 1);
                    indices[indices.Length - 1] = baseIndex;
                }

                AddIndexedLines(indices);
            }
            else
            {
                // We need to convert.
                Vector2f[] newData = new Vector2f[length];

                for (int i = 0; i < data.Length - 1; i++)
                {
                    newData[2*i] = data[i];
                    newData[2 * i + 1] = data[i + 1];
                }

                if (linkFirstToLast)
                {
                    newData[newData.Length - 2] = data[data.Length - 1];
                    newData[newData.Length - 1] = data[0];
                }

                AddControlPoints(newData);
            }
        }

        //#endfor instanced to 'Vector2f'

		//#foreach instanced to 'Vector3d'


        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(bool linkFirstToLast, params Vector3d[] data)
        {
            AddLineStrip(CommonComponents.Position, linkFirstToLast, data);
        }

        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="positionComponent">The position component name.</param>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(string positionComponent, bool linkFirstToLast, params Vector3d[] data)
        {
            int length = linkFirstToLast ? data.Length * 2 : data.Length * 2 - 2;

            if (IsIndexed)
            {
                uint baseIndex = AddControlPoints(positionComponent, data);

                // We create indices.
                uint[] indices = new uint[length];

                // We set them.
                for (int i = 0; i < data.Length - 1; i++)
                {
                    indices[2 * i] = (uint)(baseIndex + i);
                    indices[2 * i] = (uint)(baseIndex + i + 1);
                }

                if (linkFirstToLast)
                {
                    indices[indices.Length - 2] = (uint)(baseIndex + data.Length - 1);
                    indices[indices.Length - 1] = baseIndex;
                }

                AddIndexedLines(indices);
            }
            else
            {
                // We need to convert.
                Vector3d[] newData = new Vector3d[length];

                for (int i = 0; i < data.Length - 1; i++)
                {
                    newData[2*i] = data[i];
                    newData[2 * i + 1] = data[i + 1];
                }

                if (linkFirstToLast)
                {
                    newData[newData.Length - 2] = data[data.Length - 1];
                    newData[newData.Length - 1] = data[0];
                }

                AddControlPoints(newData);
            }
        }

        //#endfor instanced to 'Vector3d'

		//#foreach instanced to 'Vector3f'


        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(bool linkFirstToLast, params Vector3f[] data)
        {
            AddLineStrip(CommonComponents.Position, linkFirstToLast, data);
        }

        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="positionComponent">The position component name.</param>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(string positionComponent, bool linkFirstToLast, params Vector3f[] data)
        {
            int length = linkFirstToLast ? data.Length * 2 : data.Length * 2 - 2;

            if (IsIndexed)
            {
                uint baseIndex = AddControlPoints(positionComponent, data);

                // We create indices.
                uint[] indices = new uint[length];

                // We set them.
                for (int i = 0; i < data.Length - 1; i++)
                {
                    indices[2 * i] = (uint)(baseIndex + i);
                    indices[2 * i] = (uint)(baseIndex + i + 1);
                }

                if (linkFirstToLast)
                {
                    indices[indices.Length - 2] = (uint)(baseIndex + data.Length - 1);
                    indices[indices.Length - 1] = baseIndex;
                }

                AddIndexedLines(indices);
            }
            else
            {
                // We need to convert.
                Vector3f[] newData = new Vector3f[length];

                for (int i = 0; i < data.Length - 1; i++)
                {
                    newData[2*i] = data[i];
                    newData[2 * i + 1] = data[i + 1];
                }

                if (linkFirstToLast)
                {
                    newData[newData.Length - 2] = data[data.Length - 1];
                    newData[newData.Length - 1] = data[0];
                }

                AddControlPoints(newData);
            }
        }

        //#endfor instanced to 'Vector3f'

		//#foreach instanced to 'Vector4d'


        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(bool linkFirstToLast, params Vector4d[] data)
        {
            AddLineStrip(CommonComponents.Position, linkFirstToLast, data);
        }

        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="positionComponent">The position component name.</param>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(string positionComponent, bool linkFirstToLast, params Vector4d[] data)
        {
            int length = linkFirstToLast ? data.Length * 2 : data.Length * 2 - 2;

            if (IsIndexed)
            {
                uint baseIndex = AddControlPoints(positionComponent, data);

                // We create indices.
                uint[] indices = new uint[length];

                // We set them.
                for (int i = 0; i < data.Length - 1; i++)
                {
                    indices[2 * i] = (uint)(baseIndex + i);
                    indices[2 * i] = (uint)(baseIndex + i + 1);
                }

                if (linkFirstToLast)
                {
                    indices[indices.Length - 2] = (uint)(baseIndex + data.Length - 1);
                    indices[indices.Length - 1] = baseIndex;
                }

                AddIndexedLines(indices);
            }
            else
            {
                // We need to convert.
                Vector4d[] newData = new Vector4d[length];

                for (int i = 0; i < data.Length - 1; i++)
                {
                    newData[2*i] = data[i];
                    newData[2 * i + 1] = data[i + 1];
                }

                if (linkFirstToLast)
                {
                    newData[newData.Length - 2] = data[data.Length - 1];
                    newData[newData.Length - 1] = data[0];
                }

                AddControlPoints(newData);
            }
        }

        //#endfor instanced to 'Vector4d'

		//#foreach instanced to 'Vector4f'


        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(bool linkFirstToLast, params Vector4f[] data)
        {
            AddLineStrip(CommonComponents.Position, linkFirstToLast, data);
        }

        /// <summary>
        /// Adds a line strip.
        /// </summary>
        /// <param name="positionComponent">The position component name.</param>
        /// <param name="linkFirstToLast">Should first be linked to last.</param>
        /// <param name="data">The actual data.</param>
        public void AddLineStrip(string positionComponent, bool linkFirstToLast, params Vector4f[] data)
        {
            int length = linkFirstToLast ? data.Length * 2 : data.Length * 2 - 2;

            if (IsIndexed)
            {
                uint baseIndex = AddControlPoints(positionComponent, data);

                // We create indices.
                uint[] indices = new uint[length];

                // We set them.
                for (int i = 0; i < data.Length - 1; i++)
                {
                    indices[2 * i] = (uint)(baseIndex + i);
                    indices[2 * i] = (uint)(baseIndex + i + 1);
                }

                if (linkFirstToLast)
                {
                    indices[indices.Length - 2] = (uint)(baseIndex + data.Length - 1);
                    indices[indices.Length - 1] = baseIndex;
                }

                AddIndexedLines(indices);
            }
            else
            {
                // We need to convert.
                Vector4f[] newData = new Vector4f[length];

                for (int i = 0; i < data.Length - 1; i++)
                {
                    newData[2*i] = data[i];
                    newData[2 * i + 1] = data[i + 1];
                }

                if (linkFirstToLast)
                {
                    newData[newData.Length - 2] = data[data.Length - 1];
                    newData[newData.Length - 1] = data[0];
                }

                AddControlPoints(newData);
            }
        }

        //#endfor instanced to 'Vector4f'


        #endregion

    }
}
