// This file was generated by TemplateEngine from template source 'PolygonTesselation'
// using template 'PolygonTesselation. Do not modify this file directly, modify it from template source.

using System;
using System.Collections.Generic;
using System.Text;

namespace SharpMedia.Math.Shapes.Algorithms
{
    /// <summary>
    /// Tesselation options.
    /// </summary>
    [Flags]
    public enum TesselationOptions
    {
        None = 0,

        /// <summary>
        /// Holes are identified using bounding boxes. They have the same
        /// orientation as other parts.
        /// </summary>
        BoundableHolesIdentify = 1,

        /// <summary>
        /// Holes are identified by having different orientation.
        /// </summary>
        HolesIdentifyOrientation = 8,

        /// <summary>
        /// Counter-clockwise polygon orientation.
        /// </summary>
        CCW = 2
    }

    /// <summary>
    /// A tesselation edge type.
    /// </summary>
    internal enum TesselationVertexType
    {
        Regular,
        Start,
        End,
        Split,
        Merge
    }

    
		//#foreach instanced to 'Vector2d'


    /// <summary>
    /// A vertex class.
    /// </summary>
    internal class TesselationVertex2d : IComparable<TesselationVertex2d>
    {
        #region Helper Methods

        /// <summary>
        /// Checks if it is a left-turn vertex.
        /// </summary>
        /// <returns></returns>
        public bool IsLeftTurn()
        {
            return Angle(PreviousEdge.Vertex1.ProjectedPosition,
                ProjectedPosition, NextEdge.Vertex2.ProjectedPosition) <= (double)MathHelper.PI;

        }

        /// <summary>
        /// Identifies the vertex.
        /// </summary>
        public void IdentifyVertex()
        {
            bool leftTurn = IsLeftTurn(); //< Angle < 180 degrees


            Vector2d
                     p1 = PreviousEdge.Vertex1.ProjectedPosition,
                     p2 = NextEdge.Vertex2.ProjectedPosition;

            if (p1.Y <= ProjectedPosition.Y && p2.Y <= ProjectedPosition.Y)
            {
                VertexType = leftTurn ? TesselationVertexType.Start : TesselationVertexType.Split;
            }
            else if (p1.Y >= ProjectedPosition.Y && p2.Y >= ProjectedPosition.Y)
            {
                VertexType = leftTurn ? TesselationVertexType.End : TesselationVertexType.Merge;
            }
            else
            {
                VertexType = TesselationVertexType.Regular;
            }
        }

        #endregion

        #region Monotone Isolation Data

        /// <summary>
        /// Previous edge.
        /// </summary>
        public TesselationEdge2d PreviousEdge;

        /// <summary>
        /// Current edge.
        /// </summary>
        public TesselationEdge2d NextEdge;

        /// <summary>
        /// The vertex type.
        /// </summary>
        public TesselationVertexType VertexType;

        /// <summary>
        /// Projected position for tesselation.
        /// </summary>
        public Vector2d ProjectedPosition;

        /// <summary>
        /// Additional diagonals on vertex.
        /// </summary>
        public List<TesselationEdge2d> AdditionalDiagonals;

        /// <summary>
        /// Number of times vertex was visited.
        /// </summary>
        public uint VisitCount = 0;

        /// <summary>
        /// Number of links.
        /// </summary>
        public uint Links
        {
            get
            {
                if (AdditionalDiagonals == null) return 1;
                else return (uint)AdditionalDiagonals.Count + 1;
            }
        }

        /// <summary>
        /// Tries to visit it.
        /// </summary>
        /// <returns></returns>
        public bool TryVisit()
        {
            if (!CanVisit) return false;

            VisitCount++;
            return true;
        }

        /// <summary>
        /// Can is be visited.
        /// </summary>
        public bool CanVisit
        {
            get
            {
                if ((int)VisitCount >= Links)
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Adds vertex to visited.
        /// </summary>
        /// <param name="toVisit"></param>
        public void AddToVisits(Stack<TesselationVertex2d> toVisit)
        {
            VisitCount++;

            if ((int)VisitCount < Links)
            {
                toVisit.Push(this);
            }
        }

        /// <summary>
        /// Angle btween positions, in radians.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="v"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public double Angle(Vector2d prev, Vector2d v, Vector2d next)
        {
            Vector2d v1 = v - prev;
            Vector2d v2 = next - v;

            // We compute cosine.
            double cos = (v1 * v2) / (v1.Length * v2.Length);

            // We compute sine.
            double sinSign = ((new Vector3d(v1.X, v1.Y, 0.0)) ^ (new Vector3d(v2.X, v2.Y, 0.0))).Z;


            double acos = MathHelper.ACos(cos);

            if (sinSign >= 0.0)
            {
                return (double)MathHelper.PI - acos;
            }
            else
            {
                return (double)MathHelper.PI + acos;
            }
        }

        /// <summary>
        /// Angle between vertices, in radians.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="v"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public double Angle(TesselationVertex2d prev, TesselationVertex2d v, TesselationVertex2d next)
        {
            return Angle(prev.ProjectedPosition, v.ProjectedPosition, next.ProjectedPosition);
        }

        /// <summary>
        /// Gets the new vertex in chain, or null if ended.
        /// </summary>
        /// <param name="ending"></param>
        /// <returns></returns>
        public TesselationVertex2d NextVertex(TesselationVertex2d prev)
        {
            // We find the next vertex that is most left turn.
            TesselationVertex2d next = null;

            if (AdditionalDiagonals == null)
            {
                next = this.NextEdge.Vertex2;
                return next;
            }

            // We turn to left, take leftmost.
            double angle = (this.NextEdge.Vertex2 != prev && this.NextEdge.Vertex2.CanVisit) ?
                this.NextEdge.Vertex2.Angle(prev, this, this.NextEdge.Vertex2) : (double)10.0;
            next = angle == (double)10.0 ? null : this.NextEdge.Vertex2;

            for (int i = 0; i < AdditionalDiagonals.Count; i++)
            {
                TesselationVertex2d other = AdditionalDiagonals[i].Vertex1 == this ? AdditionalDiagonals[i].Vertex2 :
                    AdditionalDiagonals[i].Vertex1;
                if (other == prev) continue;



                double angle2 = Angle(prev, this, other);

                if (angle2 < angle)
                {
                    angle = angle2;
                    next = other;
                }
            }

            return next;
        }

        #endregion

        #region Mesh Data

        /// <summary>
        /// The vertex index.
        /// </summary>
        public uint VertexIndex;

        #endregion

        #region IComparable<TesselationVertex2d> Members

        public int CompareTo(TesselationVertex2d other)
        {
            int cmp = this.ProjectedPosition.Y.CompareTo(other.ProjectedPosition.Y);
            if (cmp == 0)
            {
                return this.ProjectedPosition.X.CompareTo(other.ProjectedPosition.X);
            }
            return -cmp;
        }

        #endregion
    }

    /// <summary>
    /// A tesselation edge.
    /// </summary>
    internal class TesselationEdge2d
    {
        #region Public Members

        /// <summary>
        /// The first vertex.
        /// </summary>
        public TesselationVertex2d Vertex1;

        /// <summary>
        /// The second vertex.
        /// </summary>
        public TesselationVertex2d Vertex2;

        /// <summary>
        /// Helper vertex of edge.
        /// </summary>
        public TesselationVertex2d Helper;


        #endregion
    }

    /// <summary>
    /// A sweep edge structure.
    /// </summary>
    internal class TesselationSweepEdges2d
    {
        #region Private Members
        List<TesselationEdge2d> sweepEdges = new List<TesselationEdge2d>();
        #endregion

        #region Private Methods

        double Distance(Vector2d p, TesselationEdge2d edge)
        {
            Vector2d p1 = edge.Vertex1.ProjectedPosition,
                        p2 = edge.Vertex2.ProjectedPosition;

            // Special case horizontal.
            if (MathHelper.NearEqual(p1.X, p2.X))
            {
                if (p1.X < p.X) return p.X - p1.X;
                return double.PositiveInfinity;
            }

            // We have line.
            double k = (p2.Y - p1.Y) / (p2.X - p1.X);
            double n = p2.Y - k * p2.X;

            double xInt = (p.Y - n) / k;

            if (MathHelper.NearEqual(xInt, p.X) || xInt < p.X) return p.X - xInt;
            return double.PositiveInfinity;
        }

        #endregion

        #region Public Members

        /// <summary>
        /// Deletes an edge.
        /// </summary>
        /// <param name="index"></param>
        public void Delete(int index)
        {
            sweepEdges.RemoveAt(index);
        }

        /// <summary>
        /// Deletes an edge.
        /// </summary>
        /// <param name="edge"></param>
        public void Delete(TesselationEdge2d edge)
        {
            sweepEdges.Remove(edge);
        }

        /// <summary>
        /// Adds an edge.
        /// </summary>
        /// <param name="edge"></param>
        public void Add(TesselationEdge2d edge)
        {
            sweepEdges.Add(edge);
        }

        /// <summary>
        /// Checks if interior is to right.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public bool InteriorToRight(Vector2d p)
        {
            // We count number of edges to the right.
            int c = 0;
            for (int i = 0; i < sweepEdges.Count; i++)
            {
                if (Distance(p, sweepEdges[i]) == double.PositiveInfinity) c++;
            }

            return c % 2 == 1;
        }

        /// <summary>
        /// Finds left edge.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public int FindLeft(Vector2d p)
        {
            // We find edge that is the closest to left.
            int bestMatch = 0;
            double bestDist = Distance(p, sweepEdges[0]);

            // Greedy search for best match.
            for (int i = 1; i < sweepEdges.Count; i++)
            {
                double dist = Distance(p, sweepEdges[i]);
                if (dist < bestDist)
                {
                    bestDist = dist;
                    bestMatch = i;
                }
            }

            return bestMatch;
        }

        /// <summary>
        /// Obtains tesselation edge (indexed).
        /// </summary>
        /// <param name="idx"></param>
        /// <returns></returns>
        public TesselationEdge2d this[int idx]
        {
            get { return sweepEdges[idx]; }
        }

        #endregion
    }


    //#endfor instanced to 'Vector2d'

		//#foreach instanced to 'Vector2f'


    /// <summary>
    /// A vertex class.
    /// </summary>
    internal class TesselationVertex2f : IComparable<TesselationVertex2f>
    {
        #region Helper Methods

        /// <summary>
        /// Checks if it is a left-turn vertex.
        /// </summary>
        /// <returns></returns>
        public bool IsLeftTurn()
        {
            return Angle(PreviousEdge.Vertex1.ProjectedPosition,
                ProjectedPosition, NextEdge.Vertex2.ProjectedPosition) <= (float)MathHelper.PI;

        }

        /// <summary>
        /// Identifies the vertex.
        /// </summary>
        public void IdentifyVertex()
        {
            bool leftTurn = IsLeftTurn(); //< Angle < 180 degrees


            Vector2f
                     p1 = PreviousEdge.Vertex1.ProjectedPosition,
                     p2 = NextEdge.Vertex2.ProjectedPosition;

            if (p1.Y <= ProjectedPosition.Y && p2.Y <= ProjectedPosition.Y)
            {
                VertexType = leftTurn ? TesselationVertexType.Start : TesselationVertexType.Split;
            }
            else if (p1.Y >= ProjectedPosition.Y && p2.Y >= ProjectedPosition.Y)
            {
                VertexType = leftTurn ? TesselationVertexType.End : TesselationVertexType.Merge;
            }
            else
            {
                VertexType = TesselationVertexType.Regular;
            }
        }

        #endregion

        #region Monotone Isolation Data

        /// <summary>
        /// Previous edge.
        /// </summary>
        public TesselationEdge2f PreviousEdge;

        /// <summary>
        /// Current edge.
        /// </summary>
        public TesselationEdge2f NextEdge;

        /// <summary>
        /// The vertex type.
        /// </summary>
        public TesselationVertexType VertexType;

        /// <summary>
        /// Projected position for tesselation.
        /// </summary>
        public Vector2f ProjectedPosition;

        /// <summary>
        /// Additional diagonals on vertex.
        /// </summary>
        public List<TesselationEdge2f> AdditionalDiagonals;

        /// <summary>
        /// Number of times vertex was visited.
        /// </summary>
        public uint VisitCount = 0;

        /// <summary>
        /// Number of links.
        /// </summary>
        public uint Links
        {
            get
            {
                if (AdditionalDiagonals == null) return 1;
                else return (uint)AdditionalDiagonals.Count + 1;
            }
        }

        /// <summary>
        /// Tries to visit it.
        /// </summary>
        /// <returns></returns>
        public bool TryVisit()
        {
            if (!CanVisit) return false;

            VisitCount++;
            return true;
        }

        /// <summary>
        /// Can is be visited.
        /// </summary>
        public bool CanVisit
        {
            get
            {
                if ((int)VisitCount >= Links)
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Adds vertex to visited.
        /// </summary>
        /// <param name="toVisit"></param>
        public void AddToVisits(Stack<TesselationVertex2f> toVisit)
        {
            VisitCount++;

            if ((int)VisitCount < Links)
            {
                toVisit.Push(this);
            }
        }

        /// <summary>
        /// Angle btween positions, in radians.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="v"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public float Angle(Vector2f prev, Vector2f v, Vector2f next)
        {
            Vector2f v1 = v - prev;
            Vector2f v2 = next - v;

            // We compute cosine.
            float cos = (v1 * v2) / (v1.Length * v2.Length);

            // We compute sine.
            float sinSign = ((new Vector3f(v1.X, v1.Y, 0.0f)) ^ (new Vector3f(v2.X, v2.Y, 0.0f))).Z;


            float acos = MathHelper.ACos(cos);

            if (sinSign >= 0.0f)
            {
                return (float)MathHelper.PI - acos;
            }
            else
            {
                return (float)MathHelper.PI + acos;
            }
        }

        /// <summary>
        /// Angle between vertices, in radians.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="v"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public float Angle(TesselationVertex2f prev, TesselationVertex2f v, TesselationVertex2f next)
        {
            return Angle(prev.ProjectedPosition, v.ProjectedPosition, next.ProjectedPosition);
        }

        /// <summary>
        /// Gets the new vertex in chain, or null if ended.
        /// </summary>
        /// <param name="ending"></param>
        /// <returns></returns>
        public TesselationVertex2f NextVertex(TesselationVertex2f prev)
        {
            // We find the next vertex that is most left turn.
            TesselationVertex2f next = null;

            if (AdditionalDiagonals == null)
            {
                next = this.NextEdge.Vertex2;
                return next;
            }

            // We turn to left, take leftmost.
            float angle = (this.NextEdge.Vertex2 != prev && this.NextEdge.Vertex2.CanVisit) ?
                this.NextEdge.Vertex2.Angle(prev, this, this.NextEdge.Vertex2) : (float)10.0;
            next = angle == (float)10.0 ? null : this.NextEdge.Vertex2;

            for (int i = 0; i < AdditionalDiagonals.Count; i++)
            {
                TesselationVertex2f other = AdditionalDiagonals[i].Vertex1 == this ? AdditionalDiagonals[i].Vertex2 :
                    AdditionalDiagonals[i].Vertex1;
                if (other == prev) continue;



                float angle2 = Angle(prev, this, other);

                if (angle2 < angle)
                {
                    angle = angle2;
                    next = other;
                }
            }

            return next;
        }

        #endregion

        #region Mesh Data

        /// <summary>
        /// The vertex index.
        /// </summary>
        public uint VertexIndex;

        #endregion

        #region IComparable<TesselationVertex2f> Members

        public int CompareTo(TesselationVertex2f other)
        {
            int cmp = this.ProjectedPosition.Y.CompareTo(other.ProjectedPosition.Y);
            if (cmp == 0)
            {
                return this.ProjectedPosition.X.CompareTo(other.ProjectedPosition.X);
            }
            return -cmp;
        }

        #endregion
    }

    /// <summary>
    /// A tesselation edge.
    /// </summary>
    internal class TesselationEdge2f
    {
        #region Public Members

        /// <summary>
        /// The first vertex.
        /// </summary>
        public TesselationVertex2f Vertex1;

        /// <summary>
        /// The second vertex.
        /// </summary>
        public TesselationVertex2f Vertex2;

        /// <summary>
        /// Helper vertex of edge.
        /// </summary>
        public TesselationVertex2f Helper;


        #endregion
    }

    /// <summary>
    /// A sweep edge structure.
    /// </summary>
    internal class TesselationSweepEdges2f
    {
        #region Private Members
        List<TesselationEdge2f> sweepEdges = new List<TesselationEdge2f>();
        #endregion

        #region Private Methods

        float Distance(Vector2f p, TesselationEdge2f edge)
        {
            Vector2f p1 = edge.Vertex1.ProjectedPosition,
                        p2 = edge.Vertex2.ProjectedPosition;

            // Special case horizontal.
            if (MathHelper.NearEqual(p1.X, p2.X))
            {
                if (p1.X < p.X) return p.X - p1.X;
                return float.PositiveInfinity;
            }

            // We have line.
            float k = (p2.Y - p1.Y) / (p2.X - p1.X);
            float n = p2.Y - k * p2.X;

            float xInt = (p.Y - n) / k;

            if (MathHelper.NearEqual(xInt, p.X) || xInt < p.X) return p.X - xInt;
            return float.PositiveInfinity;
        }

        #endregion

        #region Public Members

        /// <summary>
        /// Deletes an edge.
        /// </summary>
        /// <param name="index"></param>
        public void Delete(int index)
        {
            sweepEdges.RemoveAt(index);
        }

        /// <summary>
        /// Deletes an edge.
        /// </summary>
        /// <param name="edge"></param>
        public void Delete(TesselationEdge2f edge)
        {
            sweepEdges.Remove(edge);
        }

        /// <summary>
        /// Adds an edge.
        /// </summary>
        /// <param name="edge"></param>
        public void Add(TesselationEdge2f edge)
        {
            sweepEdges.Add(edge);
        }

        /// <summary>
        /// Checks if interior is to right.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public bool InteriorToRight(Vector2f p)
        {
            // We count number of edges to the right.
            int c = 0;
            for (int i = 0; i < sweepEdges.Count; i++)
            {
                if (Distance(p, sweepEdges[i]) == float.PositiveInfinity) c++;
            }

            return c % 2 == 1;
        }

        /// <summary>
        /// Finds left edge.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public int FindLeft(Vector2f p)
        {
            // We find edge that is the closest to left.
            int bestMatch = 0;
            float bestDist = Distance(p, sweepEdges[0]);

            // Greedy search for best match.
            for (int i = 1; i < sweepEdges.Count; i++)
            {
                float dist = Distance(p, sweepEdges[i]);
                if (dist < bestDist)
                {
                    bestDist = dist;
                    bestMatch = i;
                }
            }

            return bestMatch;
        }

        /// <summary>
        /// Obtains tesselation edge (indexed).
        /// </summary>
        /// <param name="idx"></param>
        /// <returns></returns>
        public TesselationEdge2f this[int idx]
        {
            get { return sweepEdges[idx]; }
        }

        #endregion
    }


    //#endfor instanced to 'Vector2f'

		//#foreach instanced to 'Vector3d'


    /// <summary>
    /// A vertex class.
    /// </summary>
    internal class TesselationVertex3d : IComparable<TesselationVertex3d>
    {
        #region Helper Methods

        /// <summary>
        /// Checks if it is a left-turn vertex.
        /// </summary>
        /// <returns></returns>
        public bool IsLeftTurn()
        {
            return Angle(PreviousEdge.Vertex1.ProjectedPosition,
                ProjectedPosition, NextEdge.Vertex2.ProjectedPosition) <= (double)MathHelper.PI;

        }

        /// <summary>
        /// Identifies the vertex.
        /// </summary>
        public void IdentifyVertex()
        {
            bool leftTurn = IsLeftTurn(); //< Angle < 180 degrees


            Vector2d
                     p1 = PreviousEdge.Vertex1.ProjectedPosition,
                     p2 = NextEdge.Vertex2.ProjectedPosition;

            if (p1.Y <= ProjectedPosition.Y && p2.Y <= ProjectedPosition.Y)
            {
                VertexType = leftTurn ? TesselationVertexType.Start : TesselationVertexType.Split;
            }
            else if (p1.Y >= ProjectedPosition.Y && p2.Y >= ProjectedPosition.Y)
            {
                VertexType = leftTurn ? TesselationVertexType.End : TesselationVertexType.Merge;
            }
            else
            {
                VertexType = TesselationVertexType.Regular;
            }
        }

        #endregion

        #region Monotone Isolation Data

        /// <summary>
        /// Previous edge.
        /// </summary>
        public TesselationEdge3d PreviousEdge;

        /// <summary>
        /// Current edge.
        /// </summary>
        public TesselationEdge3d NextEdge;

        /// <summary>
        /// The vertex type.
        /// </summary>
        public TesselationVertexType VertexType;

        /// <summary>
        /// Projected position for tesselation.
        /// </summary>
        public Vector2d ProjectedPosition;

        /// <summary>
        /// Additional diagonals on vertex.
        /// </summary>
        public List<TesselationEdge3d> AdditionalDiagonals;

        /// <summary>
        /// Number of times vertex was visited.
        /// </summary>
        public uint VisitCount = 0;

        /// <summary>
        /// Number of links.
        /// </summary>
        public uint Links
        {
            get
            {
                if (AdditionalDiagonals == null) return 1;
                else return (uint)AdditionalDiagonals.Count + 1;
            }
        }

        /// <summary>
        /// Tries to visit it.
        /// </summary>
        /// <returns></returns>
        public bool TryVisit()
        {
            if (!CanVisit) return false;

            VisitCount++;
            return true;
        }

        /// <summary>
        /// Can is be visited.
        /// </summary>
        public bool CanVisit
        {
            get
            {
                if ((int)VisitCount >= Links)
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Adds vertex to visited.
        /// </summary>
        /// <param name="toVisit"></param>
        public void AddToVisits(Stack<TesselationVertex3d> toVisit)
        {
            VisitCount++;

            if ((int)VisitCount < Links)
            {
                toVisit.Push(this);
            }
        }

        /// <summary>
        /// Angle btween positions, in radians.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="v"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public double Angle(Vector2d prev, Vector2d v, Vector2d next)
        {
            Vector2d v1 = v - prev;
            Vector2d v2 = next - v;

            // We compute cosine.
            double cos = (v1 * v2) / (v1.Length * v2.Length);

            // We compute sine.
            double sinSign = ((new Vector3d(v1.X, v1.Y, 0.0)) ^ (new Vector3d(v2.X, v2.Y, 0.0))).Z;


            double acos = MathHelper.ACos(cos);

            if (sinSign >= 0.0)
            {
                return (double)MathHelper.PI - acos;
            }
            else
            {
                return (double)MathHelper.PI + acos;
            }
        }

        /// <summary>
        /// Angle between vertices, in radians.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="v"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public double Angle(TesselationVertex3d prev, TesselationVertex3d v, TesselationVertex3d next)
        {
            return Angle(prev.ProjectedPosition, v.ProjectedPosition, next.ProjectedPosition);
        }

        /// <summary>
        /// Gets the new vertex in chain, or null if ended.
        /// </summary>
        /// <param name="ending"></param>
        /// <returns></returns>
        public TesselationVertex3d NextVertex(TesselationVertex3d prev)
        {
            // We find the next vertex that is most left turn.
            TesselationVertex3d next = null;

            if (AdditionalDiagonals == null)
            {
                next = this.NextEdge.Vertex2;
                return next;
            }

            // We turn to left, take leftmost.
            double angle = (this.NextEdge.Vertex2 != prev && this.NextEdge.Vertex2.CanVisit) ?
                this.NextEdge.Vertex2.Angle(prev, this, this.NextEdge.Vertex2) : (double)10.0;
            next = angle == (double)10.0 ? null : this.NextEdge.Vertex2;

            for (int i = 0; i < AdditionalDiagonals.Count; i++)
            {
                TesselationVertex3d other = AdditionalDiagonals[i].Vertex1 == this ? AdditionalDiagonals[i].Vertex2 :
                    AdditionalDiagonals[i].Vertex1;
                if (other == prev) continue;



                double angle2 = Angle(prev, this, other);

                if (angle2 < angle)
                {
                    angle = angle2;
                    next = other;
                }
            }

            return next;
        }

        #endregion

        #region Mesh Data

        /// <summary>
        /// The vertex index.
        /// </summary>
        public uint VertexIndex;

        #endregion

        #region IComparable<TesselationVertex3d> Members

        public int CompareTo(TesselationVertex3d other)
        {
            int cmp = this.ProjectedPosition.Y.CompareTo(other.ProjectedPosition.Y);
            if (cmp == 0)
            {
                return this.ProjectedPosition.X.CompareTo(other.ProjectedPosition.X);
            }
            return -cmp;
        }

        #endregion
    }

    /// <summary>
    /// A tesselation edge.
    /// </summary>
    internal class TesselationEdge3d
    {
        #region Public Members

        /// <summary>
        /// The first vertex.
        /// </summary>
        public TesselationVertex3d Vertex1;

        /// <summary>
        /// The second vertex.
        /// </summary>
        public TesselationVertex3d Vertex2;

        /// <summary>
        /// Helper vertex of edge.
        /// </summary>
        public TesselationVertex3d Helper;


        #endregion
    }

    /// <summary>
    /// A sweep edge structure.
    /// </summary>
    internal class TesselationSweepEdges3d
    {
        #region Private Members
        List<TesselationEdge3d> sweepEdges = new List<TesselationEdge3d>();
        #endregion

        #region Private Methods

        double Distance(Vector2d p, TesselationEdge3d edge)
        {
            Vector2d p1 = edge.Vertex1.ProjectedPosition,
                        p2 = edge.Vertex2.ProjectedPosition;

            // Special case horizontal.
            if (MathHelper.NearEqual(p1.X, p2.X))
            {
                if (p1.X < p.X) return p.X - p1.X;
                return double.PositiveInfinity;
            }

            // We have line.
            double k = (p2.Y - p1.Y) / (p2.X - p1.X);
            double n = p2.Y - k * p2.X;

            double xInt = (p.Y - n) / k;

            if (MathHelper.NearEqual(xInt, p.X) || xInt < p.X) return p.X - xInt;
            return double.PositiveInfinity;
        }

        #endregion

        #region Public Members

        /// <summary>
        /// Deletes an edge.
        /// </summary>
        /// <param name="index"></param>
        public void Delete(int index)
        {
            sweepEdges.RemoveAt(index);
        }

        /// <summary>
        /// Deletes an edge.
        /// </summary>
        /// <param name="edge"></param>
        public void Delete(TesselationEdge3d edge)
        {
            sweepEdges.Remove(edge);
        }

        /// <summary>
        /// Adds an edge.
        /// </summary>
        /// <param name="edge"></param>
        public void Add(TesselationEdge3d edge)
        {
            sweepEdges.Add(edge);
        }

        /// <summary>
        /// Checks if interior is to right.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public bool InteriorToRight(Vector2d p)
        {
            // We count number of edges to the right.
            int c = 0;
            for (int i = 0; i < sweepEdges.Count; i++)
            {
                if (Distance(p, sweepEdges[i]) == double.PositiveInfinity) c++;
            }

            return c % 2 == 1;
        }

        /// <summary>
        /// Finds left edge.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public int FindLeft(Vector2d p)
        {
            // We find edge that is the closest to left.
            int bestMatch = 0;
            double bestDist = Distance(p, sweepEdges[0]);

            // Greedy search for best match.
            for (int i = 1; i < sweepEdges.Count; i++)
            {
                double dist = Distance(p, sweepEdges[i]);
                if (dist < bestDist)
                {
                    bestDist = dist;
                    bestMatch = i;
                }
            }

            return bestMatch;
        }

        /// <summary>
        /// Obtains tesselation edge (indexed).
        /// </summary>
        /// <param name="idx"></param>
        /// <returns></returns>
        public TesselationEdge3d this[int idx]
        {
            get { return sweepEdges[idx]; }
        }

        #endregion
    }


    //#endfor instanced to 'Vector3d'

		//#foreach instanced to 'Vector3f'


    /// <summary>
    /// A vertex class.
    /// </summary>
    internal class TesselationVertex3f : IComparable<TesselationVertex3f>
    {
        #region Helper Methods

        /// <summary>
        /// Checks if it is a left-turn vertex.
        /// </summary>
        /// <returns></returns>
        public bool IsLeftTurn()
        {
            return Angle(PreviousEdge.Vertex1.ProjectedPosition,
                ProjectedPosition, NextEdge.Vertex2.ProjectedPosition) <= (float)MathHelper.PI;

        }

        /// <summary>
        /// Identifies the vertex.
        /// </summary>
        public void IdentifyVertex()
        {
            bool leftTurn = IsLeftTurn(); //< Angle < 180 degrees


            Vector2f
                     p1 = PreviousEdge.Vertex1.ProjectedPosition,
                     p2 = NextEdge.Vertex2.ProjectedPosition;

            if (p1.Y <= ProjectedPosition.Y && p2.Y <= ProjectedPosition.Y)
            {
                VertexType = leftTurn ? TesselationVertexType.Start : TesselationVertexType.Split;
            }
            else if (p1.Y >= ProjectedPosition.Y && p2.Y >= ProjectedPosition.Y)
            {
                VertexType = leftTurn ? TesselationVertexType.End : TesselationVertexType.Merge;
            }
            else
            {
                VertexType = TesselationVertexType.Regular;
            }
        }

        #endregion

        #region Monotone Isolation Data

        /// <summary>
        /// Previous edge.
        /// </summary>
        public TesselationEdge3f PreviousEdge;

        /// <summary>
        /// Current edge.
        /// </summary>
        public TesselationEdge3f NextEdge;

        /// <summary>
        /// The vertex type.
        /// </summary>
        public TesselationVertexType VertexType;

        /// <summary>
        /// Projected position for tesselation.
        /// </summary>
        public Vector2f ProjectedPosition;

        /// <summary>
        /// Additional diagonals on vertex.
        /// </summary>
        public List<TesselationEdge3f> AdditionalDiagonals;

        /// <summary>
        /// Number of times vertex was visited.
        /// </summary>
        public uint VisitCount = 0;

        /// <summary>
        /// Number of links.
        /// </summary>
        public uint Links
        {
            get
            {
                if (AdditionalDiagonals == null) return 1;
                else return (uint)AdditionalDiagonals.Count + 1;
            }
        }

        /// <summary>
        /// Tries to visit it.
        /// </summary>
        /// <returns></returns>
        public bool TryVisit()
        {
            if (!CanVisit) return false;

            VisitCount++;
            return true;
        }

        /// <summary>
        /// Can is be visited.
        /// </summary>
        public bool CanVisit
        {
            get
            {
                if ((int)VisitCount >= Links)
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Adds vertex to visited.
        /// </summary>
        /// <param name="toVisit"></param>
        public void AddToVisits(Stack<TesselationVertex3f> toVisit)
        {
            VisitCount++;

            if ((int)VisitCount < Links)
            {
                toVisit.Push(this);
            }
        }

        /// <summary>
        /// Angle btween positions, in radians.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="v"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public float Angle(Vector2f prev, Vector2f v, Vector2f next)
        {
            Vector2f v1 = v - prev;
            Vector2f v2 = next - v;

            // We compute cosine.
            float cos = (v1 * v2) / (v1.Length * v2.Length);

            // We compute sine.
            float sinSign = ((new Vector3f(v1.X, v1.Y, 0.0f)) ^ (new Vector3f(v2.X, v2.Y, 0.0f))).Z;


            float acos = MathHelper.ACos(cos);

            if (sinSign >= 0.0f)
            {
                return (float)MathHelper.PI - acos;
            }
            else
            {
                return (float)MathHelper.PI + acos;
            }
        }

        /// <summary>
        /// Angle between vertices, in radians.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="v"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public float Angle(TesselationVertex3f prev, TesselationVertex3f v, TesselationVertex3f next)
        {
            return Angle(prev.ProjectedPosition, v.ProjectedPosition, next.ProjectedPosition);
        }

        /// <summary>
        /// Gets the new vertex in chain, or null if ended.
        /// </summary>
        /// <param name="ending"></param>
        /// <returns></returns>
        public TesselationVertex3f NextVertex(TesselationVertex3f prev)
        {
            // We find the next vertex that is most left turn.
            TesselationVertex3f next = null;

            if (AdditionalDiagonals == null)
            {
                next = this.NextEdge.Vertex2;
                return next;
            }

            // We turn to left, take leftmost.
            float angle = (this.NextEdge.Vertex2 != prev && this.NextEdge.Vertex2.CanVisit) ?
                this.NextEdge.Vertex2.Angle(prev, this, this.NextEdge.Vertex2) : (float)10.0;
            next = angle == (float)10.0 ? null : this.NextEdge.Vertex2;

            for (int i = 0; i < AdditionalDiagonals.Count; i++)
            {
                TesselationVertex3f other = AdditionalDiagonals[i].Vertex1 == this ? AdditionalDiagonals[i].Vertex2 :
                    AdditionalDiagonals[i].Vertex1;
                if (other == prev) continue;



                float angle2 = Angle(prev, this, other);

                if (angle2 < angle)
                {
                    angle = angle2;
                    next = other;
                }
            }

            return next;
        }

        #endregion

        #region Mesh Data

        /// <summary>
        /// The vertex index.
        /// </summary>
        public uint VertexIndex;

        #endregion

        #region IComparable<TesselationVertex3f> Members

        public int CompareTo(TesselationVertex3f other)
        {
            int cmp = this.ProjectedPosition.Y.CompareTo(other.ProjectedPosition.Y);
            if (cmp == 0)
            {
                return this.ProjectedPosition.X.CompareTo(other.ProjectedPosition.X);
            }
            return -cmp;
        }

        #endregion
    }

    /// <summary>
    /// A tesselation edge.
    /// </summary>
    internal class TesselationEdge3f
    {
        #region Public Members

        /// <summary>
        /// The first vertex.
        /// </summary>
        public TesselationVertex3f Vertex1;

        /// <summary>
        /// The second vertex.
        /// </summary>
        public TesselationVertex3f Vertex2;

        /// <summary>
        /// Helper vertex of edge.
        /// </summary>
        public TesselationVertex3f Helper;


        #endregion
    }

    /// <summary>
    /// A sweep edge structure.
    /// </summary>
    internal class TesselationSweepEdges3f
    {
        #region Private Members
        List<TesselationEdge3f> sweepEdges = new List<TesselationEdge3f>();
        #endregion

        #region Private Methods

        float Distance(Vector2f p, TesselationEdge3f edge)
        {
            Vector2f p1 = edge.Vertex1.ProjectedPosition,
                        p2 = edge.Vertex2.ProjectedPosition;

            // Special case horizontal.
            if (MathHelper.NearEqual(p1.X, p2.X))
            {
                if (p1.X < p.X) return p.X - p1.X;
                return float.PositiveInfinity;
            }

            // We have line.
            float k = (p2.Y - p1.Y) / (p2.X - p1.X);
            float n = p2.Y - k * p2.X;

            float xInt = (p.Y - n) / k;

            if (MathHelper.NearEqual(xInt, p.X) || xInt < p.X) return p.X - xInt;
            return float.PositiveInfinity;
        }

        #endregion

        #region Public Members

        /// <summary>
        /// Deletes an edge.
        /// </summary>
        /// <param name="index"></param>
        public void Delete(int index)
        {
            sweepEdges.RemoveAt(index);
        }

        /// <summary>
        /// Deletes an edge.
        /// </summary>
        /// <param name="edge"></param>
        public void Delete(TesselationEdge3f edge)
        {
            sweepEdges.Remove(edge);
        }

        /// <summary>
        /// Adds an edge.
        /// </summary>
        /// <param name="edge"></param>
        public void Add(TesselationEdge3f edge)
        {
            sweepEdges.Add(edge);
        }

        /// <summary>
        /// Checks if interior is to right.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public bool InteriorToRight(Vector2f p)
        {
            // We count number of edges to the right.
            int c = 0;
            for (int i = 0; i < sweepEdges.Count; i++)
            {
                if (Distance(p, sweepEdges[i]) == float.PositiveInfinity) c++;
            }

            return c % 2 == 1;
        }

        /// <summary>
        /// Finds left edge.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public int FindLeft(Vector2f p)
        {
            // We find edge that is the closest to left.
            int bestMatch = 0;
            float bestDist = Distance(p, sweepEdges[0]);

            // Greedy search for best match.
            for (int i = 1; i < sweepEdges.Count; i++)
            {
                float dist = Distance(p, sweepEdges[i]);
                if (dist < bestDist)
                {
                    bestDist = dist;
                    bestMatch = i;
                }
            }

            return bestMatch;
        }

        /// <summary>
        /// Obtains tesselation edge (indexed).
        /// </summary>
        /// <param name="idx"></param>
        /// <returns></returns>
        public TesselationEdge3f this[int idx]
        {
            get { return sweepEdges[idx]; }
        }

        #endregion
    }


    //#endfor instanced to 'Vector3f'



    /// <summary>
    /// A polygon tesselator. Given a group of polygons (contours), a triangle mesh is generated.
    /// </summary>
    public static class PolygonTesselation
    {
        
		//#foreach instanced to 'Vector2d'


        #region Vector2d

        #region Private Helpers

        const double RandomizationFactor2d = (double)1e-4;


                /// <summary>
        /// Is polygon clockwise in order.
        /// </summary>
        /// <param name="polygon"></param>
        /// <returns></returns>
        static bool IsClockwise(params Vector2d[] positions)
        {
            // We check winding order.
            double area = 0.0;
            for (int j = 1; j < positions.Length; j++)
            {
                // FIXME: this is Z projection assumed.
                area += positions[j - 1].X * positions[j].Y - positions[j - 1].Y * positions[j].X;
            }

            return area <= 0.0;

        }

        static void Reverse(Vector2d[] positions)
        {
            int n = positions.Length;
            for (int i = 0; i < n / 2; i++)
            {
                Vector2d v = positions[i];
                positions[i] = positions[n - i - 1];
                positions[n - 1 - i] = v;
            }
        }

        /// <summary>
        /// Obtains first hole.
        /// </summary>
        /// <param name="polygons"></param>
        /// <returns></returns>
        static uint GetFirstHole(List<Vector2d[]> polygons)
        {
            uint[] idx = GetBoundableHoles(polygons);
            for (int i = 0; i < idx.Length; i++)
            {
                if (idx[i] != uint.MaxValue) return (uint)i;
            }
            return uint.MaxValue;
        }

        /// <summary>
        /// Gets indices of polygons that are holes, together with bounding box of polygon.
        /// </summary>
        /// <param name="polygons"></param>
        /// <returns></returns>
        static uint[] GetBoundableHoles(List<Vector2d[]> polygons)
        {
            uint[] holes = new uint[polygons.Count];
            

            // We compute all bounding boxes.
            Vector2d[] mins = new Vector2d[polygons.Count];
            Vector2d[] maxs = new Vector2d[polygons.Count];

            for (int i = 0; i < polygons.Count; i++)
            {
                GetBoundingBox(polygons[i], out mins[i], out maxs[i]);
            }

            // We initialize holes.
            for (int i = 0; i < polygons.Count; i++) holes[i] = uint.MaxValue;

            // A hole is an element that is completely inside other polygon.
            for (int i = 0; i < polygons.Count; i++)
            {
                for (int j = 0; j < polygons.Count; j++)
                {
                    if (i == j) continue;

                    // We check if j is completelly inside i.
                    
                        if (mins[j].X >= mins[i].Y && mins[j].Y >= mins[i].Y  &&
                           maxs[j].X <= maxs[i].Y && maxs[j].Y <= maxs[i].Y)
                    
                    {
                        holes[j] = (uint)i;
                        break;
                    }

                    

                }
            }

            return holes;
        }



        /// <summary>
        /// Obtains bounding box of polygon.
        /// </summary>
        /// <param name="polygon"></param>
        /// <param name="min"></param>
        /// <param name="max"></param>
        static void GetBoundingBox(Vector2d[] polygon, out Vector2d min, out Vector2d max)
        {
            
            min = new Vector2d(double.PositiveInfinity, double.PositiveInfinity);
            max = new Vector2d(double.NegativeInfinity, double.NegativeInfinity);
            

            for(int i = 0; i < polygon.Length; i++)
            {
                Vector2d v = polygon[i];

                min.X = min.X < v.X ? min.X : v.X;
                min.Y = min.Y < v.Y ? min.Y : v.Y;
                

                max.X = max.X > v.X ? max.X : v.X;
                max.Y = max.Y > v.Y ? max.Y : v.Y;
                
            }
        }


        /// <summary>
        /// Is vertex left turn.
        /// </summary>
        static bool IsLeftTurn(TesselationVertex2d vertex)
        {
            return vertex.IsLeftTurn();
        }

        /// <summary>
        /// Is interior to right.
        /// </summary>
        static bool InteriorToRight(TesselationVertex2d vertex)
        {
            // We check if point a bit to the right is contained in triangle.
            Vector2d p1 = vertex.PreviousEdge.Vertex1.ProjectedPosition;
            Vector2d p2 = vertex.NextEdge.Vertex2.ProjectedPosition;

            bool isLeftTurn = IsLeftTurn(vertex);

            // We intersect diagonals.

            // Special case.
            if (MathHelper.NearEqual(p1.X, p2.X))
            {
                if (isLeftTurn)
                {
                    return vertex.ProjectedPosition.X <= p1.X;
                }
                else
                {
                    return vertex.ProjectedPosition.X >= p1.X;
                }
            }

            // We now do intersection.
            double k = (p2.Y - p1.Y) / (p2.X - p1.X);
            double n = p1.Y - k * p1.X;

            double x = (vertex.ProjectedPosition.Y - n) / k;


            if (isLeftTurn)
            {
                return x >= vertex.ProjectedPosition.X;
            }
            else
            {
                return x < vertex.ProjectedPosition.X;
            }

        }

        /// <summary>
        /// Debugs a vertex.
        /// </summary>
        static void DebugVertices(TesselationVertex2d root)
        {

            Console.WriteLine();
            Console.WriteLine("=====");
            TesselationVertex2d v = root.NextEdge.Vertex2;

            while (true)
            {
                Console.WriteLine("{0}, {1}", v.ProjectedPosition.X, v.ProjectedPosition.Y);

                if (v == root) break;

                TesselationVertex2d t = v.NextEdge.Vertex2;
                if (t.PreviousEdge.Vertex1 != v)
                {
                    Console.Write("Error link.");
                }

                v = t;
                   
            }
        }

        /// <summary>
        /// Creates a linked list.
        /// </summary>
        static void CreateLinked(List<Vector2d[]> polygons, List<TesselationVertex2d> vertices, List<TesselationVertex2d> beginning,
            Storage.Builders.ITriangleBuilder2d builder, TesselationOptions options)
        {
            bool windingClockwise = (options & TesselationOptions.CCW) != 0 ? false : true;

 
            uint[] holeParents = null;

            // We may need to identify holes.
            if ((options & TesselationOptions.BoundableHolesIdentify) != 0)
            {
                holeParents = GetBoundableHoles(polygons);

                // We reverse those.
                for (int i = 0; i < holeParents.Length; i++)
                {
                    if (holeParents[i] == uint.MaxValue) continue;
                    Reverse(polygons[i]);
                }
            }
            

            // X-range compute.
            double xmax = double.NegativeInfinity;
            double xmin = double.PositiveInfinity;

            int startPolygon = 0;
            TesselationEdge2d currentEdge = null;

            // Seperate polygons.
            TesselationVertex2d[][] perPolygonData = new TesselationVertex2d[polygons.Count][];


            // We reverse them.
            if (!windingClockwise)
            {
                for (int i = 0; i < polygons.Count; i++)
                {
                    Reverse(polygons[i]);
                }
            }

            // We now identify all holes based on orientation
            if ((options & TesselationOptions.HolesIdentifyOrientation) != 0)
            {
                holeParents = GetBoundableHoles(polygons);

                // Some may not be holes, we should check this.
            }

            for (int j = 0; j < polygons.Count; j++)
            {
                Vector2d[] positions = polygons[j];
                perPolygonData[j] = new TesselationVertex2d[positions.Length];

                uint baseIndex = builder.AddControlPoints(positions);

                for (int i = 0; i < positions.Length; i++)
                {
                    Vector2d v = positions[i];

                    // We compute bounding box.
                    Vector2d projPosition;
                    
                    projPosition = v;
                    

                    if (projPosition.X > xmax) xmax = projPosition.X;
                    if (projPosition.X < xmin) xmin = projPosition.X;

                    // Now we link appropriatelly.
                    TesselationVertex2d vertex = new TesselationVertex2d();

                    vertex.PreviousEdge = currentEdge;

                    vertex.VertexIndex = (uint)(baseIndex + i);

                    vertex.ProjectedPosition = projPosition;

                    // We add vertex.
                    vertices.Add(vertex);

                    // We also link edge.
                    if (currentEdge != null) currentEdge.Vertex2 = vertex;
                    currentEdge = new TesselationEdge2d();
                    currentEdge.Vertex1 = vertex;
                    vertex.NextEdge = currentEdge;

                    perPolygonData[j][i] = vertex;

                }

                // We need for beginnings of polygons.
                beginning.Add(vertices[startPolygon]);

                // We end polygon.
                currentEdge.Vertex2 = vertices[startPolygon];

                vertices[startPolygon].PreviousEdge = currentEdge;

                startPolygon = vertices.Count;
                currentEdge = null;
            }


            // TODO: may add already sorted hint.

            // We need to handle hole merge.
            if (holeParents != null)
            {
                for (int i = 0; i < holeParents.Length; i++)
                {
                    if (holeParents[i] == uint.MaxValue) continue;

                    uint parent = holeParents[i];

                    TesselationVertex2d[] parentData = perPolygonData[parent];
                    TesselationVertex2d[] holeData = perPolygonData[i];

                    // We sort parent.
                    Array.Sort(parentData);

                    // We find top of hole.
                    TesselationVertex2d top = holeData[0];
                    for (int j = 1; j < holeData.Length; j++)
                    {
                        if (holeData[j].ProjectedPosition.Y > top.ProjectedPosition.Y) top = holeData[j];
                    }

                    // We now find the shortest link that exists.
                    int lower = ~Array.BinarySearch(parentData, top);

                    // We find appropriate vertex.
                    TesselationVertex2d linkTo = parentData[lower-1];

                    // TODO: we should check it does not intersect anything

                    // We now link, new vertices have small y displacement.
                    double disp = (xmax - xmin) * RandomizationFactor2d;
                    if (linkTo.ProjectedPosition.X < top.ProjectedPosition.X) disp *= -1.0f;

                    TesselationEdge2d diagTo = new TesselationEdge2d();
                    TesselationEdge2d diagBack = new TesselationEdge2d();

                    // The link repl vertex.
                    TesselationVertex2d linkToRepl = new TesselationVertex2d();
                    linkToRepl.ProjectedPosition = linkTo.ProjectedPosition;
                    linkToRepl.ProjectedPosition.Y -= disp;
                    linkToRepl.VertexIndex = linkTo.VertexIndex;
                    linkToRepl.PreviousEdge = linkTo.PreviousEdge;
                    linkTo.PreviousEdge.Vertex2 = linkToRepl;
                    linkToRepl.NextEdge = diagTo;


                    vertices.Add(linkToRepl);

                    // We create new vertex and link appropriatelly.
                    TesselationVertex2d topRepl = new TesselationVertex2d();
                    topRepl.ProjectedPosition = top.ProjectedPosition;
                    topRepl.ProjectedPosition.Y -= disp;
                    topRepl.VertexIndex = top.VertexIndex;
                    topRepl.PreviousEdge = diagTo;
                    topRepl.NextEdge = top.NextEdge;
                    top.NextEdge.Vertex1 = topRepl;
                    

                    vertices.Add(topRepl);

                    top.NextEdge = diagBack;
                    linkTo.PreviousEdge = diagBack;

                    // We also fill diagonals.
                    diagTo.Vertex1 = linkToRepl;
                    diagTo.Vertex2 = topRepl;

                    diagBack.Vertex1 = top;
                    diagBack.Vertex2 = linkTo;

                    
                    //DebugVertices(linkToRepl);
                }
            }

            // We perform randomization, so no vertices have the same y coordinate.
            // We allow maximum of 5 randomizations.
            for (int z = 0; ; z++)
            {
                if (z >= 5) throw new Exception("Randomization failed.");


                double scale = 2.0f * (xmax - xmin) * RandomizationFactor2d;

                // We randomize all of them.
                for (int i = 0; i < vertices.Count; i++)
                {
                    vertices[i].ProjectedPosition.Y += scale * vertices[i].ProjectedPosition.X;
                }

                vertices.Sort();

                // We check if ok.
                bool randomized = true;
                for (int i = 1; i < vertices.Count; i++)
                {
                    if (vertices[i].ProjectedPosition.Y == vertices[i - 1].ProjectedPosition.Y)
                    {
                        randomized = false;
                        break;
                    }
                }

                if (randomized) break;
            }
            

            for (int i = 0; i < vertices.Count; i++)
            {
                // We identify vertex.
                vertices[i].IdentifyVertex();
            }

            
        }



        /// <summary>
        /// Makes polygon monothone.
        /// </summary>
        /// <param name="vertices"></param>
        /// <returns></returns>
        static List<TesselationEdge2d> MakeMonothone(List<TesselationVertex2d> vertices)
        {
            // 1) Vertices are sorted.
            TesselationSweepEdges2d edges = new TesselationSweepEdges2d();
            List<TesselationEdge2d> split = new List<TesselationEdge2d>();

            // 2) We now go top-bottom.
            for (int i = 0; i < vertices.Count; i++)
            {
                switch (vertices[i].VertexType)
                {
                    case TesselationVertexType.Regular:
                        HandleRegularVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Start:
                        HandleStartVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.End:
                        HandleEndVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Split:
                        HandleSplitVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Merge:
                        HandleMergeVertex(vertices[i], split, edges);
                        break;
                }
            }

            return split;
        }

        static void HandleStartVertex(TesselationVertex2d vertex, List<TesselationEdge2d> splits, TesselationSweepEdges2d edges)
        {
            // We set helper to self.
            vertex.NextEdge.Helper = vertex;

            edges.Add(vertex.NextEdge);
        }

        static void HandleEndVertex(TesselationVertex2d vertex, List<TesselationEdge2d> splits, TesselationSweepEdges2d edges)
        {
            // We handle merge vertex.
            if (vertex.PreviousEdge.Helper != null &&
                vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge2d diag = new TesselationEdge2d();
                diag.Vertex1 = vertex;
                diag.Vertex2 = vertex.PreviousEdge.Helper;

                splits.Add(diag);
            }

            edges.Delete(vertex.PreviousEdge);
        }

        static void HandleSplitVertex(TesselationVertex2d vertex, List<TesselationEdge2d> splits, TesselationSweepEdges2d edges)
        {
            int edgeId =  edges.FindLeft(vertex.ProjectedPosition);

            // We create diagonal
            TesselationEdge2d diag = new TesselationEdge2d();
            diag.Vertex1 = vertex;
            diag.Vertex2 = edges[edgeId].Helper;
            splits.Add(diag);
            
            // Adjust helpers.
            edges[edgeId].Helper = vertex;

            // Add additional helper.
            vertex.NextEdge.Helper = vertex;
            edges.Add(vertex.NextEdge);
            
        }

        static void HandleMergeVertex(TesselationVertex2d vertex, List<TesselationEdge2d> splits, TesselationSweepEdges2d edges)
        {
            // We first check for previos merge.
            if (vertex.PreviousEdge.Helper != null &&
                vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge2d diag = new TesselationEdge2d();
                diag.Vertex1 = vertex;
                diag.Vertex2 = vertex.PreviousEdge.Helper;

                splits.Add(diag);
            }

            // We delete previous edge.
            edges.Delete(vertex.PreviousEdge);

            // We find left edge.
            int leftEdgeId = edges.FindLeft(vertex.ProjectedPosition);

            if (edges[leftEdgeId].Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge2d diag = new TesselationEdge2d();
                diag.Vertex1 = vertex;
                diag.Vertex2 = edges[leftEdgeId].Helper;

                splits.Add(diag);
            }

            // We adjust helper.
            edges[leftEdgeId].Helper = vertex;
        }

        static void HandleRegularVertex(TesselationVertex2d vertex, List<TesselationEdge2d> splits, TesselationSweepEdges2d edges)
        {
            // We skip it if there is no interior to the right.
            if (InteriorToRight(vertex))
            {

                if (vertex.PreviousEdge.Helper != null &&
                    vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
                {
                    TesselationEdge2d diag = new TesselationEdge2d();
                    diag.Vertex1 = vertex;
                    diag.Vertex2 = vertex.PreviousEdge.Helper;

                    splits.Add(diag);
                }

                // We delete previous edge.
                edges.Delete(vertex.PreviousEdge);

                // We insert new edge.
                vertex.NextEdge.Helper = vertex;
                edges.Add(vertex.NextEdge);

            }
            else
            {
                // We insert the merge vertex.
                int edgeId = edges.FindLeft(vertex.ProjectedPosition);
                if (edges[edgeId].Helper.VertexType == TesselationVertexType.Merge)
                {
                    TesselationEdge2d diag = new TesselationEdge2d();
                    diag.Vertex1 = vertex;
                    diag.Vertex2 = edges[edgeId].Helper;

                    splits.Add(diag);
                }

                edges[edgeId].Helper = vertex;
            }
        }

        static bool OnTheSameChain(TesselationVertex2d current, TesselationVertex2d top)
        {
            bool onTheSameChain = false;
            if (current.NextEdge.Vertex2 == top || current.PreviousEdge.Vertex1 == top) onTheSameChain = true;
            if (!onTheSameChain && current.AdditionalDiagonals != null)
            {
                for (int j = 0; j < current.AdditionalDiagonals.Count; j++)
                {
                    if (current.AdditionalDiagonals[j].Vertex1 == top ||
                       current.AdditionalDiagonals[j].Vertex2 == top)
                    {
                        onTheSameChain = true;
                        break;
                    }
                }
            }
            return onTheSameChain;
        }

        /// <summary>
        /// Triangulates monotone polygon. Vertices are added to buffer.
        /// </summary>
        /// <param name="sortedMonothone"></param>
        /// <param name="meshBuilder"></param>
        static void TriangulateMonotone(List<TesselationVertex2d> sorted, 
            Storage.Builders.ITriangleBuilder2d meshBuilder)
        {
            // At least three vertices
            if (sorted.Count < 3) return;

            Stack<TesselationVertex2d> stack = new Stack<TesselationVertex2d>();

            // Identifies vertices on left chain as true, false if right chain.
            bool[] leftChain = new bool[sorted.Count];
            {
                // FIXME: are vertical beginings handled correctly. They do not arise
                // commonly ... so we leave it for now

                TesselationVertex2d left;
                if (sorted[0].ProjectedPosition.X <= sorted[1].ProjectedPosition.X)
                {
                    left = sorted[0];
                    leftChain[0] = true;
                    leftChain[1] = false;
                }
                else
                {
                    left = sorted[1];
                    leftChain[0] = false;
                    leftChain[1] = true;
                }

                // We now set the chains.
                for (int i = 2; i < sorted.Count - 1; i++)
                {
                    TesselationVertex2d current = sorted[i];

                    if (OnTheSameChain(current, left))
                    {
                        leftChain[i] = true;
                        left = current;
                    }
                    else
                    {
                        leftChain[i] = false;
                    }
                }
            }


            // We push first two vertices.
            stack.Push(sorted[0]);
            stack.Push(sorted[1]);

            // We enter the loop.
            for (int i = 2; i < sorted.Count - 1; i++)
            {
                TesselationVertex2d current = sorted[i];
                TesselationVertex2d top = stack.Pop();

                // We check if on the same side (same chain).



                if (OnTheSameChain(current, top))
                {
                    // In this case, we generate diagonals with elements on stack as long as we can
                    // (as long as they are legal).

                    // We link to all vertices we can stack.
                    TesselationVertex2d p1 = top, p2 = null;
                    uint curId = current.VertexIndex;

                    while (stack.Count > 0)
                    {
                        p2 = stack.Pop();

                        
                        // We first check if it is possible (orientation of triangle).
                        Vector3d normal = (p2.ProjectedPosition - p1.ProjectedPosition).Vec3 ^
                            (current.ProjectedPosition - p1.ProjectedPosition).Vec3;

                        bool isIrregular = leftChain[i] ? normal.Z > 0.0 : normal.Z < 0.0;

                        if (isIrregular)
                        {
                            stack.Push(p2);
                            p2 = p1;
                            break;
                        }
                        


                        // We have a triangle, we may need to ensure vertices are added.
                        uint p1Id = p1.VertexIndex;
                        uint p2Id = p2.VertexIndex;

                        // We add triangle and relink.
                        meshBuilder.AddIndexedTriangles(new uint[] {curId, p2Id, p1Id});

                        // We relink.
                        p1 = p2;
                    }

                    // We push back to stack.
                    stack.Push(p2);
                    stack.Push(current);
                }
                // Different chains.
                else
                {
                    // We link to all vertices on stack.
                    TesselationVertex2d p1 = top, p2;
                    uint curId = current.VertexIndex;

                    while (stack.Count > 0)
                    {
                        // We pop the second one.
                        p2 = stack.Pop();

                        // We have a triangle, we may need to ensure vertices are added.
                        uint p1Id = p1.VertexIndex;
                        uint p2Id = p2.VertexIndex;

                        // We now add triangle.
                        meshBuilder.AddIndexedTriangles(new uint[] {curId, p2Id, p1Id });

                        // We relink.
                        p1 = p2;
                    }

                    // At the end, we push current-1 and current.
                    stack.Push(sorted[i - 1]);
                    stack.Push(current);
                }
            }

            // We end it.
            
            if (stack.Count > 0)
            {
                TesselationVertex2d current = sorted[sorted.Count - 1];
                TesselationVertex2d top = stack.Pop();

                while (stack.Count > 0)
                {
                    TesselationVertex2d other = stack.Pop();

                    meshBuilder.AddIndexedTriangles(new uint[] {current.VertexIndex, other.VertexIndex, top.VertexIndex});

                    top = other;
                }
            }
        }

        #endregion

        #region Public Static Members

        /// <summary>
        /// Converts polygon group to triangle mesh.
        /// </summary>
        /// <param name="polygons">The polygon contours.</param>
        /// <param name="builder">The builder where results are written.</param>
        public static void Tesselate(List<Vector2d[]> polygons,
            Storage.Builders.ITriangleBuilder2d builder)
        {
            Tesselate(polygons, builder, TesselationOptions.BoundableHolesIdentify);
        }


        /// <summary>
        /// Converts polygon group to triangle mesh.
        /// </summary>
        /// <param name="polygons">The polygon contours.</param>
        /// <param name="builder">The builder where results are written.</param>
        /// <param name="options">Tesselation options.</param>
        public static void Tesselate(List<Vector2d[]> polygons,
            Storage.Builders.ITriangleBuilder2d builder, TesselationOptions options)
        {
            if (!builder.IsIndexed)
            {
                throw new InvalidOperationException("Only indexed builder supported for now.");
            }


            // We first create linked list.
            List<TesselationVertex2d> vertices = new List<TesselationVertex2d>();
            List<TesselationVertex2d> beginning = new List<TesselationVertex2d>();
            

            CreateLinked(polygons, vertices, beginning, builder, options);

            // We make the polygon monothone by using split diagonals.
            List<TesselationEdge2d> additionalDiagonals = MakeMonothone(vertices);


            {
                // May improve efficiency of algorithm.

                Stack<TesselationVertex2d> toVisit = new Stack<TesselationVertex2d>(10);
                for (int j = 0; j < beginning.Count; j++)
                {
                    toVisit.Push(beginning[j]);
                }

                // We first append diagonals to multi-linked list.
                for (int i = 0; i < additionalDiagonals.Count; i++)
                {
                    // We take the diagonal and add it to vertices.
                    TesselationEdge2d diag = additionalDiagonals[i];

                    if (diag.Vertex1.AdditionalDiagonals == null) diag.Vertex1.AdditionalDiagonals = new List<TesselationEdge2d>();
                    if (diag.Vertex2.AdditionalDiagonals == null) diag.Vertex2.AdditionalDiagonals = new List<TesselationEdge2d>();

                    diag.Vertex1.AdditionalDiagonals.Add(diag);
                    diag.Vertex2.AdditionalDiagonals.Add(diag);

                    // We also push one element of diagonal (in case they are split).
                    toVisit.Push(diag.Vertex1);
                }

                // We start at topmost vertex and create a polygon.
                List<TesselationVertex2d> monothone = new List<TesselationVertex2d>(vertices.Count);
                
                while (toVisit.Count > 0)
                {
                    // We first check if already visited.
                    TesselationVertex2d start = toVisit.Pop();
                    TesselationVertex2d current = start;
                    TesselationVertex2d prev = start.PreviousEdge.Vertex1;
                    if (!start.TryVisit()) continue;

                    // We begin a new monothone
                    monothone.Clear();

                    monothone.Add(start);

                    // We now transverse the polygon.
                    while(true)
                    {
                        TesselationVertex2d t = current;
                        current = current.NextVertex(prev); //< Left order.
                        prev = t;
                        if (current == null || current == start) break;

                        current.AddToVisits(toVisit);
                        monothone.Add(current);
                    }

                    // We sort monotone.
                    monothone.Sort();

                    // Monothone triangulate.
                    TriangulateMonotone(monothone, builder);
                }
            }

        }

        #endregion

        #endregion Vector2d

        //#endfor instanced to 'Vector2d'

		//#foreach instanced to 'Vector2f'


        #region Vector2f

        #region Private Helpers

        const float RandomizationFactor2f = (float)1e-4;


                /// <summary>
        /// Is polygon clockwise in order.
        /// </summary>
        /// <param name="polygon"></param>
        /// <returns></returns>
        static bool IsClockwise(params Vector2f[] positions)
        {
            // We check winding order.
            float area = 0.0f;
            for (int j = 1; j < positions.Length; j++)
            {
                // FIXME: this is Z projection assumed.
                area += positions[j - 1].X * positions[j].Y - positions[j - 1].Y * positions[j].X;
            }

            return area <= 0.0f;

        }

        static void Reverse(Vector2f[] positions)
        {
            int n = positions.Length;
            for (int i = 0; i < n / 2; i++)
            {
                Vector2f v = positions[i];
                positions[i] = positions[n - i - 1];
                positions[n - 1 - i] = v;
            }
        }

        /// <summary>
        /// Obtains first hole.
        /// </summary>
        /// <param name="polygons"></param>
        /// <returns></returns>
        static uint GetFirstHole(List<Vector2f[]> polygons)
        {
            uint[] idx = GetBoundableHoles(polygons);
            for (int i = 0; i < idx.Length; i++)
            {
                if (idx[i] != uint.MaxValue) return (uint)i;
            }
            return uint.MaxValue;
        }

        /// <summary>
        /// Gets indices of polygons that are holes, together with bounding box of polygon.
        /// </summary>
        /// <param name="polygons"></param>
        /// <returns></returns>
        static uint[] GetBoundableHoles(List<Vector2f[]> polygons)
        {
            uint[] holes = new uint[polygons.Count];
            

            // We compute all bounding boxes.
            Vector2f[] mins = new Vector2f[polygons.Count];
            Vector2f[] maxs = new Vector2f[polygons.Count];

            for (int i = 0; i < polygons.Count; i++)
            {
                GetBoundingBox(polygons[i], out mins[i], out maxs[i]);
            }

            // We initialize holes.
            for (int i = 0; i < polygons.Count; i++) holes[i] = uint.MaxValue;

            // A hole is an element that is completely inside other polygon.
            for (int i = 0; i < polygons.Count; i++)
            {
                for (int j = 0; j < polygons.Count; j++)
                {
                    if (i == j) continue;

                    // We check if j is completelly inside i.
                    
                        if (mins[j].X >= mins[i].Y && mins[j].Y >= mins[i].Y  &&
                           maxs[j].X <= maxs[i].Y && maxs[j].Y <= maxs[i].Y)
                    
                    {
                        holes[j] = (uint)i;
                        break;
                    }

                    

                }
            }

            return holes;
        }



        /// <summary>
        /// Obtains bounding box of polygon.
        /// </summary>
        /// <param name="polygon"></param>
        /// <param name="min"></param>
        /// <param name="max"></param>
        static void GetBoundingBox(Vector2f[] polygon, out Vector2f min, out Vector2f max)
        {
            
            min = new Vector2f(float.PositiveInfinity, float.PositiveInfinity);
            max = new Vector2f(float.NegativeInfinity, float.NegativeInfinity);
            

            for(int i = 0; i < polygon.Length; i++)
            {
                Vector2f v = polygon[i];

                min.X = min.X < v.X ? min.X : v.X;
                min.Y = min.Y < v.Y ? min.Y : v.Y;
                

                max.X = max.X > v.X ? max.X : v.X;
                max.Y = max.Y > v.Y ? max.Y : v.Y;
                
            }
        }


        /// <summary>
        /// Is vertex left turn.
        /// </summary>
        static bool IsLeftTurn(TesselationVertex2f vertex)
        {
            return vertex.IsLeftTurn();
        }

        /// <summary>
        /// Is interior to right.
        /// </summary>
        static bool InteriorToRight(TesselationVertex2f vertex)
        {
            // We check if point a bit to the right is contained in triangle.
            Vector2f p1 = vertex.PreviousEdge.Vertex1.ProjectedPosition;
            Vector2f p2 = vertex.NextEdge.Vertex2.ProjectedPosition;

            bool isLeftTurn = IsLeftTurn(vertex);

            // We intersect diagonals.

            // Special case.
            if (MathHelper.NearEqual(p1.X, p2.X))
            {
                if (isLeftTurn)
                {
                    return vertex.ProjectedPosition.X <= p1.X;
                }
                else
                {
                    return vertex.ProjectedPosition.X >= p1.X;
                }
            }

            // We now do intersection.
            float k = (p2.Y - p1.Y) / (p2.X - p1.X);
            float n = p1.Y - k * p1.X;

            float x = (vertex.ProjectedPosition.Y - n) / k;


            if (isLeftTurn)
            {
                return x >= vertex.ProjectedPosition.X;
            }
            else
            {
                return x < vertex.ProjectedPosition.X;
            }

        }

        /// <summary>
        /// Debugs a vertex.
        /// </summary>
        static void DebugVertices(TesselationVertex2f root)
        {

            Console.WriteLine();
            Console.WriteLine("=====");
            TesselationVertex2f v = root.NextEdge.Vertex2;

            while (true)
            {
                Console.WriteLine("{0}, {1}", v.ProjectedPosition.X, v.ProjectedPosition.Y);

                if (v == root) break;

                TesselationVertex2f t = v.NextEdge.Vertex2;
                if (t.PreviousEdge.Vertex1 != v)
                {
                    Console.Write("Error link.");
                }

                v = t;
                   
            }
        }

        /// <summary>
        /// Creates a linked list.
        /// </summary>
        static void CreateLinked(List<Vector2f[]> polygons, List<TesselationVertex2f> vertices, List<TesselationVertex2f> beginning,
            Storage.Builders.ITriangleBuilder2f builder, TesselationOptions options)
        {
            bool windingClockwise = (options & TesselationOptions.CCW) != 0 ? false : true;

 
            uint[] holeParents = null;

            // We may need to identify holes.
            if ((options & TesselationOptions.BoundableHolesIdentify) != 0)
            {
                holeParents = GetBoundableHoles(polygons);

                // We reverse those.
                for (int i = 0; i < holeParents.Length; i++)
                {
                    if (holeParents[i] == uint.MaxValue) continue;
                    Reverse(polygons[i]);
                }
            }
            

            // X-range compute.
            float xmax = float.NegativeInfinity;
            float xmin = float.PositiveInfinity;

            int startPolygon = 0;
            TesselationEdge2f currentEdge = null;

            // Seperate polygons.
            TesselationVertex2f[][] perPolygonData = new TesselationVertex2f[polygons.Count][];


            // We reverse them.
            if (!windingClockwise)
            {
                for (int i = 0; i < polygons.Count; i++)
                {
                    Reverse(polygons[i]);
                }
            }

            // We now identify all holes based on orientation
            if ((options & TesselationOptions.HolesIdentifyOrientation) != 0)
            {
                holeParents = GetBoundableHoles(polygons);

                // Some may not be holes, we should check this.
            }

            for (int j = 0; j < polygons.Count; j++)
            {
                Vector2f[] positions = polygons[j];
                perPolygonData[j] = new TesselationVertex2f[positions.Length];

                uint baseIndex = builder.AddControlPoints(positions);

                for (int i = 0; i < positions.Length; i++)
                {
                    Vector2f v = positions[i];

                    // We compute bounding box.
                    Vector2f projPosition;
                    
                    projPosition = v;
                    

                    if (projPosition.X > xmax) xmax = projPosition.X;
                    if (projPosition.X < xmin) xmin = projPosition.X;

                    // Now we link appropriatelly.
                    TesselationVertex2f vertex = new TesselationVertex2f();

                    vertex.PreviousEdge = currentEdge;

                    vertex.VertexIndex = (uint)(baseIndex + i);

                    vertex.ProjectedPosition = projPosition;

                    // We add vertex.
                    vertices.Add(vertex);

                    // We also link edge.
                    if (currentEdge != null) currentEdge.Vertex2 = vertex;
                    currentEdge = new TesselationEdge2f();
                    currentEdge.Vertex1 = vertex;
                    vertex.NextEdge = currentEdge;

                    perPolygonData[j][i] = vertex;

                }

                // We need for beginnings of polygons.
                beginning.Add(vertices[startPolygon]);

                // We end polygon.
                currentEdge.Vertex2 = vertices[startPolygon];

                vertices[startPolygon].PreviousEdge = currentEdge;

                startPolygon = vertices.Count;
                currentEdge = null;
            }


            // TODO: may add already sorted hint.

            // We need to handle hole merge.
            if (holeParents != null)
            {
                for (int i = 0; i < holeParents.Length; i++)
                {
                    if (holeParents[i] == uint.MaxValue) continue;

                    uint parent = holeParents[i];

                    TesselationVertex2f[] parentData = perPolygonData[parent];
                    TesselationVertex2f[] holeData = perPolygonData[i];

                    // We sort parent.
                    Array.Sort(parentData);

                    // We find top of hole.
                    TesselationVertex2f top = holeData[0];
                    for (int j = 1; j < holeData.Length; j++)
                    {
                        if (holeData[j].ProjectedPosition.Y > top.ProjectedPosition.Y) top = holeData[j];
                    }

                    // We now find the shortest link that exists.
                    int lower = ~Array.BinarySearch(parentData, top);

                    // We find appropriate vertex.
                    TesselationVertex2f linkTo = parentData[lower-1];

                    // TODO: we should check it does not intersect anything

                    // We now link, new vertices have small y displacement.
                    float disp = (xmax - xmin) * RandomizationFactor2f;
                    if (linkTo.ProjectedPosition.X < top.ProjectedPosition.X) disp *= -1.0f;

                    TesselationEdge2f diagTo = new TesselationEdge2f();
                    TesselationEdge2f diagBack = new TesselationEdge2f();

                    // The link repl vertex.
                    TesselationVertex2f linkToRepl = new TesselationVertex2f();
                    linkToRepl.ProjectedPosition = linkTo.ProjectedPosition;
                    linkToRepl.ProjectedPosition.Y -= disp;
                    linkToRepl.VertexIndex = linkTo.VertexIndex;
                    linkToRepl.PreviousEdge = linkTo.PreviousEdge;
                    linkTo.PreviousEdge.Vertex2 = linkToRepl;
                    linkToRepl.NextEdge = diagTo;


                    vertices.Add(linkToRepl);

                    // We create new vertex and link appropriatelly.
                    TesselationVertex2f topRepl = new TesselationVertex2f();
                    topRepl.ProjectedPosition = top.ProjectedPosition;
                    topRepl.ProjectedPosition.Y -= disp;
                    topRepl.VertexIndex = top.VertexIndex;
                    topRepl.PreviousEdge = diagTo;
                    topRepl.NextEdge = top.NextEdge;
                    top.NextEdge.Vertex1 = topRepl;
                    

                    vertices.Add(topRepl);

                    top.NextEdge = diagBack;
                    linkTo.PreviousEdge = diagBack;

                    // We also fill diagonals.
                    diagTo.Vertex1 = linkToRepl;
                    diagTo.Vertex2 = topRepl;

                    diagBack.Vertex1 = top;
                    diagBack.Vertex2 = linkTo;

                    
                    //DebugVertices(linkToRepl);
                }
            }

            // We perform randomization, so no vertices have the same y coordinate.
            // We allow maximum of 5 randomizations.
            for (int z = 0; ; z++)
            {
                if (z >= 5) throw new Exception("Randomization failed.");


                float scale = 2.0f * (xmax - xmin) * RandomizationFactor2f;

                // We randomize all of them.
                for (int i = 0; i < vertices.Count; i++)
                {
                    vertices[i].ProjectedPosition.Y += scale * vertices[i].ProjectedPosition.X;
                }

                vertices.Sort();

                // We check if ok.
                bool randomized = true;
                for (int i = 1; i < vertices.Count; i++)
                {
                    if (vertices[i].ProjectedPosition.Y == vertices[i - 1].ProjectedPosition.Y)
                    {
                        randomized = false;
                        break;
                    }
                }

                if (randomized) break;
            }
            

            for (int i = 0; i < vertices.Count; i++)
            {
                // We identify vertex.
                vertices[i].IdentifyVertex();
            }

            
        }



        /// <summary>
        /// Makes polygon monothone.
        /// </summary>
        /// <param name="vertices"></param>
        /// <returns></returns>
        static List<TesselationEdge2f> MakeMonothone(List<TesselationVertex2f> vertices)
        {
            // 1) Vertices are sorted.
            TesselationSweepEdges2f edges = new TesselationSweepEdges2f();
            List<TesselationEdge2f> split = new List<TesselationEdge2f>();

            // 2) We now go top-bottom.
            for (int i = 0; i < vertices.Count; i++)
            {
                switch (vertices[i].VertexType)
                {
                    case TesselationVertexType.Regular:
                        HandleRegularVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Start:
                        HandleStartVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.End:
                        HandleEndVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Split:
                        HandleSplitVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Merge:
                        HandleMergeVertex(vertices[i], split, edges);
                        break;
                }
            }

            return split;
        }

        static void HandleStartVertex(TesselationVertex2f vertex, List<TesselationEdge2f> splits, TesselationSweepEdges2f edges)
        {
            // We set helper to self.
            vertex.NextEdge.Helper = vertex;

            edges.Add(vertex.NextEdge);
        }

        static void HandleEndVertex(TesselationVertex2f vertex, List<TesselationEdge2f> splits, TesselationSweepEdges2f edges)
        {
            // We handle merge vertex.
            if (vertex.PreviousEdge.Helper != null &&
                vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge2f diag = new TesselationEdge2f();
                diag.Vertex1 = vertex;
                diag.Vertex2 = vertex.PreviousEdge.Helper;

                splits.Add(diag);
            }

            edges.Delete(vertex.PreviousEdge);
        }

        static void HandleSplitVertex(TesselationVertex2f vertex, List<TesselationEdge2f> splits, TesselationSweepEdges2f edges)
        {
            int edgeId =  edges.FindLeft(vertex.ProjectedPosition);

            // We create diagonal
            TesselationEdge2f diag = new TesselationEdge2f();
            diag.Vertex1 = vertex;
            diag.Vertex2 = edges[edgeId].Helper;
            splits.Add(diag);
            
            // Adjust helpers.
            edges[edgeId].Helper = vertex;

            // Add additional helper.
            vertex.NextEdge.Helper = vertex;
            edges.Add(vertex.NextEdge);
            
        }

        static void HandleMergeVertex(TesselationVertex2f vertex, List<TesselationEdge2f> splits, TesselationSweepEdges2f edges)
        {
            // We first check for previos merge.
            if (vertex.PreviousEdge.Helper != null &&
                vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge2f diag = new TesselationEdge2f();
                diag.Vertex1 = vertex;
                diag.Vertex2 = vertex.PreviousEdge.Helper;

                splits.Add(diag);
            }

            // We delete previous edge.
            edges.Delete(vertex.PreviousEdge);

            // We find left edge.
            int leftEdgeId = edges.FindLeft(vertex.ProjectedPosition);

            if (edges[leftEdgeId].Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge2f diag = new TesselationEdge2f();
                diag.Vertex1 = vertex;
                diag.Vertex2 = edges[leftEdgeId].Helper;

                splits.Add(diag);
            }

            // We adjust helper.
            edges[leftEdgeId].Helper = vertex;
        }

        static void HandleRegularVertex(TesselationVertex2f vertex, List<TesselationEdge2f> splits, TesselationSweepEdges2f edges)
        {
            // We skip it if there is no interior to the right.
            if (InteriorToRight(vertex))
            {

                if (vertex.PreviousEdge.Helper != null &&
                    vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
                {
                    TesselationEdge2f diag = new TesselationEdge2f();
                    diag.Vertex1 = vertex;
                    diag.Vertex2 = vertex.PreviousEdge.Helper;

                    splits.Add(diag);
                }

                // We delete previous edge.
                edges.Delete(vertex.PreviousEdge);

                // We insert new edge.
                vertex.NextEdge.Helper = vertex;
                edges.Add(vertex.NextEdge);

            }
            else
            {
                // We insert the merge vertex.
                int edgeId = edges.FindLeft(vertex.ProjectedPosition);
                if (edges[edgeId].Helper.VertexType == TesselationVertexType.Merge)
                {
                    TesselationEdge2f diag = new TesselationEdge2f();
                    diag.Vertex1 = vertex;
                    diag.Vertex2 = edges[edgeId].Helper;

                    splits.Add(diag);
                }

                edges[edgeId].Helper = vertex;
            }
        }

        static bool OnTheSameChain(TesselationVertex2f current, TesselationVertex2f top)
        {
            bool onTheSameChain = false;
            if (current.NextEdge.Vertex2 == top || current.PreviousEdge.Vertex1 == top) onTheSameChain = true;
            if (!onTheSameChain && current.AdditionalDiagonals != null)
            {
                for (int j = 0; j < current.AdditionalDiagonals.Count; j++)
                {
                    if (current.AdditionalDiagonals[j].Vertex1 == top ||
                       current.AdditionalDiagonals[j].Vertex2 == top)
                    {
                        onTheSameChain = true;
                        break;
                    }
                }
            }
            return onTheSameChain;
        }

        /// <summary>
        /// Triangulates monotone polygon. Vertices are added to buffer.
        /// </summary>
        /// <param name="sortedMonothone"></param>
        /// <param name="meshBuilder"></param>
        static void TriangulateMonotone(List<TesselationVertex2f> sorted, 
            Storage.Builders.ITriangleBuilder2f meshBuilder)
        {
            // At least three vertices
            if (sorted.Count < 3) return;

            Stack<TesselationVertex2f> stack = new Stack<TesselationVertex2f>();

            // Identifies vertices on left chain as true, false if right chain.
            bool[] leftChain = new bool[sorted.Count];
            {
                // FIXME: are vertical beginings handled correctly. They do not arise
                // commonly ... so we leave it for now

                TesselationVertex2f left;
                if (sorted[0].ProjectedPosition.X <= sorted[1].ProjectedPosition.X)
                {
                    left = sorted[0];
                    leftChain[0] = true;
                    leftChain[1] = false;
                }
                else
                {
                    left = sorted[1];
                    leftChain[0] = false;
                    leftChain[1] = true;
                }

                // We now set the chains.
                for (int i = 2; i < sorted.Count - 1; i++)
                {
                    TesselationVertex2f current = sorted[i];

                    if (OnTheSameChain(current, left))
                    {
                        leftChain[i] = true;
                        left = current;
                    }
                    else
                    {
                        leftChain[i] = false;
                    }
                }
            }


            // We push first two vertices.
            stack.Push(sorted[0]);
            stack.Push(sorted[1]);

            // We enter the loop.
            for (int i = 2; i < sorted.Count - 1; i++)
            {
                TesselationVertex2f current = sorted[i];
                TesselationVertex2f top = stack.Pop();

                // We check if on the same side (same chain).



                if (OnTheSameChain(current, top))
                {
                    // In this case, we generate diagonals with elements on stack as long as we can
                    // (as long as they are legal).

                    // We link to all vertices we can stack.
                    TesselationVertex2f p1 = top, p2 = null;
                    uint curId = current.VertexIndex;

                    while (stack.Count > 0)
                    {
                        p2 = stack.Pop();

                        
                        // We first check if it is possible (orientation of triangle).
                        Vector3f normal = (p2.ProjectedPosition - p1.ProjectedPosition).Vec3 ^
                            (current.ProjectedPosition - p1.ProjectedPosition).Vec3;

                        bool isIrregular = leftChain[i] ? normal.Z > 0.0f : normal.Z < 0.0f;

                        if (isIrregular)
                        {
                            stack.Push(p2);
                            p2 = p1;
                            break;
                        }
                        


                        // We have a triangle, we may need to ensure vertices are added.
                        uint p1Id = p1.VertexIndex;
                        uint p2Id = p2.VertexIndex;

                        // We add triangle and relink.
                        meshBuilder.AddIndexedTriangles(new uint[] {curId, p2Id, p1Id});

                        // We relink.
                        p1 = p2;
                    }

                    // We push back to stack.
                    stack.Push(p2);
                    stack.Push(current);
                }
                // Different chains.
                else
                {
                    // We link to all vertices on stack.
                    TesselationVertex2f p1 = top, p2;
                    uint curId = current.VertexIndex;

                    while (stack.Count > 0)
                    {
                        // We pop the second one.
                        p2 = stack.Pop();

                        // We have a triangle, we may need to ensure vertices are added.
                        uint p1Id = p1.VertexIndex;
                        uint p2Id = p2.VertexIndex;

                        // We now add triangle.
                        meshBuilder.AddIndexedTriangles(new uint[] {curId, p2Id, p1Id });

                        // We relink.
                        p1 = p2;
                    }

                    // At the end, we push current-1 and current.
                    stack.Push(sorted[i - 1]);
                    stack.Push(current);
                }
            }

            // We end it.
            
            if (stack.Count > 0)
            {
                TesselationVertex2f current = sorted[sorted.Count - 1];
                TesselationVertex2f top = stack.Pop();

                while (stack.Count > 0)
                {
                    TesselationVertex2f other = stack.Pop();

                    meshBuilder.AddIndexedTriangles(new uint[] {current.VertexIndex, other.VertexIndex, top.VertexIndex});

                    top = other;
                }
            }
        }

        #endregion

        #region Public Static Members

        /// <summary>
        /// Converts polygon group to triangle mesh.
        /// </summary>
        /// <param name="polygons">The polygon contours.</param>
        /// <param name="builder">The builder where results are written.</param>
        public static void Tesselate(List<Vector2f[]> polygons,
            Storage.Builders.ITriangleBuilder2f builder)
        {
            Tesselate(polygons, builder, TesselationOptions.BoundableHolesIdentify);
        }


        /// <summary>
        /// Converts polygon group to triangle mesh.
        /// </summary>
        /// <param name="polygons">The polygon contours.</param>
        /// <param name="builder">The builder where results are written.</param>
        /// <param name="options">Tesselation options.</param>
        public static void Tesselate(List<Vector2f[]> polygons,
            Storage.Builders.ITriangleBuilder2f builder, TesselationOptions options)
        {
            if (!builder.IsIndexed)
            {
                throw new InvalidOperationException("Only indexed builder supported for now.");
            }


            // We first create linked list.
            List<TesselationVertex2f> vertices = new List<TesselationVertex2f>();
            List<TesselationVertex2f> beginning = new List<TesselationVertex2f>();
            

            CreateLinked(polygons, vertices, beginning, builder, options);

            // We make the polygon monothone by using split diagonals.
            List<TesselationEdge2f> additionalDiagonals = MakeMonothone(vertices);


            {
                // May improve efficiency of algorithm.

                Stack<TesselationVertex2f> toVisit = new Stack<TesselationVertex2f>(10);
                for (int j = 0; j < beginning.Count; j++)
                {
                    toVisit.Push(beginning[j]);
                }

                // We first append diagonals to multi-linked list.
                for (int i = 0; i < additionalDiagonals.Count; i++)
                {
                    // We take the diagonal and add it to vertices.
                    TesselationEdge2f diag = additionalDiagonals[i];

                    if (diag.Vertex1.AdditionalDiagonals == null) diag.Vertex1.AdditionalDiagonals = new List<TesselationEdge2f>();
                    if (diag.Vertex2.AdditionalDiagonals == null) diag.Vertex2.AdditionalDiagonals = new List<TesselationEdge2f>();

                    diag.Vertex1.AdditionalDiagonals.Add(diag);
                    diag.Vertex2.AdditionalDiagonals.Add(diag);

                    // We also push one element of diagonal (in case they are split).
                    toVisit.Push(diag.Vertex1);
                }

                // We start at topmost vertex and create a polygon.
                List<TesselationVertex2f> monothone = new List<TesselationVertex2f>(vertices.Count);
                
                while (toVisit.Count > 0)
                {
                    // We first check if already visited.
                    TesselationVertex2f start = toVisit.Pop();
                    TesselationVertex2f current = start;
                    TesselationVertex2f prev = start.PreviousEdge.Vertex1;
                    if (!start.TryVisit()) continue;

                    // We begin a new monothone
                    monothone.Clear();

                    monothone.Add(start);

                    // We now transverse the polygon.
                    while(true)
                    {
                        TesselationVertex2f t = current;
                        current = current.NextVertex(prev); //< Left order.
                        prev = t;
                        if (current == null || current == start) break;

                        current.AddToVisits(toVisit);
                        monothone.Add(current);
                    }

                    // We sort monotone.
                    monothone.Sort();

                    // Monothone triangulate.
                    TriangulateMonotone(monothone, builder);
                }
            }

        }

        #endregion

        #endregion Vector2f

        //#endfor instanced to 'Vector2f'

		//#foreach instanced to 'Vector3d'


        #region Vector3d

        #region Private Helpers

        const double RandomizationFactor3d = (double)1e-4;


                /// <summary>
        /// Is polygon clockwise in order.
        /// </summary>
        /// <param name="polygon"></param>
        /// <returns></returns>
        static bool IsClockwise(params Vector3d[] positions)
        {
            // We check winding order.
            double area = 0.0;
            for (int j = 1; j < positions.Length; j++)
            {
                // FIXME: this is Z projection assumed.
                area += positions[j - 1].X * positions[j].Y - positions[j - 1].Y * positions[j].X;
            }

            return area <= 0.0;

        }

        static void Reverse(Vector3d[] positions)
        {
            int n = positions.Length;
            for (int i = 0; i < n / 2; i++)
            {
                Vector3d v = positions[i];
                positions[i] = positions[n - i - 1];
                positions[n - 1 - i] = v;
            }
        }

        /// <summary>
        /// Obtains first hole.
        /// </summary>
        /// <param name="polygons"></param>
        /// <returns></returns>
        static uint GetFirstHole(List<Vector3d[]> polygons)
        {
            uint[] idx = GetBoundableHoles(polygons);
            for (int i = 0; i < idx.Length; i++)
            {
                if (idx[i] != uint.MaxValue) return (uint)i;
            }
            return uint.MaxValue;
        }

        /// <summary>
        /// Gets indices of polygons that are holes, together with bounding box of polygon.
        /// </summary>
        /// <param name="polygons"></param>
        /// <returns></returns>
        static uint[] GetBoundableHoles(List<Vector3d[]> polygons)
        {
            uint[] holes = new uint[polygons.Count];
            

            // We compute all bounding boxes.
            Vector3d[] mins = new Vector3d[polygons.Count];
            Vector3d[] maxs = new Vector3d[polygons.Count];

            for (int i = 0; i < polygons.Count; i++)
            {
                GetBoundingBox(polygons[i], out mins[i], out maxs[i]);
            }

            // We initialize holes.
            for (int i = 0; i < polygons.Count; i++) holes[i] = uint.MaxValue;

            // A hole is an element that is completely inside other polygon.
            for (int i = 0; i < polygons.Count; i++)
            {
                for (int j = 0; j < polygons.Count; j++)
                {
                    if (i == j) continue;

                    // We check if j is completelly inside i.
                    //#ifdef 3D

                    if (mins[j].X >= mins[i].Y && mins[j].Y >= mins[i].Y && mins[j].Z >= mins[i].Z &&
                       maxs[j].X <= maxs[i].Y && maxs[j].Y <= maxs[i].Y && maxs[j].Z <= maxs[i].Z)
                    //#endif
                    {
                        holes[j] = (uint)i;
                        break;
                    }

                    

                }
            }

            return holes;
        }



        /// <summary>
        /// Obtains bounding box of polygon.
        /// </summary>
        /// <param name="polygon"></param>
        /// <param name="min"></param>
        /// <param name="max"></param>
        static void GetBoundingBox(Vector3d[] polygon, out Vector3d min, out Vector3d max)
        {
            //#ifdef 3D

            min = new Vector3d(double.PositiveInfinity, double.PositiveInfinity, double.PositiveInfinity);
            max = new Vector3d(double.NegativeInfinity, double.NegativeInfinity, double.NegativeInfinity);
            //#endif

            for(int i = 0; i < polygon.Length; i++)
            {
                Vector3d v = polygon[i];

                min.X = min.X < v.X ? min.X : v.X;
                min.Y = min.Y < v.Y ? min.Y : v.Y;
                //#ifdef 3D

                min.Z = min.Z < v.Z ? min.Z : v.Z;
                //#endif

                max.X = max.X > v.X ? max.X : v.X;
                max.Y = max.Y > v.Y ? max.Y : v.Y;
                //#ifdef 3D

                max.Z = max.Z > v.Z ? max.Z : v.Z;
                //#endif
            }
        }


        /// <summary>
        /// Is vertex left turn.
        /// </summary>
        static bool IsLeftTurn(TesselationVertex3d vertex)
        {
            return vertex.IsLeftTurn();
        }

        /// <summary>
        /// Is interior to right.
        /// </summary>
        static bool InteriorToRight(TesselationVertex3d vertex)
        {
            // We check if point a bit to the right is contained in triangle.
            Vector2d p1 = vertex.PreviousEdge.Vertex1.ProjectedPosition;
            Vector2d p2 = vertex.NextEdge.Vertex2.ProjectedPosition;

            bool isLeftTurn = IsLeftTurn(vertex);

            // We intersect diagonals.

            // Special case.
            if (MathHelper.NearEqual(p1.X, p2.X))
            {
                if (isLeftTurn)
                {
                    return vertex.ProjectedPosition.X <= p1.X;
                }
                else
                {
                    return vertex.ProjectedPosition.X >= p1.X;
                }
            }

            // We now do intersection.
            double k = (p2.Y - p1.Y) / (p2.X - p1.X);
            double n = p1.Y - k * p1.X;

            double x = (vertex.ProjectedPosition.Y - n) / k;


            if (isLeftTurn)
            {
                return x >= vertex.ProjectedPosition.X;
            }
            else
            {
                return x < vertex.ProjectedPosition.X;
            }

        }

        /// <summary>
        /// Debugs a vertex.
        /// </summary>
        static void DebugVertices(TesselationVertex3d root)
        {

            Console.WriteLine();
            Console.WriteLine("=====");
            TesselationVertex3d v = root.NextEdge.Vertex2;

            while (true)
            {
                Console.WriteLine("{0}, {1}", v.ProjectedPosition.X, v.ProjectedPosition.Y);

                if (v == root) break;

                TesselationVertex3d t = v.NextEdge.Vertex2;
                if (t.PreviousEdge.Vertex1 != v)
                {
                    Console.Write("Error link.");
                }

                v = t;
                   
            }
        }

        /// <summary>
        /// Creates a linked list.
        /// </summary>
        static void CreateLinked(List<Vector3d[]> polygons, List<TesselationVertex3d> vertices, List<TesselationVertex3d> beginning,
            Storage.Builders.ITriangleBuilder3d builder, TesselationOptions options)
        {
            bool windingClockwise = (options & TesselationOptions.CCW) != 0 ? false : true;

 
            uint[] holeParents = null;

            // We may need to identify holes.
            if ((options & TesselationOptions.BoundableHolesIdentify) != 0)
            {
                holeParents = GetBoundableHoles(polygons);

                // We reverse those.
                for (int i = 0; i < holeParents.Length; i++)
                {
                    if (holeParents[i] == uint.MaxValue) continue;
                    Reverse(polygons[i]);
                }
            }
            

            // X-range compute.
            double xmax = double.NegativeInfinity;
            double xmin = double.PositiveInfinity;

            int startPolygon = 0;
            TesselationEdge3d currentEdge = null;

            // Seperate polygons.
            TesselationVertex3d[][] perPolygonData = new TesselationVertex3d[polygons.Count][];


            // We reverse them.
            if (!windingClockwise)
            {
                for (int i = 0; i < polygons.Count; i++)
                {
                    Reverse(polygons[i]);
                }
            }

            // We now identify all holes based on orientation
            if ((options & TesselationOptions.HolesIdentifyOrientation) != 0)
            {
                holeParents = GetBoundableHoles(polygons);

                // Some may not be holes, we should check this.
            }

            for (int j = 0; j < polygons.Count; j++)
            {
                Vector3d[] positions = polygons[j];
                perPolygonData[j] = new TesselationVertex3d[positions.Length];

                uint baseIndex = builder.AddControlPoints(positions);

                for (int i = 0; i < positions.Length; i++)
                {
                    Vector3d v = positions[i];

                    // We compute bounding box.
                    Vector2d projPosition;
                    //#ifdef 3D

                    projPosition = v.Vec2; //< For now this is projection, later we need to add "proper plane" projection.
                    //#endif

                    if (projPosition.X > xmax) xmax = projPosition.X;
                    if (projPosition.X < xmin) xmin = projPosition.X;

                    // Now we link appropriatelly.
                    TesselationVertex3d vertex = new TesselationVertex3d();

                    vertex.PreviousEdge = currentEdge;

                    vertex.VertexIndex = (uint)(baseIndex + i);

                    vertex.ProjectedPosition = projPosition;

                    // We add vertex.
                    vertices.Add(vertex);

                    // We also link edge.
                    if (currentEdge != null) currentEdge.Vertex2 = vertex;
                    currentEdge = new TesselationEdge3d();
                    currentEdge.Vertex1 = vertex;
                    vertex.NextEdge = currentEdge;

                    perPolygonData[j][i] = vertex;

                }

                // We need for beginnings of polygons.
                beginning.Add(vertices[startPolygon]);

                // We end polygon.
                currentEdge.Vertex2 = vertices[startPolygon];

                vertices[startPolygon].PreviousEdge = currentEdge;

                startPolygon = vertices.Count;
                currentEdge = null;
            }


            // TODO: may add already sorted hint.

            // We need to handle hole merge.
            if (holeParents != null)
            {
                for (int i = 0; i < holeParents.Length; i++)
                {
                    if (holeParents[i] == uint.MaxValue) continue;

                    uint parent = holeParents[i];

                    TesselationVertex3d[] parentData = perPolygonData[parent];
                    TesselationVertex3d[] holeData = perPolygonData[i];

                    // We sort parent.
                    Array.Sort(parentData);

                    // We find top of hole.
                    TesselationVertex3d top = holeData[0];
                    for (int j = 1; j < holeData.Length; j++)
                    {
                        if (holeData[j].ProjectedPosition.Y > top.ProjectedPosition.Y) top = holeData[j];
                    }

                    // We now find the shortest link that exists.
                    int lower = ~Array.BinarySearch(parentData, top);

                    // We find appropriate vertex.
                    TesselationVertex3d linkTo = parentData[lower-1];

                    // TODO: we should check it does not intersect anything

                    // We now link, new vertices have small y displacement.
                    double disp = (xmax - xmin) * RandomizationFactor3d;
                    if (linkTo.ProjectedPosition.X < top.ProjectedPosition.X) disp *= -1.0f;

                    TesselationEdge3d diagTo = new TesselationEdge3d();
                    TesselationEdge3d diagBack = new TesselationEdge3d();

                    // The link repl vertex.
                    TesselationVertex3d linkToRepl = new TesselationVertex3d();
                    linkToRepl.ProjectedPosition = linkTo.ProjectedPosition;
                    linkToRepl.ProjectedPosition.Y -= disp;
                    linkToRepl.VertexIndex = linkTo.VertexIndex;
                    linkToRepl.PreviousEdge = linkTo.PreviousEdge;
                    linkTo.PreviousEdge.Vertex2 = linkToRepl;
                    linkToRepl.NextEdge = diagTo;


                    vertices.Add(linkToRepl);

                    // We create new vertex and link appropriatelly.
                    TesselationVertex3d topRepl = new TesselationVertex3d();
                    topRepl.ProjectedPosition = top.ProjectedPosition;
                    topRepl.ProjectedPosition.Y -= disp;
                    topRepl.VertexIndex = top.VertexIndex;
                    topRepl.PreviousEdge = diagTo;
                    topRepl.NextEdge = top.NextEdge;
                    top.NextEdge.Vertex1 = topRepl;
                    

                    vertices.Add(topRepl);

                    top.NextEdge = diagBack;
                    linkTo.PreviousEdge = diagBack;

                    // We also fill diagonals.
                    diagTo.Vertex1 = linkToRepl;
                    diagTo.Vertex2 = topRepl;

                    diagBack.Vertex1 = top;
                    diagBack.Vertex2 = linkTo;

                    
                    //DebugVertices(linkToRepl);
                }
            }

            // We perform randomization, so no vertices have the same y coordinate.
            // We allow maximum of 5 randomizations.
            for (int z = 0; ; z++)
            {
                if (z >= 5) throw new Exception("Randomization failed.");


                double scale = 2.0f * (xmax - xmin) * RandomizationFactor3d;

                // We randomize all of them.
                for (int i = 0; i < vertices.Count; i++)
                {
                    vertices[i].ProjectedPosition.Y += scale * vertices[i].ProjectedPosition.X;
                }

                vertices.Sort();

                // We check if ok.
                bool randomized = true;
                for (int i = 1; i < vertices.Count; i++)
                {
                    if (vertices[i].ProjectedPosition.Y == vertices[i - 1].ProjectedPosition.Y)
                    {
                        randomized = false;
                        break;
                    }
                }

                if (randomized) break;
            }
            

            for (int i = 0; i < vertices.Count; i++)
            {
                // We identify vertex.
                vertices[i].IdentifyVertex();
            }

            
        }



        /// <summary>
        /// Makes polygon monothone.
        /// </summary>
        /// <param name="vertices"></param>
        /// <returns></returns>
        static List<TesselationEdge3d> MakeMonothone(List<TesselationVertex3d> vertices)
        {
            // 1) Vertices are sorted.
            TesselationSweepEdges3d edges = new TesselationSweepEdges3d();
            List<TesselationEdge3d> split = new List<TesselationEdge3d>();

            // 2) We now go top-bottom.
            for (int i = 0; i < vertices.Count; i++)
            {
                switch (vertices[i].VertexType)
                {
                    case TesselationVertexType.Regular:
                        HandleRegularVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Start:
                        HandleStartVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.End:
                        HandleEndVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Split:
                        HandleSplitVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Merge:
                        HandleMergeVertex(vertices[i], split, edges);
                        break;
                }
            }

            return split;
        }

        static void HandleStartVertex(TesselationVertex3d vertex, List<TesselationEdge3d> splits, TesselationSweepEdges3d edges)
        {
            // We set helper to self.
            vertex.NextEdge.Helper = vertex;

            edges.Add(vertex.NextEdge);
        }

        static void HandleEndVertex(TesselationVertex3d vertex, List<TesselationEdge3d> splits, TesselationSweepEdges3d edges)
        {
            // We handle merge vertex.
            if (vertex.PreviousEdge.Helper != null &&
                vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge3d diag = new TesselationEdge3d();
                diag.Vertex1 = vertex;
                diag.Vertex2 = vertex.PreviousEdge.Helper;

                splits.Add(diag);
            }

            edges.Delete(vertex.PreviousEdge);
        }

        static void HandleSplitVertex(TesselationVertex3d vertex, List<TesselationEdge3d> splits, TesselationSweepEdges3d edges)
        {
            int edgeId =  edges.FindLeft(vertex.ProjectedPosition);

            // We create diagonal
            TesselationEdge3d diag = new TesselationEdge3d();
            diag.Vertex1 = vertex;
            diag.Vertex2 = edges[edgeId].Helper;
            splits.Add(diag);
            
            // Adjust helpers.
            edges[edgeId].Helper = vertex;

            // Add additional helper.
            vertex.NextEdge.Helper = vertex;
            edges.Add(vertex.NextEdge);
            
        }

        static void HandleMergeVertex(TesselationVertex3d vertex, List<TesselationEdge3d> splits, TesselationSweepEdges3d edges)
        {
            // We first check for previos merge.
            if (vertex.PreviousEdge.Helper != null &&
                vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge3d diag = new TesselationEdge3d();
                diag.Vertex1 = vertex;
                diag.Vertex2 = vertex.PreviousEdge.Helper;

                splits.Add(diag);
            }

            // We delete previous edge.
            edges.Delete(vertex.PreviousEdge);

            // We find left edge.
            int leftEdgeId = edges.FindLeft(vertex.ProjectedPosition);

            if (edges[leftEdgeId].Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge3d diag = new TesselationEdge3d();
                diag.Vertex1 = vertex;
                diag.Vertex2 = edges[leftEdgeId].Helper;

                splits.Add(diag);
            }

            // We adjust helper.
            edges[leftEdgeId].Helper = vertex;
        }

        static void HandleRegularVertex(TesselationVertex3d vertex, List<TesselationEdge3d> splits, TesselationSweepEdges3d edges)
        {
            // We skip it if there is no interior to the right.
            if (InteriorToRight(vertex))
            {

                if (vertex.PreviousEdge.Helper != null &&
                    vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
                {
                    TesselationEdge3d diag = new TesselationEdge3d();
                    diag.Vertex1 = vertex;
                    diag.Vertex2 = vertex.PreviousEdge.Helper;

                    splits.Add(diag);
                }

                // We delete previous edge.
                edges.Delete(vertex.PreviousEdge);

                // We insert new edge.
                vertex.NextEdge.Helper = vertex;
                edges.Add(vertex.NextEdge);

            }
            else
            {
                // We insert the merge vertex.
                int edgeId = edges.FindLeft(vertex.ProjectedPosition);
                if (edges[edgeId].Helper.VertexType == TesselationVertexType.Merge)
                {
                    TesselationEdge3d diag = new TesselationEdge3d();
                    diag.Vertex1 = vertex;
                    diag.Vertex2 = edges[edgeId].Helper;

                    splits.Add(diag);
                }

                edges[edgeId].Helper = vertex;
            }
        }

        static bool OnTheSameChain(TesselationVertex3d current, TesselationVertex3d top)
        {
            bool onTheSameChain = false;
            if (current.NextEdge.Vertex2 == top || current.PreviousEdge.Vertex1 == top) onTheSameChain = true;
            if (!onTheSameChain && current.AdditionalDiagonals != null)
            {
                for (int j = 0; j < current.AdditionalDiagonals.Count; j++)
                {
                    if (current.AdditionalDiagonals[j].Vertex1 == top ||
                       current.AdditionalDiagonals[j].Vertex2 == top)
                    {
                        onTheSameChain = true;
                        break;
                    }
                }
            }
            return onTheSameChain;
        }

        /// <summary>
        /// Triangulates monotone polygon. Vertices are added to buffer.
        /// </summary>
        /// <param name="sortedMonothone"></param>
        /// <param name="meshBuilder"></param>
        static void TriangulateMonotone(List<TesselationVertex3d> sorted, 
            Storage.Builders.ITriangleBuilder3d meshBuilder)
        {
            // At least three vertices
            if (sorted.Count < 3) return;

            Stack<TesselationVertex3d> stack = new Stack<TesselationVertex3d>();

            // Identifies vertices on left chain as true, false if right chain.
            bool[] leftChain = new bool[sorted.Count];
            {
                // FIXME: are vertical beginings handled correctly. They do not arise
                // commonly ... so we leave it for now

                TesselationVertex3d left;
                if (sorted[0].ProjectedPosition.X <= sorted[1].ProjectedPosition.X)
                {
                    left = sorted[0];
                    leftChain[0] = true;
                    leftChain[1] = false;
                }
                else
                {
                    left = sorted[1];
                    leftChain[0] = false;
                    leftChain[1] = true;
                }

                // We now set the chains.
                for (int i = 2; i < sorted.Count - 1; i++)
                {
                    TesselationVertex3d current = sorted[i];

                    if (OnTheSameChain(current, left))
                    {
                        leftChain[i] = true;
                        left = current;
                    }
                    else
                    {
                        leftChain[i] = false;
                    }
                }
            }


            // We push first two vertices.
            stack.Push(sorted[0]);
            stack.Push(sorted[1]);

            // We enter the loop.
            for (int i = 2; i < sorted.Count - 1; i++)
            {
                TesselationVertex3d current = sorted[i];
                TesselationVertex3d top = stack.Pop();

                // We check if on the same side (same chain).



                if (OnTheSameChain(current, top))
                {
                    // In this case, we generate diagonals with elements on stack as long as we can
                    // (as long as they are legal).

                    // We link to all vertices we can stack.
                    TesselationVertex3d p1 = top, p2 = null;
                    uint curId = current.VertexIndex;

                    while (stack.Count > 0)
                    {
                        p2 = stack.Pop();

                        
                        // We first check if it is possible (orientation of triangle).
                        Vector3d normal = (p2.ProjectedPosition - p1.ProjectedPosition).Vec3 ^
                            (current.ProjectedPosition - p1.ProjectedPosition).Vec3;

                        bool isIrregular = leftChain[i] ? normal.Z > 0.0 : normal.Z < 0.0;

                        if (isIrregular)
                        {
                            stack.Push(p2);
                            p2 = p1;
                            break;
                        }
                        


                        // We have a triangle, we may need to ensure vertices are added.
                        uint p1Id = p1.VertexIndex;
                        uint p2Id = p2.VertexIndex;

                        // We add triangle and relink.
                        meshBuilder.AddIndexedTriangles(new uint[] {curId, p2Id, p1Id});

                        // We relink.
                        p1 = p2;
                    }

                    // We push back to stack.
                    stack.Push(p2);
                    stack.Push(current);
                }
                // Different chains.
                else
                {
                    // We link to all vertices on stack.
                    TesselationVertex3d p1 = top, p2;
                    uint curId = current.VertexIndex;

                    while (stack.Count > 0)
                    {
                        // We pop the second one.
                        p2 = stack.Pop();

                        // We have a triangle, we may need to ensure vertices are added.
                        uint p1Id = p1.VertexIndex;
                        uint p2Id = p2.VertexIndex;

                        // We now add triangle.
                        meshBuilder.AddIndexedTriangles(new uint[] {curId, p2Id, p1Id });

                        // We relink.
                        p1 = p2;
                    }

                    // At the end, we push current-1 and current.
                    stack.Push(sorted[i - 1]);
                    stack.Push(current);
                }
            }

            // We end it.
            
            if (stack.Count > 0)
            {
                TesselationVertex3d current = sorted[sorted.Count - 1];
                TesselationVertex3d top = stack.Pop();

                while (stack.Count > 0)
                {
                    TesselationVertex3d other = stack.Pop();

                    meshBuilder.AddIndexedTriangles(new uint[] {current.VertexIndex, other.VertexIndex, top.VertexIndex});

                    top = other;
                }
            }
        }

        #endregion

        #region Public Static Members

        /// <summary>
        /// Converts polygon group to triangle mesh.
        /// </summary>
        /// <param name="polygons">The polygon contours.</param>
        /// <param name="builder">The builder where results are written.</param>
        public static void Tesselate(List<Vector3d[]> polygons,
            Storage.Builders.ITriangleBuilder3d builder)
        {
            Tesselate(polygons, builder, TesselationOptions.BoundableHolesIdentify);
        }


        /// <summary>
        /// Converts polygon group to triangle mesh.
        /// </summary>
        /// <param name="polygons">The polygon contours.</param>
        /// <param name="builder">The builder where results are written.</param>
        /// <param name="options">Tesselation options.</param>
        public static void Tesselate(List<Vector3d[]> polygons,
            Storage.Builders.ITriangleBuilder3d builder, TesselationOptions options)
        {
            if (!builder.IsIndexed)
            {
                throw new InvalidOperationException("Only indexed builder supported for now.");
            }


            // We first create linked list.
            List<TesselationVertex3d> vertices = new List<TesselationVertex3d>();
            List<TesselationVertex3d> beginning = new List<TesselationVertex3d>();
            

            CreateLinked(polygons, vertices, beginning, builder, options);

            // We make the polygon monothone by using split diagonals.
            List<TesselationEdge3d> additionalDiagonals = MakeMonothone(vertices);


            {
                // May improve efficiency of algorithm.

                Stack<TesselationVertex3d> toVisit = new Stack<TesselationVertex3d>(10);
                for (int j = 0; j < beginning.Count; j++)
                {
                    toVisit.Push(beginning[j]);
                }

                // We first append diagonals to multi-linked list.
                for (int i = 0; i < additionalDiagonals.Count; i++)
                {
                    // We take the diagonal and add it to vertices.
                    TesselationEdge3d diag = additionalDiagonals[i];

                    if (diag.Vertex1.AdditionalDiagonals == null) diag.Vertex1.AdditionalDiagonals = new List<TesselationEdge3d>();
                    if (diag.Vertex2.AdditionalDiagonals == null) diag.Vertex2.AdditionalDiagonals = new List<TesselationEdge3d>();

                    diag.Vertex1.AdditionalDiagonals.Add(diag);
                    diag.Vertex2.AdditionalDiagonals.Add(diag);

                    // We also push one element of diagonal (in case they are split).
                    toVisit.Push(diag.Vertex1);
                }

                // We start at topmost vertex and create a polygon.
                List<TesselationVertex3d> monothone = new List<TesselationVertex3d>(vertices.Count);
                
                while (toVisit.Count > 0)
                {
                    // We first check if already visited.
                    TesselationVertex3d start = toVisit.Pop();
                    TesselationVertex3d current = start;
                    TesselationVertex3d prev = start.PreviousEdge.Vertex1;
                    if (!start.TryVisit()) continue;

                    // We begin a new monothone
                    monothone.Clear();

                    monothone.Add(start);

                    // We now transverse the polygon.
                    while(true)
                    {
                        TesselationVertex3d t = current;
                        current = current.NextVertex(prev); //< Left order.
                        prev = t;
                        if (current == null || current == start) break;

                        current.AddToVisits(toVisit);
                        monothone.Add(current);
                    }

                    // We sort monotone.
                    monothone.Sort();

                    // Monothone triangulate.
                    TriangulateMonotone(monothone, builder);
                }
            }

        }

        #endregion

        #endregion Vector3d

        //#endfor instanced to 'Vector3d'

		//#foreach instanced to 'Vector3f'


        #region Vector3f

        #region Private Helpers

        const float RandomizationFactor3f = (float)1e-4;


                /// <summary>
        /// Is polygon clockwise in order.
        /// </summary>
        /// <param name="polygon"></param>
        /// <returns></returns>
        static bool IsClockwise(params Vector3f[] positions)
        {
            // We check winding order.
            float area = 0.0f;
            for (int j = 1; j < positions.Length; j++)
            {
                // FIXME: this is Z projection assumed.
                area += positions[j - 1].X * positions[j].Y - positions[j - 1].Y * positions[j].X;
            }

            return area <= 0.0f;

        }

        static void Reverse(Vector3f[] positions)
        {
            int n = positions.Length;
            for (int i = 0; i < n / 2; i++)
            {
                Vector3f v = positions[i];
                positions[i] = positions[n - i - 1];
                positions[n - 1 - i] = v;
            }
        }

        /// <summary>
        /// Obtains first hole.
        /// </summary>
        /// <param name="polygons"></param>
        /// <returns></returns>
        static uint GetFirstHole(List<Vector3f[]> polygons)
        {
            uint[] idx = GetBoundableHoles(polygons);
            for (int i = 0; i < idx.Length; i++)
            {
                if (idx[i] != uint.MaxValue) return (uint)i;
            }
            return uint.MaxValue;
        }

        /// <summary>
        /// Gets indices of polygons that are holes, together with bounding box of polygon.
        /// </summary>
        /// <param name="polygons"></param>
        /// <returns></returns>
        static uint[] GetBoundableHoles(List<Vector3f[]> polygons)
        {
            uint[] holes = new uint[polygons.Count];
            

            // We compute all bounding boxes.
            Vector3f[] mins = new Vector3f[polygons.Count];
            Vector3f[] maxs = new Vector3f[polygons.Count];

            for (int i = 0; i < polygons.Count; i++)
            {
                GetBoundingBox(polygons[i], out mins[i], out maxs[i]);
            }

            // We initialize holes.
            for (int i = 0; i < polygons.Count; i++) holes[i] = uint.MaxValue;

            // A hole is an element that is completely inside other polygon.
            for (int i = 0; i < polygons.Count; i++)
            {
                for (int j = 0; j < polygons.Count; j++)
                {
                    if (i == j) continue;

                    // We check if j is completelly inside i.
                    //#ifdef 3D

                    if (mins[j].X >= mins[i].Y && mins[j].Y >= mins[i].Y && mins[j].Z >= mins[i].Z &&
                       maxs[j].X <= maxs[i].Y && maxs[j].Y <= maxs[i].Y && maxs[j].Z <= maxs[i].Z)
                    //#endif
                    {
                        holes[j] = (uint)i;
                        break;
                    }

                    

                }
            }

            return holes;
        }



        /// <summary>
        /// Obtains bounding box of polygon.
        /// </summary>
        /// <param name="polygon"></param>
        /// <param name="min"></param>
        /// <param name="max"></param>
        static void GetBoundingBox(Vector3f[] polygon, out Vector3f min, out Vector3f max)
        {
            //#ifdef 3D

            min = new Vector3f(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);
            max = new Vector3f(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity);
            //#endif

            for(int i = 0; i < polygon.Length; i++)
            {
                Vector3f v = polygon[i];

                min.X = min.X < v.X ? min.X : v.X;
                min.Y = min.Y < v.Y ? min.Y : v.Y;
                //#ifdef 3D

                min.Z = min.Z < v.Z ? min.Z : v.Z;
                //#endif

                max.X = max.X > v.X ? max.X : v.X;
                max.Y = max.Y > v.Y ? max.Y : v.Y;
                //#ifdef 3D

                max.Z = max.Z > v.Z ? max.Z : v.Z;
                //#endif
            }
        }


        /// <summary>
        /// Is vertex left turn.
        /// </summary>
        static bool IsLeftTurn(TesselationVertex3f vertex)
        {
            return vertex.IsLeftTurn();
        }

        /// <summary>
        /// Is interior to right.
        /// </summary>
        static bool InteriorToRight(TesselationVertex3f vertex)
        {
            // We check if point a bit to the right is contained in triangle.
            Vector2f p1 = vertex.PreviousEdge.Vertex1.ProjectedPosition;
            Vector2f p2 = vertex.NextEdge.Vertex2.ProjectedPosition;

            bool isLeftTurn = IsLeftTurn(vertex);

            // We intersect diagonals.

            // Special case.
            if (MathHelper.NearEqual(p1.X, p2.X))
            {
                if (isLeftTurn)
                {
                    return vertex.ProjectedPosition.X <= p1.X;
                }
                else
                {
                    return vertex.ProjectedPosition.X >= p1.X;
                }
            }

            // We now do intersection.
            float k = (p2.Y - p1.Y) / (p2.X - p1.X);
            float n = p1.Y - k * p1.X;

            float x = (vertex.ProjectedPosition.Y - n) / k;


            if (isLeftTurn)
            {
                return x >= vertex.ProjectedPosition.X;
            }
            else
            {
                return x < vertex.ProjectedPosition.X;
            }

        }

        /// <summary>
        /// Debugs a vertex.
        /// </summary>
        static void DebugVertices(TesselationVertex3f root)
        {

            Console.WriteLine();
            Console.WriteLine("=====");
            TesselationVertex3f v = root.NextEdge.Vertex2;

            while (true)
            {
                Console.WriteLine("{0}, {1}", v.ProjectedPosition.X, v.ProjectedPosition.Y);

                if (v == root) break;

                TesselationVertex3f t = v.NextEdge.Vertex2;
                if (t.PreviousEdge.Vertex1 != v)
                {
                    Console.Write("Error link.");
                }

                v = t;
                   
            }
        }

        /// <summary>
        /// Creates a linked list.
        /// </summary>
        static void CreateLinked(List<Vector3f[]> polygons, List<TesselationVertex3f> vertices, List<TesselationVertex3f> beginning,
            Storage.Builders.ITriangleBuilder3f builder, TesselationOptions options)
        {
            bool windingClockwise = (options & TesselationOptions.CCW) != 0 ? false : true;

 
            uint[] holeParents = null;

            // We may need to identify holes.
            if ((options & TesselationOptions.BoundableHolesIdentify) != 0)
            {
                holeParents = GetBoundableHoles(polygons);

                // We reverse those.
                for (int i = 0; i < holeParents.Length; i++)
                {
                    if (holeParents[i] == uint.MaxValue) continue;
                    Reverse(polygons[i]);
                }
            }
            

            // X-range compute.
            float xmax = float.NegativeInfinity;
            float xmin = float.PositiveInfinity;

            int startPolygon = 0;
            TesselationEdge3f currentEdge = null;

            // Seperate polygons.
            TesselationVertex3f[][] perPolygonData = new TesselationVertex3f[polygons.Count][];


            // We reverse them.
            if (!windingClockwise)
            {
                for (int i = 0; i < polygons.Count; i++)
                {
                    Reverse(polygons[i]);
                }
            }

            // We now identify all holes based on orientation
            if ((options & TesselationOptions.HolesIdentifyOrientation) != 0)
            {
                holeParents = GetBoundableHoles(polygons);

                // Some may not be holes, we should check this.
            }

            for (int j = 0; j < polygons.Count; j++)
            {
                Vector3f[] positions = polygons[j];
                perPolygonData[j] = new TesselationVertex3f[positions.Length];

                uint baseIndex = builder.AddControlPoints(positions);

                for (int i = 0; i < positions.Length; i++)
                {
                    Vector3f v = positions[i];

                    // We compute bounding box.
                    Vector2f projPosition;
                    //#ifdef 3D

                    projPosition = v.Vec2; //< For now this is projection, later we need to add "proper plane" projection.
                    //#endif

                    if (projPosition.X > xmax) xmax = projPosition.X;
                    if (projPosition.X < xmin) xmin = projPosition.X;

                    // Now we link appropriatelly.
                    TesselationVertex3f vertex = new TesselationVertex3f();

                    vertex.PreviousEdge = currentEdge;

                    vertex.VertexIndex = (uint)(baseIndex + i);

                    vertex.ProjectedPosition = projPosition;

                    // We add vertex.
                    vertices.Add(vertex);

                    // We also link edge.
                    if (currentEdge != null) currentEdge.Vertex2 = vertex;
                    currentEdge = new TesselationEdge3f();
                    currentEdge.Vertex1 = vertex;
                    vertex.NextEdge = currentEdge;

                    perPolygonData[j][i] = vertex;

                }

                // We need for beginnings of polygons.
                beginning.Add(vertices[startPolygon]);

                // We end polygon.
                currentEdge.Vertex2 = vertices[startPolygon];

                vertices[startPolygon].PreviousEdge = currentEdge;

                startPolygon = vertices.Count;
                currentEdge = null;
            }


            // TODO: may add already sorted hint.

            // We need to handle hole merge.
            if (holeParents != null)
            {
                for (int i = 0; i < holeParents.Length; i++)
                {
                    if (holeParents[i] == uint.MaxValue) continue;

                    uint parent = holeParents[i];

                    TesselationVertex3f[] parentData = perPolygonData[parent];
                    TesselationVertex3f[] holeData = perPolygonData[i];

                    // We sort parent.
                    Array.Sort(parentData);

                    // We find top of hole.
                    TesselationVertex3f top = holeData[0];
                    for (int j = 1; j < holeData.Length; j++)
                    {
                        if (holeData[j].ProjectedPosition.Y > top.ProjectedPosition.Y) top = holeData[j];
                    }

                    // We now find the shortest link that exists.
                    int lower = ~Array.BinarySearch(parentData, top);

                    // We find appropriate vertex.
                    TesselationVertex3f linkTo = parentData[lower-1];

                    // TODO: we should check it does not intersect anything

                    // We now link, new vertices have small y displacement.
                    float disp = (xmax - xmin) * RandomizationFactor3f;
                    if (linkTo.ProjectedPosition.X < top.ProjectedPosition.X) disp *= -1.0f;

                    TesselationEdge3f diagTo = new TesselationEdge3f();
                    TesselationEdge3f diagBack = new TesselationEdge3f();

                    // The link repl vertex.
                    TesselationVertex3f linkToRepl = new TesselationVertex3f();
                    linkToRepl.ProjectedPosition = linkTo.ProjectedPosition;
                    linkToRepl.ProjectedPosition.Y -= disp;
                    linkToRepl.VertexIndex = linkTo.VertexIndex;
                    linkToRepl.PreviousEdge = linkTo.PreviousEdge;
                    linkTo.PreviousEdge.Vertex2 = linkToRepl;
                    linkToRepl.NextEdge = diagTo;


                    vertices.Add(linkToRepl);

                    // We create new vertex and link appropriatelly.
                    TesselationVertex3f topRepl = new TesselationVertex3f();
                    topRepl.ProjectedPosition = top.ProjectedPosition;
                    topRepl.ProjectedPosition.Y -= disp;
                    topRepl.VertexIndex = top.VertexIndex;
                    topRepl.PreviousEdge = diagTo;
                    topRepl.NextEdge = top.NextEdge;
                    top.NextEdge.Vertex1 = topRepl;
                    

                    vertices.Add(topRepl);

                    top.NextEdge = diagBack;
                    linkTo.PreviousEdge = diagBack;

                    // We also fill diagonals.
                    diagTo.Vertex1 = linkToRepl;
                    diagTo.Vertex2 = topRepl;

                    diagBack.Vertex1 = top;
                    diagBack.Vertex2 = linkTo;

                    
                    //DebugVertices(linkToRepl);
                }
            }

            // We perform randomization, so no vertices have the same y coordinate.
            // We allow maximum of 5 randomizations.
            for (int z = 0; ; z++)
            {
                if (z >= 5) throw new Exception("Randomization failed.");


                float scale = 2.0f * (xmax - xmin) * RandomizationFactor3f;

                // We randomize all of them.
                for (int i = 0; i < vertices.Count; i++)
                {
                    vertices[i].ProjectedPosition.Y += scale * vertices[i].ProjectedPosition.X;
                }

                vertices.Sort();

                // We check if ok.
                bool randomized = true;
                for (int i = 1; i < vertices.Count; i++)
                {
                    if (vertices[i].ProjectedPosition.Y == vertices[i - 1].ProjectedPosition.Y)
                    {
                        randomized = false;
                        break;
                    }
                }

                if (randomized) break;
            }
            

            for (int i = 0; i < vertices.Count; i++)
            {
                // We identify vertex.
                vertices[i].IdentifyVertex();
            }

            
        }



        /// <summary>
        /// Makes polygon monothone.
        /// </summary>
        /// <param name="vertices"></param>
        /// <returns></returns>
        static List<TesselationEdge3f> MakeMonothone(List<TesselationVertex3f> vertices)
        {
            // 1) Vertices are sorted.
            TesselationSweepEdges3f edges = new TesselationSweepEdges3f();
            List<TesselationEdge3f> split = new List<TesselationEdge3f>();

            // 2) We now go top-bottom.
            for (int i = 0; i < vertices.Count; i++)
            {
                switch (vertices[i].VertexType)
                {
                    case TesselationVertexType.Regular:
                        HandleRegularVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Start:
                        HandleStartVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.End:
                        HandleEndVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Split:
                        HandleSplitVertex(vertices[i], split, edges);
                        break;
                    case TesselationVertexType.Merge:
                        HandleMergeVertex(vertices[i], split, edges);
                        break;
                }
            }

            return split;
        }

        static void HandleStartVertex(TesselationVertex3f vertex, List<TesselationEdge3f> splits, TesselationSweepEdges3f edges)
        {
            // We set helper to self.
            vertex.NextEdge.Helper = vertex;

            edges.Add(vertex.NextEdge);
        }

        static void HandleEndVertex(TesselationVertex3f vertex, List<TesselationEdge3f> splits, TesselationSweepEdges3f edges)
        {
            // We handle merge vertex.
            if (vertex.PreviousEdge.Helper != null &&
                vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge3f diag = new TesselationEdge3f();
                diag.Vertex1 = vertex;
                diag.Vertex2 = vertex.PreviousEdge.Helper;

                splits.Add(diag);
            }

            edges.Delete(vertex.PreviousEdge);
        }

        static void HandleSplitVertex(TesselationVertex3f vertex, List<TesselationEdge3f> splits, TesselationSweepEdges3f edges)
        {
            int edgeId =  edges.FindLeft(vertex.ProjectedPosition);

            // We create diagonal
            TesselationEdge3f diag = new TesselationEdge3f();
            diag.Vertex1 = vertex;
            diag.Vertex2 = edges[edgeId].Helper;
            splits.Add(diag);
            
            // Adjust helpers.
            edges[edgeId].Helper = vertex;

            // Add additional helper.
            vertex.NextEdge.Helper = vertex;
            edges.Add(vertex.NextEdge);
            
        }

        static void HandleMergeVertex(TesselationVertex3f vertex, List<TesselationEdge3f> splits, TesselationSweepEdges3f edges)
        {
            // We first check for previos merge.
            if (vertex.PreviousEdge.Helper != null &&
                vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge3f diag = new TesselationEdge3f();
                diag.Vertex1 = vertex;
                diag.Vertex2 = vertex.PreviousEdge.Helper;

                splits.Add(diag);
            }

            // We delete previous edge.
            edges.Delete(vertex.PreviousEdge);

            // We find left edge.
            int leftEdgeId = edges.FindLeft(vertex.ProjectedPosition);

            if (edges[leftEdgeId].Helper.VertexType == TesselationVertexType.Merge)
            {
                TesselationEdge3f diag = new TesselationEdge3f();
                diag.Vertex1 = vertex;
                diag.Vertex2 = edges[leftEdgeId].Helper;

                splits.Add(diag);
            }

            // We adjust helper.
            edges[leftEdgeId].Helper = vertex;
        }

        static void HandleRegularVertex(TesselationVertex3f vertex, List<TesselationEdge3f> splits, TesselationSweepEdges3f edges)
        {
            // We skip it if there is no interior to the right.
            if (InteriorToRight(vertex))
            {

                if (vertex.PreviousEdge.Helper != null &&
                    vertex.PreviousEdge.Helper.VertexType == TesselationVertexType.Merge)
                {
                    TesselationEdge3f diag = new TesselationEdge3f();
                    diag.Vertex1 = vertex;
                    diag.Vertex2 = vertex.PreviousEdge.Helper;

                    splits.Add(diag);
                }

                // We delete previous edge.
                edges.Delete(vertex.PreviousEdge);

                // We insert new edge.
                vertex.NextEdge.Helper = vertex;
                edges.Add(vertex.NextEdge);

            }
            else
            {
                // We insert the merge vertex.
                int edgeId = edges.FindLeft(vertex.ProjectedPosition);
                if (edges[edgeId].Helper.VertexType == TesselationVertexType.Merge)
                {
                    TesselationEdge3f diag = new TesselationEdge3f();
                    diag.Vertex1 = vertex;
                    diag.Vertex2 = edges[edgeId].Helper;

                    splits.Add(diag);
                }

                edges[edgeId].Helper = vertex;
            }
        }

        static bool OnTheSameChain(TesselationVertex3f current, TesselationVertex3f top)
        {
            bool onTheSameChain = false;
            if (current.NextEdge.Vertex2 == top || current.PreviousEdge.Vertex1 == top) onTheSameChain = true;
            if (!onTheSameChain && current.AdditionalDiagonals != null)
            {
                for (int j = 0; j < current.AdditionalDiagonals.Count; j++)
                {
                    if (current.AdditionalDiagonals[j].Vertex1 == top ||
                       current.AdditionalDiagonals[j].Vertex2 == top)
                    {
                        onTheSameChain = true;
                        break;
                    }
                }
            }
            return onTheSameChain;
        }

        /// <summary>
        /// Triangulates monotone polygon. Vertices are added to buffer.
        /// </summary>
        /// <param name="sortedMonothone"></param>
        /// <param name="meshBuilder"></param>
        static void TriangulateMonotone(List<TesselationVertex3f> sorted, 
            Storage.Builders.ITriangleBuilder3f meshBuilder)
        {
            // At least three vertices
            if (sorted.Count < 3) return;

            Stack<TesselationVertex3f> stack = new Stack<TesselationVertex3f>();

            // Identifies vertices on left chain as true, false if right chain.
            bool[] leftChain = new bool[sorted.Count];
            {
                // FIXME: are vertical beginings handled correctly. They do not arise
                // commonly ... so we leave it for now

                TesselationVertex3f left;
                if (sorted[0].ProjectedPosition.X <= sorted[1].ProjectedPosition.X)
                {
                    left = sorted[0];
                    leftChain[0] = true;
                    leftChain[1] = false;
                }
                else
                {
                    left = sorted[1];
                    leftChain[0] = false;
                    leftChain[1] = true;
                }

                // We now set the chains.
                for (int i = 2; i < sorted.Count - 1; i++)
                {
                    TesselationVertex3f current = sorted[i];

                    if (OnTheSameChain(current, left))
                    {
                        leftChain[i] = true;
                        left = current;
                    }
                    else
                    {
                        leftChain[i] = false;
                    }
                }
            }


            // We push first two vertices.
            stack.Push(sorted[0]);
            stack.Push(sorted[1]);

            // We enter the loop.
            for (int i = 2; i < sorted.Count - 1; i++)
            {
                TesselationVertex3f current = sorted[i];
                TesselationVertex3f top = stack.Pop();

                // We check if on the same side (same chain).



                if (OnTheSameChain(current, top))
                {
                    // In this case, we generate diagonals with elements on stack as long as we can
                    // (as long as they are legal).

                    // We link to all vertices we can stack.
                    TesselationVertex3f p1 = top, p2 = null;
                    uint curId = current.VertexIndex;

                    while (stack.Count > 0)
                    {
                        p2 = stack.Pop();

                        
                        // We first check if it is possible (orientation of triangle).
                        Vector3f normal = (p2.ProjectedPosition - p1.ProjectedPosition).Vec3 ^
                            (current.ProjectedPosition - p1.ProjectedPosition).Vec3;

                        bool isIrregular = leftChain[i] ? normal.Z > 0.0f : normal.Z < 0.0f;

                        if (isIrregular)
                        {
                            stack.Push(p2);
                            p2 = p1;
                            break;
                        }
                        


                        // We have a triangle, we may need to ensure vertices are added.
                        uint p1Id = p1.VertexIndex;
                        uint p2Id = p2.VertexIndex;

                        // We add triangle and relink.
                        meshBuilder.AddIndexedTriangles(new uint[] {curId, p2Id, p1Id});

                        // We relink.
                        p1 = p2;
                    }

                    // We push back to stack.
                    stack.Push(p2);
                    stack.Push(current);
                }
                // Different chains.
                else
                {
                    // We link to all vertices on stack.
                    TesselationVertex3f p1 = top, p2;
                    uint curId = current.VertexIndex;

                    while (stack.Count > 0)
                    {
                        // We pop the second one.
                        p2 = stack.Pop();

                        // We have a triangle, we may need to ensure vertices are added.
                        uint p1Id = p1.VertexIndex;
                        uint p2Id = p2.VertexIndex;

                        // We now add triangle.
                        meshBuilder.AddIndexedTriangles(new uint[] {curId, p2Id, p1Id });

                        // We relink.
                        p1 = p2;
                    }

                    // At the end, we push current-1 and current.
                    stack.Push(sorted[i - 1]);
                    stack.Push(current);
                }
            }

            // We end it.
            
            if (stack.Count > 0)
            {
                TesselationVertex3f current = sorted[sorted.Count - 1];
                TesselationVertex3f top = stack.Pop();

                while (stack.Count > 0)
                {
                    TesselationVertex3f other = stack.Pop();

                    meshBuilder.AddIndexedTriangles(new uint[] {current.VertexIndex, other.VertexIndex, top.VertexIndex});

                    top = other;
                }
            }
        }

        #endregion

        #region Public Static Members

        /// <summary>
        /// Converts polygon group to triangle mesh.
        /// </summary>
        /// <param name="polygons">The polygon contours.</param>
        /// <param name="builder">The builder where results are written.</param>
        public static void Tesselate(List<Vector3f[]> polygons,
            Storage.Builders.ITriangleBuilder3f builder)
        {
            Tesselate(polygons, builder, TesselationOptions.BoundableHolesIdentify);
        }


        /// <summary>
        /// Converts polygon group to triangle mesh.
        /// </summary>
        /// <param name="polygons">The polygon contours.</param>
        /// <param name="builder">The builder where results are written.</param>
        /// <param name="options">Tesselation options.</param>
        public static void Tesselate(List<Vector3f[]> polygons,
            Storage.Builders.ITriangleBuilder3f builder, TesselationOptions options)
        {
            if (!builder.IsIndexed)
            {
                throw new InvalidOperationException("Only indexed builder supported for now.");
            }


            // We first create linked list.
            List<TesselationVertex3f> vertices = new List<TesselationVertex3f>();
            List<TesselationVertex3f> beginning = new List<TesselationVertex3f>();
            

            CreateLinked(polygons, vertices, beginning, builder, options);

            // We make the polygon monothone by using split diagonals.
            List<TesselationEdge3f> additionalDiagonals = MakeMonothone(vertices);


            {
                // May improve efficiency of algorithm.

                Stack<TesselationVertex3f> toVisit = new Stack<TesselationVertex3f>(10);
                for (int j = 0; j < beginning.Count; j++)
                {
                    toVisit.Push(beginning[j]);
                }

                // We first append diagonals to multi-linked list.
                for (int i = 0; i < additionalDiagonals.Count; i++)
                {
                    // We take the diagonal and add it to vertices.
                    TesselationEdge3f diag = additionalDiagonals[i];

                    if (diag.Vertex1.AdditionalDiagonals == null) diag.Vertex1.AdditionalDiagonals = new List<TesselationEdge3f>();
                    if (diag.Vertex2.AdditionalDiagonals == null) diag.Vertex2.AdditionalDiagonals = new List<TesselationEdge3f>();

                    diag.Vertex1.AdditionalDiagonals.Add(diag);
                    diag.Vertex2.AdditionalDiagonals.Add(diag);

                    // We also push one element of diagonal (in case they are split).
                    toVisit.Push(diag.Vertex1);
                }

                // We start at topmost vertex and create a polygon.
                List<TesselationVertex3f> monothone = new List<TesselationVertex3f>(vertices.Count);
                
                while (toVisit.Count > 0)
                {
                    // We first check if already visited.
                    TesselationVertex3f start = toVisit.Pop();
                    TesselationVertex3f current = start;
                    TesselationVertex3f prev = start.PreviousEdge.Vertex1;
                    if (!start.TryVisit()) continue;

                    // We begin a new monothone
                    monothone.Clear();

                    monothone.Add(start);

                    // We now transverse the polygon.
                    while(true)
                    {
                        TesselationVertex3f t = current;
                        current = current.NextVertex(prev); //< Left order.
                        prev = t;
                        if (current == null || current == start) break;

                        current.AddToVisits(toVisit);
                        monothone.Add(current);
                    }

                    // We sort monotone.
                    monothone.Sort();

                    // Monothone triangulate.
                    TriangulateMonotone(monothone, builder);
                }
            }

        }

        #endregion

        #endregion Vector3f

        //#endfor instanced to 'Vector3f'

    }
}
