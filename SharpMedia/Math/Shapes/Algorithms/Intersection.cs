// This file was generated by TemplateEngine from template source 'Intersection'
// using template 'Intersection. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.Math.Matrix;
using SharpMedia.AspectOriented;

namespace SharpMedia.Math.Shapes
{

    /// <summary>
    /// An intersection class allows intersecting many primitve pairs.
    /// </summary>
    /// <remarks>There are usually many intersection provided for the same pair type.</remarks>
    public static class Intersection
    {
        #region LineSeg-LineSeg Intersection

        
		//#foreach instanced to '2Dd'


        /// <summary>
        /// Pure intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment2d one, LineSegment2d other)
        {
            double t1, t2;
            return Intersect(one, other, out t1, out t2);
        }

        /// <summary>
        /// Intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <param name="t1">The interpolation for first line segment, only if intersects is true.</param>
        /// <param name="t2">The interpolation for second line segment, only if intersects is true.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment2d one, LineSegment2d other, 
            out double t1, out double t2)
        {
            t1 = t2 = 0.0;

            // We solve 2x2 system and then check if it is ok for the third argument.
            Vector2d r = LinearSolver.SolveSystem(
                new Matrix2x2d(one.Direction.X, -other.Direction.X,
                               one.Direction.Y, -other.Direction.Y),
                new Vector2d(other.A.X - one.A.X, other.A.Y - one.A.Y));

            // If system has the solution, it must be in range [0,1].
            if (r.X < 0.0 || r.X > 0.0) return false;
            if (r.Y < 0.0 || r.Y > 0.0) return false;

            // We check if the last line satisfies.
            if (!Vector2d.NearEqual(one.Sample(r.X), other.Sample(r.Y))) return false;

            // We copy interpolation.
            t1 = r.X;
            t2 = r.Y;
            return true;
        }

        /// <summary>
        /// Intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <param name="result">The resulting intersection point, only if it returns true.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment2d one, LineSegment2d other, out Vector2d result)
        {
            double t1, t2;
            if (!Intersect(one, other, out t1, out t2))
            {
                result = Vector2d.Zero;
                return false;
            }
            else
            {
                result = one.Sample(t1);
                return true;
            }
        }

        //#endfor instanced to '2Dd'

		//#foreach instanced to '2Df'


        /// <summary>
        /// Pure intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment2f one, LineSegment2f other)
        {
            float t1, t2;
            return Intersect(one, other, out t1, out t2);
        }

        /// <summary>
        /// Intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <param name="t1">The interpolation for first line segment, only if intersects is true.</param>
        /// <param name="t2">The interpolation for second line segment, only if intersects is true.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment2f one, LineSegment2f other, 
            out float t1, out float t2)
        {
            t1 = t2 = 0.0f;

            // We solve 2x2 system and then check if it is ok for the third argument.
            Vector2f r = LinearSolver.SolveSystem(
                new Matrix2x2f(one.Direction.X, -other.Direction.X,
                               one.Direction.Y, -other.Direction.Y),
                new Vector2f(other.A.X - one.A.X, other.A.Y - one.A.Y));

            // If system has the solution, it must be in range [0,1].
            if (r.X < 0.0f || r.X > 0.0f) return false;
            if (r.Y < 0.0f || r.Y > 0.0f) return false;

            // We check if the last line satisfies.
            if (!Vector2f.NearEqual(one.Sample(r.X), other.Sample(r.Y))) return false;

            // We copy interpolation.
            t1 = r.X;
            t2 = r.Y;
            return true;
        }

        /// <summary>
        /// Intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <param name="result">The resulting intersection point, only if it returns true.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment2f one, LineSegment2f other, out Vector2f result)
        {
            float t1, t2;
            if (!Intersect(one, other, out t1, out t2))
            {
                result = Vector2f.Zero;
                return false;
            }
            else
            {
                result = one.Sample(t1);
                return true;
            }
        }

        //#endfor instanced to '2Df'

		//#foreach instanced to '3Dd'


        /// <summary>
        /// Pure intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment3d one, LineSegment3d other)
        {
            double t1, t2;
            return Intersect(one, other, out t1, out t2);
        }

        /// <summary>
        /// Intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <param name="t1">The interpolation for first line segment, only if intersects is true.</param>
        /// <param name="t2">The interpolation for second line segment, only if intersects is true.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment3d one, LineSegment3d other, 
            out double t1, out double t2)
        {
            t1 = t2 = 0.0;

            // We solve 2x2 system and then check if it is ok for the third argument.
            Vector2d r = LinearSolver.SolveSystem(
                new Matrix2x2d(one.Direction.X, -other.Direction.X,
                               one.Direction.Y, -other.Direction.Y),
                new Vector2d(other.A.X - one.A.X, other.A.Y - one.A.Y));

            // If system has the solution, it must be in range [0,1].
            if (r.X < 0.0 || r.X > 0.0) return false;
            if (r.Y < 0.0 || r.Y > 0.0) return false;

            // We check if the last line satisfies.
            if (!Vector3d.NearEqual(one.Sample(r.X), other.Sample(r.Y))) return false;

            // We copy interpolation.
            t1 = r.X;
            t2 = r.Y;
            return true;
        }

        /// <summary>
        /// Intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <param name="result">The resulting intersection point, only if it returns true.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment3d one, LineSegment3d other, out Vector3d result)
        {
            double t1, t2;
            if (!Intersect(one, other, out t1, out t2))
            {
                result = Vector3d.Zero;
                return false;
            }
            else
            {
                result = one.Sample(t1);
                return true;
            }
        }

        //#endfor instanced to '3Dd'

		//#foreach instanced to '3Df'


        /// <summary>
        /// Pure intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment3f one, LineSegment3f other)
        {
            float t1, t2;
            return Intersect(one, other, out t1, out t2);
        }

        /// <summary>
        /// Intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <param name="t1">The interpolation for first line segment, only if intersects is true.</param>
        /// <param name="t2">The interpolation for second line segment, only if intersects is true.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment3f one, LineSegment3f other, 
            out float t1, out float t2)
        {
            t1 = t2 = 0.0f;

            // We solve 2x2 system and then check if it is ok for the third argument.
            Vector2f r = LinearSolver.SolveSystem(
                new Matrix2x2f(one.Direction.X, -other.Direction.X,
                               one.Direction.Y, -other.Direction.Y),
                new Vector2f(other.A.X - one.A.X, other.A.Y - one.A.Y));

            // If system has the solution, it must be in range [0,1].
            if (r.X < 0.0f || r.X > 0.0f) return false;
            if (r.Y < 0.0f || r.Y > 0.0f) return false;

            // We check if the last line satisfies.
            if (!Vector3f.NearEqual(one.Sample(r.X), other.Sample(r.Y))) return false;

            // We copy interpolation.
            t1 = r.X;
            t2 = r.Y;
            return true;
        }

        /// <summary>
        /// Intersection test.
        /// </summary>
        /// <remarks>Test does not handle parallel lines.</remarks>
        /// <param name="one">The first line segment.</param>
        /// <param name="other">The second line segment.</param>
        /// <param name="result">The resulting intersection point, only if it returns true.</param>
        /// <returns>Do lines intersect.</returns>
        public static bool Intersect(LineSegment3f one, LineSegment3f other, out Vector3f result)
        {
            float t1, t2;
            if (!Intersect(one, other, out t1, out t2))
            {
                result = Vector3f.Zero;
                return false;
            }
            else
            {
                result = one.Sample(t1);
                return true;
            }
        }

        //#endfor instanced to '3Df'


        #endregion

        #region LineSeg-Triangle Intersection

        
		//#foreach instanced to '3Dd'


        //#ifdef 3D


        /// <summary>
        /// A line-triangle intersection.
        /// </summary>
        /// <remarks>Only point is returned. In case of line segment lying on top of triangle, one
        /// point is only returned.</remarks>
        /// <param name="line">The line segment</param>
        /// <param name="triangle">The triangle</param>
        /// <param name="point">The intersection point.</param>
        /// <returns>Does intersection occur</returns>
        private static bool Intersect(LineSegment3d line, Triangle3d triangle, out Vector3d point)
        {
            // We compute distance of ray of plane.
            double d = -((line.A - triangle.A) * triangle.Normal) / (line.Direction * triangle.Normal);

            // We exit quickly if intersection does not occur on line.
            if (d < 0.0 || d > 1.0)
            {
                point = Vector3d.Zero;
                return false;
            }

            // We now compute the actual point on the plane.
            point = line.A + d * line.Direction;

            // We have to determine if point lies inside triangle. We do it using barycentric
            // coordinates. We solve the system with two unknowns.
            Vector2d uv = triangle.GetBarycentric(point);

            // Is it inside.
            return Triangle3d.IsBaryCentricInside(uv);
        }

        //#endif

        //#endfor instanced to '3Dd'

		//#foreach instanced to '3Df'


        //#ifdef 3D


        /// <summary>
        /// A line-triangle intersection.
        /// </summary>
        /// <remarks>Only point is returned. In case of line segment lying on top of triangle, one
        /// point is only returned.</remarks>
        /// <param name="line">The line segment</param>
        /// <param name="triangle">The triangle</param>
        /// <param name="point">The intersection point.</param>
        /// <returns>Does intersection occur</returns>
        private static bool Intersect(LineSegment3f line, Triangle3f triangle, out Vector3f point)
        {
            // We compute distance of ray of plane.
            float d = -((line.A - triangle.A) * triangle.Normal) / (line.Direction * triangle.Normal);

            // We exit quickly if intersection does not occur on line.
            if (d < 0.0f || d > 1.0f)
            {
                point = Vector3f.Zero;
                return false;
            }

            // We now compute the actual point on the plane.
            point = line.A + d * line.Direction;

            // We have to determine if point lies inside triangle. We do it using barycentric
            // coordinates. We solve the system with two unknowns.
            Vector2f uv = triangle.GetBarycentric(point);

            // Is it inside.
            return Triangle3f.IsBaryCentricInside(uv);
        }

        //#endif

        //#endfor instanced to '3Df'


        #endregion

        #region Triangle-Triangle Intersection

        #endregion

        #region Triangle-Ray Intersection

        
		//#foreach instanced to '2Dd'


        

        //#endfor instanced to '2Dd'

		//#foreach instanced to '2Df'


        

        //#endfor instanced to '2Df'

		//#foreach instanced to '3Dd'


        //#ifdef 3D


        /// <summary>
        /// Intersect triangle and ray, fast barycentric coordinate version.
        /// </summary>
        /// <param name="t">Triangle.</param>
        /// <param name="Normal">Possibly precomputed normal.</param>
        /// <param name="r">The ray.</param>
        /// <param name="p">The output collision, valid if true is returned.</param>
        /// <returns>Intersection result</returns>
        public static bool Intersect(Triangle3d t, Ray3d r, double maxDist, out Vector3d p)
        {
            Vector3d Normal = t.Normal;

            // We compute distance of ray of plane.
            double d = -((r.Origin - t.A) * Normal) / (r.Direction * Normal);

            // We exit quickly if intersection occurs behind ray, or if intersection does not
            // exist.
            if (d < 0.0 || d >= maxDist || double.IsNaN(d))
            {
                p = Vector3d.Zero;
                return false;
            }

            // We now compute the actual point on the plane.
            p = r.Origin + d * r.Direction;

            // We have to determine if point lies inside triangle. We do it using barycentric
            // coordinates. We solve the system with two unknowns.
            Vector2d uv = t.GetBarycentric(p);

            // Is it inside.
            if (Triangle3d.IsBaryCentricInside(uv))
            {
                return true;
            }
            return false;
        }

        //#endif

        //#endfor instanced to '3Dd'

		//#foreach instanced to '3Df'


        //#ifdef 3D


        /// <summary>
        /// Intersect triangle and ray, fast barycentric coordinate version.
        /// </summary>
        /// <param name="t">Triangle.</param>
        /// <param name="Normal">Possibly precomputed normal.</param>
        /// <param name="r">The ray.</param>
        /// <param name="p">The output collision, valid if true is returned.</param>
        /// <returns>Intersection result</returns>
        public static bool Intersect(Triangle3f t, Ray3f r, float maxDist, out Vector3f p)
        {
            Vector3f Normal = t.Normal;

            // We compute distance of ray of plane.
            float d = -((r.Origin - t.A) * Normal) / (r.Direction * Normal);

            // We exit quickly if intersection occurs behind ray, or if intersection does not
            // exist.
            if (d < 0.0 || d >= maxDist || float.IsNaN(d))
            {
                p = Vector3f.Zero;
                return false;
            }

            // We now compute the actual point on the plane.
            p = r.Origin + d * r.Direction;

            // We have to determine if point lies inside triangle. We do it using barycentric
            // coordinates. We solve the system with two unknowns.
            Vector2f uv = t.GetBarycentric(p);

            // Is it inside.
            if (Triangle3f.IsBaryCentricInside(uv))
            {
                return true;
            }
            return false;
        }

        //#endif

        //#endfor instanced to '3Df'


        #endregion

        #region Triangle-Line Intersection

        
		//#foreach instanced to '3Dd'


        //#ifdef 3D


        /// <summary>
        /// Triangle-Line intersection helper (only 3D version).
        /// </summary>
        /// <param name="t">The triangle.</param>
        /// <param name="r">The line.</param>
        /// <param name="p">Point of intersection.</param>
        /// <returns>Does intersection exist.</returns>
        private static bool Intersect(Triangle3d t, Line3d r, out Vector3d p)
        {
            Vector3d Normal = t.Normal;

            // We compute distance of line of plane.
            double d = -((r.A - t.A) * Normal) / (r.Direction * Normal);

            // We now compute the actual point on the plane.
            p = r.A + d * r.Direction;

            // We have to determine if point lies inside triangle. We do it using barycentric
            // coordinates. We solve the system with two unknowns.
            Vector2d uv = t.GetBarycentric(p);

            // Is it inside.
            return Triangle3d.IsBaryCentricInside(uv);
        }

        //#endif

        //#endfor instanced to '3Dd'

		//#foreach instanced to '3Df'


        //#ifdef 3D


        /// <summary>
        /// Triangle-Line intersection helper (only 3D version).
        /// </summary>
        /// <param name="t">The triangle.</param>
        /// <param name="r">The line.</param>
        /// <param name="p">Point of intersection.</param>
        /// <returns>Does intersection exist.</returns>
        private static bool Intersect(Triangle3f t, Line3f r, out Vector3f p)
        {
            Vector3f Normal = t.Normal;

            // We compute distance of line of plane.
            float d = -((r.A - t.A) * Normal) / (r.Direction * Normal);

            // We now compute the actual point on the plane.
            p = r.A + d * r.Direction;

            // We have to determine if point lies inside triangle. We do it using barycentric
            // coordinates. We solve the system with two unknowns.
            Vector2f uv = t.GetBarycentric(p);

            // Is it inside.
            return Triangle3f.IsBaryCentricInside(uv);
        }

        //#endif

        //#endfor instanced to '3Df'


        #endregion

        #region Bezier-Bezier Intersection

        
		//#foreach instanced to '2Dd'


        /// <summary>
        /// Intersection of two beziers.
        /// </summary>
        private static bool Intersect(Bezier2d b1, Bezier2d b2, out Vector2d p)
        {
            throw new NotImplementedException();
        }

        //#endfor instanced to '2Dd'

		//#foreach instanced to '2Df'


        /// <summary>
        /// Intersection of two beziers.
        /// </summary>
        private static bool Intersect(Bezier2f b1, Bezier2f b2, out Vector2f p)
        {
            throw new NotImplementedException();
        }

        //#endfor instanced to '2Df'

		//#foreach instanced to '3Dd'


        /// <summary>
        /// Intersection of two beziers.
        /// </summary>
        private static bool Intersect(Bezier3d b1, Bezier3d b2, out Vector3d p)
        {
            throw new NotImplementedException();
        }

        //#endfor instanced to '3Dd'

		//#foreach instanced to '3Df'


        /// <summary>
        /// Intersection of two beziers.
        /// </summary>
        private static bool Intersect(Bezier3f b1, Bezier3f b2, out Vector3f p)
        {
            throw new NotImplementedException();
        }

        //#endfor instanced to '3Df'


        #endregion

        // TODO: add missing 2D alternatives (for lines, rays etc.) and many other
        // intersection pairs!
    }
}
