// This file was generated by TemplateEngine from template source 'OutlineCompund'
// using template 'OutlineCompound2d. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.Testing;
using SharpMedia.Math.Matrix;
using SharpMedia.Math.Shapes.Algorithms;

namespace SharpMedia.Math.Shapes.Compounds
{



    /// <summary>
    /// An outline compund.
    /// </summary>
    /// <remarks>Outline class is provided to enable "easy" access to tesselation and storage
    /// of linked shapes. Other operations are also provided.</remarks>
    [Serializable]
    public sealed class OutlineCompound2d :
        IArea2d, IOutline2d, ITransformable2d, ICloneable<OutlineCompound2d>
    {
        #region Private Class

        /// <summary>
        /// A helper class that is used to create line contours.
        /// </summary>
        private class ContourBuilder : Storage.Builders.ILineBuilder2d
        {
            #region Private Members
            List<Vector2d[]> contours = new List<Vector2d[]>();
            #endregion

            #region Properties

            /// <summary>
            /// Obtains contours.
            /// </summary>
            public List<Vector2d[]> Contours
            {
                get
                {
                    return contours;
                }
            }

            #endregion

            #region Contructors

            /// <summary>
            /// Default constructor.
            /// </summary>
            public ContourBuilder()
            {
            }

            #endregion

            #region Helper Methods

            void FinishContour()
            {
                if (contours.Count == 0) return;
                Vector2d[] lastCountour = contours[contours.Count - 1];
                if (lastCountour == null) return;
                contours.Add(null);
            }


            #endregion

            #region Builders.ILineBuilder2d Members

            public bool IsIndexed
            {
                get { return false; }
            }


            public uint AddControlPoints(params Vector2d[] data)
            {
                // We try to figure out strips, if possible.

                throw new NotImplementedException();
            }


            public void AddIndexedLines(params uint[] indices)
            {
                throw new InvalidOperationException("The call to AddIndexedLines is invalid because builder is not indexed.");
            }

            public void AddLineStrip(bool linkFirstToLast, params Vector2d[] data)
            {
                // We try to inteligently add a strip.
                if (linkFirstToLast)
                {
                    // We make sure strip is finised.
                    FinishContour();

                    // We surely have a seperate strip.
                    Vector2d[] newData = new Vector2d[data.Length + 1];
                    data.CopyTo(newData, 0);
                    newData[data.Length] = data[0];
                    contours.Add(newData);

                    // We make sure strip is finished.
                    FinishContour();
                }
                else
                {
                    // We check if we can continue strip.
                    if (contours.Count > 0)
                    {
                        Vector2d[] lastContour = contours[contours.Count - 1];

                        // It means it is ending.
                        if (lastContour == null)
                        {
                            contours.Add(data);
                        }

                        // Else we check for append.
                        if (lastContour != null && Vector2d.NearEqual(lastContour[lastContour.Length - 1], data[0]))
                        {
                            // We append data.
                            Vector2d[] newData = new Vector2d[data.Length + lastContour.Length];
                            int i;
                            for (i = 0; i < lastContour.Length; i++)
                            {
                                newData[i] = lastContour[i];
                            }
                            for (; i < newData.Length; i++)
                            {
                                newData[i] = data[i - lastContour.Length];
                            }

                            contours[contours.Count - 1] = newData;
                            if (Vector2d.NearEqual(newData[0], newData[newData.Length - 1])) FinishContour();

                        }
                        else
                        {
                            FinishContour();
                            contours.Add(data);
                        }
                    }
                }
            }

            #endregion
        }

        #endregion

        #region Public Members
        IOutline2d[] outlines;
        #endregion

        #region Properties

        /// <summary>
        /// Outline indexer.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public IOutline2d this[uint index]
        {
            get
            {
                return outlines[index];
            }
        }

        /// <summary>
        /// Is the path closed.
        /// </summary>
        public bool IsClosed
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        /// <summary>
        /// The stop indices, if any.
        /// </summary>
        public uint[] StopIndices
        {
            get
            {
                List<uint> stops = new List<uint>();
                for (int i = 1; i < outlines.Length; i++)
                {
                    if (Vector2d.NearEqual(outlines[i].Sample(0.0), outlines[i - 1].Sample(1.0)))
                    {
                        stops.Add((uint)(i - 1));
                    }
                }
                return stops.ToArray();
            }
        }



        #endregion

        #region Public Members

        //#ifdef TesselationOptions


        /// <summary>
        /// Tesselates an outline.
        /// </summary>
        /// <param name="resolution"></param>
        /// <param name="options"></param>
        public void TesselateOutline(float resolution,
            OutlineTesselation.TesselationOptionsd options, Storage.Builders.ITriangleBuilder2d builder)
        {
            // We first generate contours.
            ContourBuilder contourBuilder = new ContourBuilder();
            Sample(resolution, contourBuilder);

            // Now we create outlines for each contour.
            for (int i = 0; i < contourBuilder.Contours.Count; i++)
            {
                OutlineTesselation.Tesselate(contourBuilder.Contours[i], options, builder);
            }
        }

        //#endif

        #endregion

        #region Constructors

        /// <summary>
        /// Triangle constructor.
        /// </summary>
        public OutlineCompound2d()
        {
        }

        /// <summary>
        /// Triangle construction.
        /// </summary>
        /// <param name="data"></param>
        public OutlineCompound2d(params IOutline2d[] outlines)
        {
            this.outlines = outlines;
        }

        #endregion

        #region Overrides

        public override string ToString()
        {
            return base.ToString();
        }

        public override bool Equals(object obj)
        {
            if (obj is OutlineCompound2d)
            {
                return this.Equals((OutlineCompound2d)obj);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #endregion

        #region IArea2d Members

        public double Area
        {
            get
            {
                return double.NaN;
            }
        }

        public void Tesselate(double resolution, Storage.Builders.ITriangleBuilder2d builder)
        {
            // We create a special line builder that will create contours.
            ContourBuilder contourBuilder = new ContourBuilder();
            Sample(resolution, contourBuilder);

            // We now invoke the algorithm.
            Algorithms.PolygonTesselation.Tesselate(contourBuilder.Contours, builder);
        }

        #endregion

        #region IOutline2d Members

        public Vector2d Sample(double t)
        {
            uint outlineIndex = (uint)(t * (double)outlines.Length);
            double interp = t * (double)outlines.Length - (double)outlineIndex;

            return outlines[outlineIndex].Sample(interp);
        }

        public void Sample(double resolution, Storage.Builders.ILineBuilder2d builder)
        {
            for (int i = 0; i < outlines.Length; i++)
            {
                outlines[i].Sample(resolution, builder);
            }
        }

        #endregion

        #region IOutlined Members

        public double OutlineLength
        {
            get
            {
                double length = 0.0;
                for (int i = 0; i < outlines.Length; i++)
                {
                    length += outlines[i].OutlineLength;
                }
                return length;
            }

        }

        #endregion

        #region ITransformable2d

        public void Transform(Matrix.Matrix3x3d matrix)
        {
            for (int i = 0; i < outlines.Length; i++)
            {
                if (!(outlines[i] is ITransformable2d))
                {
                    throw new InvalidOperationException(
                        string.Format("The outline '{0}' at index '{1}' is not transformable", outlines[i], i));
                }
            }

            for (int i = 0; i < outlines.Length; i++)
            {
                (outlines[i] as ITransformable2d).Transform(matrix);
            }
        }

        #endregion

        #region ICloneable Members

        public OutlineCompound2d Clone()
        {
            return new OutlineCompound2d(outlines);
        }

        #endregion
    }


#if SHARPMEDIA_TESTSUITE
    [TestSuite]
    internal class Test_OutlineCompound2d
    {
        [CorrectnessTest]
        public void Construction()
        {
            
        }

       

    }
#endif
}
