// This file was generated by TemplateEngine from template source 'Complex'
// using template 'Complexd. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;

using SharpMedia.Testing;

namespace SharpMedia.Math
{
    /// <summary>
    /// A double -based complex number.
    /// </summary>
    [Serializable]
    public struct Complexd : IComparable, IComparable<Complexd>, IEquatable<Complexd>
    {
        #region Public Members

        /// <summary>
        /// Real part of complex number.
        /// </summary>
        public double Re;

        /// <summary>
        /// Imagionary part of complex number.
        /// </summary>
        public double Im;

        #endregion

        #region Static Members

        /// <summary>
        /// A zero complex number.
        /// </summary>
        public static Complexd Zero
        {
            get
            {
                return new Complexd(0.0, 0.0);
            }
        }

        /// <summary>
        /// A unity complex number.
        /// </summary>
        public static Complexd One
        {
            get
            {
                return new Complexd(1.0, 0.0);
            }
        }

        /// <summary>
        /// Converts to the complex array (expands by filling 0.0 as imagionary component).
        /// </summary>
        /// <param name="array">The array.</param>
        /// <returns></returns>
        public static Complexd[] ToComplexArray(params double[] array)
        {
            Complexd[] result = new Complexd[array.Length];
            for (int i = 0; i < array.Length; i++)
            {
                result[i] = new Complexd(array[i], 0.0);
            }

            return result;
        }

        /// <summary>
        /// Converts to the scalar array by ignoring imagionary components.
        /// </summary>
        /// <param name="array">The array.</param>
        /// <returns></returns>
        public static double[] ToScalarArray(params Complexd[] array)
        {
            double[] result = new double[array.Length];
            for (int i = 0; i < array.Length; i++)
            {
                result[i] = array[i].Re;
            }

            return result;
        }


        //#ifdef NearEqual


        /// <summary>
        /// Are complex numbers nearly equal.
        /// </summary>
        public static bool NearEqual(Complexd c1, Complexd c2, double eps)
        {
            return MathHelper.NearEqual(c1.Re, c2.Re, eps) && MathHelper.NearEqual(c1.Im, c2.Im, eps);
        }

        /// <summary>
        /// Are complex numbers nearly equal.
        /// </summary>
        public static bool NearEqual(Complexd c1, Complexd c2)
        {
            return MathHelper.NearEqual(c1.Re, c2.Re) && MathHelper.NearEqual(c1.Im, c2.Im);
        }

        //#endif

        //#ifdef UniformRandomSupply


        /// <summary>
        /// Unit random complex supply.
        /// </summary>
        public static Complexd UnitRandom
        {
            get
            {
                Complexd cpx = new Complexd(MathHelper.UniformRandom(), MathHelper.UniformRandom());
                return cpx.Unit;
            }
        }

        //#endif

        #endregion

        #region Operators

        /// <summary>
        /// Complex multiplication.
        /// </summary>
        /// <param name="c1">The first complex.</param>
        /// <param name="c2">The second complex.</param>
        /// <returns>The result.</returns>
        public static Complexd operator *(Complexd c1, Complexd c2)
        {
            return new Complexd(c1.Re * c2.Re - c1.Im * c2.Im, c1.Re * c2.Im + c1.Im * c2.Re);
        }

        /// <summary>
        /// The complex-scalar multiplication.
        /// </summary>
        /// <param name="c1">The complex.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Complex scaled by f.</returns>
        public static Complexd operator *(Complexd c1, double f)
        {
            return new Complexd(c1.Re * f, c1.Im * f);
        }

        /// <summary>
        /// The complex-scalar multiplication.
        /// </summary>
        /// <param name="c1">The complex.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Complex scaled by f.</returns>
        public static Complexd operator *(double f, Complexd c1)
        {
            return new Complexd(c1.Re * f, c1.Im * f);
        }

        /// <summary>
        /// The complex divided by scalar.
        /// </summary>
        /// <param name="c1">The complex.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Complex scaled by f.</returns>
        public static Complexd operator /(Complexd c1, double f)
        {
            return new Complexd(c1.Re / f, c1.Im / f);
        }

        /// <summary>
        /// Complex division.
        /// </summary>
        public static Complexd operator /(Complexd c1, Complexd c2)
        {
            return (c1 * c2.Conjugate) / (c2.Length2);
        }

        /// <summary>
        /// Complex addition
        /// </summary>
        /// <param name="c1">The first complex.</param>
        /// <param name="c2">The second complex.</param>
        /// <returns>The result.</returns>
        public static Complexd operator +(Complexd c1, Complexd c2)
        {
            return new Complexd(c1.Re + c2.Re, c1.Im + c2.Im);
        }

        /// <summary>
        /// Complex substraction.
        /// </summary>
        /// <param name="c1">The first complex.</param>
        /// <param name="c2">The second complex.</param>
        /// <returns>The result.</returns>
        public static Complexd operator -(Complexd c1, Complexd c2)
        {
            return new Complexd(c1.Re - c2.Re, c1.Im - c2.Im);
        }

        /// <summary>
        /// Checks if complexs are equal.
        /// </summary>
        /// <param name="c1">The first complex.</param>
        /// <param name="c2">The second complex.</param>
        /// <returns></returns>
        public static bool operator ==(Complexd c1, Complexd c2)
        {
            return (c1.Re == c2.Re) && (c1.Im == c2.Im);
        }


        /// <summary>
        /// Checks complexs if they are equal.
        /// </summary>
        /// <param name="c1"></param>
        /// <param name="c2"></param>
        /// <returns></returns>
        public static bool operator !=(Complexd c1, Complexd c2)
        {
            return !(c1 == c2);
        }

        #endregion

        #region Overrides

        /// <summary>
        /// We check if two complex are equal.
        /// </summary>
        /// <param name="obj">The other.</param>
        /// <returns>Compare value.</returns>
        public override bool Equals(object obj)
        {
            if (obj.GetType() == this.GetType()) return this == (Complexd)obj;
            return false;
        }

        /// <summary>
        /// Obtains hash code, based on values.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return Re.GetHashCode() ^ Im.GetHashCode();
        }

        /// <summary>
        /// Converts complex to string.
        /// </summary>
        /// <returns>The complex string.</returns>
        public override string ToString()
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(Re);
            if (Im >= 0.0)
            {
                builder.Append("+");
            }
            builder.Append(Im);
            builder.Append("i");

            return builder.ToString();
        }

        #endregion

        #region Properties
    
        //#ifdef Vector2ClassName


        /// <summary>
        /// 2D vector, defined as (Re, Im).
        /// </summary>
        public Vector2d Vec2
        {
            set { Re = value.X; Im = value.Y; }
            get { return new Vector2d(Re, Im); }
        }

        //#endif

        /// <summary>
        /// Is complex number real.
        /// </summary>
        public bool IsReal
        {
            get { return Im == 0.0; }
        }

        /// <summary>
        /// The real part of complex.
        /// </summary>
        [Obsolete]
        public double re
        {
            set { Re = value; }
            get { return Re; }
        }

        /// <summary>
        /// The imagionary part of complex.
        /// </summary>
        [Obsolete]
        public double im
        {
            set { Im = value; }
            get { return Im; }
        }

        /// <summary>
        /// Conversion from quaternion.
        /// </summary>
        public Quaterniond Quaternion
        {
            get
            {
                return new Quaterniond(Re, Im, 0.0, 0.0);
            }
        }

        /// <summary>
        /// Conjugate of complex number.
        /// </summary>
        /// <returns>The conjugate.</returns>
        public Complexd Conjugate
        {
            get
            {
                return new Complexd(Re, -Im);
            }
        }

        /// <summary>
        /// A squared distance.
        /// </summary>
        public double Distance2
        {
            get
            {
                return Re * Re + Im * Im;
            }
        }

        /// <summary>
        /// Length of complex number.
        /// </summary>
        public double Length2
        {
            get
            {
                return Re * Re + Im * Im;
            }
        }

        /// <summary>
        /// A unit complex number.
        /// </summary>
        public Complexd Unit
        {
            get
            {
                return this / Distance;
            }
        }

        //#ifdef Sqrt


        /// <summary>
        /// A distance from origin.
        /// </summary>
        public double Distance
        {
            get
            {
                return MathHelper.Sqrt(Distance2);
            }
        }

        /// <summary>
        /// Length of complex vector.
        /// </summary>
        public double Length
        {
            get
            {
                return MathHelper.Sqrt(Length2);
            }
        }

        //#endif

        //#ifdef PolarClassName


        /// <summary>
        /// Returns a polar form of complex number.
        /// </summary>
        public Polard Polar
        {
            get
            {
                return Vec2.Polar;
            }
        }

        //#endif

        #endregion

        #region Additional operations

        //#ifdef Pow PolarClassName


        /// <summary>
        /// Computes exponent.
        /// </summary>
        /// <param name="f"></param>
        /// <returns></returns>
        public static Complexd Pow(Complexd cmp, double f)
        {
            Polard polar = cmp.Polar;
            return Pow(polar, f);
        }

        /// <summary>
        /// Computes exponent of already converted complex number in polar form.
        /// </summary>
        /// <param name="polar"></param>
        /// <param name="f"></param>
        /// <returns></returns>
        public static Complexd Pow(Polard polar, double f)
        {
            return new Complexd(MathHelper.Pow(polar.R, f), polar.Phi * f);
        }

        /// <summary>
        /// A square root of complex number.
        /// </summary>
        /// <param name="cmp"></param>
        /// <returns></returns>
        public Complexd Sqrt(Complexd cmp)
        {
            return Pow(cmp, 1.0 / 2);
        }

        //#endif

        // TODO: interpolations

        #endregion

        #region Constructors

        /// <summary>
        /// Complex constructor.
        /// </summary>
        /// <param name="re">The real component.</param>
        /// <param name="im">The imaginary component.</param>
        public Complexd(double re, double im)
        {
            this.Re = re;
            this.Im = im;
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="cpx"></param>
        public Complexd(Complexd cpx)
        {
            this.Re = cpx.Re;
            this.Im = cpx.Im;
        }

        //#ifdef PolarClassName Cos Sin


        /// <summary>
        /// A polar conversion constructor.
        /// </summary>
        /// <param name="polar"></param>
        public Complexd(Polard polar)
        {
            this.Re = polar.R * MathHelper.Cos(polar.Phi);
            this.Im = polar.R * MathHelper.Sin(polar.Phi);
        }

        //#endif

        #endregion

        #region IEquatable<Complexd> Members

        public bool Equals(Complexd other)
        {
            return this == other;
        }

        #endregion

        #region IComparable Members

        public int CompareTo(object obj)
        {
            if (obj.GetType() == GetType())
            {
                return CompareTo((Complexd)obj);
            }
            return -1;
        }

        #endregion

        #region IComparable<Complexd> Members

        public int CompareTo(Complexd other)
        {
            int cmp = Re.CompareTo(other.Re);
            if(cmp != 0) return cmp;
            return Im.CompareTo(other.Im);
        }

        #endregion
    }
}
