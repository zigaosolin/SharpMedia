// This file was generated by TemplateEngine from template source 'Vector2'
// using template 'Vector2d. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//

using System;
using SharpMedia.Testing;

namespace SharpMedia.Math
{
    /// <summary>
    /// A two dimensional vector of genetic type. Two dimensional vector can also
    /// represent a point (with the same coordinates). It holds both point and vector
    /// functionality.
    /// </summary>
    [Serializable]
    public struct Vector2d
            : IComparable,
              IComparable<Vector2d>,
              IEquatable<Vector2d>
    {
        #region Public Members

        /// <summary>
        /// A vector processor delegate. Used at many places, like solver etc. Processor
        /// is a kind of Vector2d transformator.
        /// </summary>
        /// <param name="input">Input, as vector.</param>
        /// <returns>Vector output.</returns>
        public delegate Vector2d Processor(Vector2d input);

        /// <summary>
        /// The X component of the vector.
        /// </summary>
        public double X;

        /// <summary>
        /// The Y component of the vector.
        /// </summary>
        public double Y;

        #endregion

        #region Static Helpers

        /// <summary>
        /// A zero vector.
        /// </summary>
        public static Vector2d Zero
        {
            get { return new Vector2d(0.0, 0.0); }
        }

        /// <summary>
        /// Unit vector in axis X.
        /// </summary>
        public static Vector2d AxisX
        {
            get { return new Vector2d(0.0, 1.0); }
        }

        /// <summary>
        /// Unit vector in axis Y.
        /// </summary>
        public static Vector2d AxisY
        {
            get { return new Vector2d(0.0, 1.0); }
        }

        /// <summary>
        /// Component multiplication.
        /// </summary>
        /// <param name="v1">The vector.</param>
        /// <param name="v2">The seconf vector.</param>
        /// <returns>A vector, where each component is multiplief by another vector.</returns>
        public static Vector2d ComponentMultiply(Vector2d v1, Vector2d v2)
        {
            return new Vector2d(v1.X * v2.X, v1.Y * v2.Y);
        }

        /// <summary>
        /// Components division of two vectors.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Resulting vector.</returns>
        public static Vector2d ComponentDivision(Vector2d v1, Vector2d v2)
        {
            return new Vector2d(v1.X / v2.X, v1.Y / v2.Y);
        }

        //#ifdef NaN


        /// <summary>
        /// A NaN vector.
        /// </summary>
        public static Vector2d NaN
        {
            get
            {
                return new Vector2d(double.NaN, double.NaN);
            }
        }

        //#ifdef IsNaN


        /// <summary>
        /// Is a NaN vector.
        /// </summary>
        /// <param name="vec"></param>
        /// <returns></returns>
        public static bool IsNaN(Vector2d vec)
        {
            return double.IsNaN(vec.X) || double.IsNaN(vec.Y);
        }

        //#endif

        //#endif

        //#ifdef NearEqual


        /// <summary>
        /// Checks if vectors are nearly equal.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <param name="eps">The maximum difference in one component.</param>
        /// <returns>Are vectors equal indicator.</returns>
        public static bool NearEqual(Vector2d v1, Vector2d v2, double eps)
        {
            if (!MathHelper.NearEqual(v2.X, v1.X, eps)) return false;
            if (!MathHelper.NearEqual(v2.Y, v1.Y, eps)) return false;
            return true;
        }

        /// <summary>
        /// Near equal using default epsilon.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Result indicator.</returns>
        public static bool NearEqual(Vector2d v1, Vector2d v2)
        {
            if (!MathHelper.NearEqual(v1.X, v2.X)) return false;
            if (!MathHelper.NearEqual(v1.Y, v2.Y)) return false;
            return true;
        }

        //#endif

        //#ifdef UniformRandomSupply


        /// <summary>
        /// Unit random vector property.
        /// </summary>
        public static Vector2d UnitRandom
        {
            get
            {
                Vector2d vec = new Vector2d(MathHelper.UniformRandom(), MathHelper.UniformRandom());
                return vec.Normal;
            }
        }

        //#endif


        #endregion

        #region Overrides

        /// <summary>
        /// Outputs vector in (X,Y) form.
        /// </summary>
        /// <returns>Vector convertef to string.</returns>
        public override string ToString()
        {
            return "(" + X.ToString() + " ," + Y.ToString() + ")";
        }

        /// <summary>
        /// Checks if objects equal.
        /// </summary>
        /// <param name="obj">The other object.</param>
        /// <returns>Are objects equal.</returns>
        public override bool Equals(object obj)
        {
            if (obj.GetType() == this.GetType()) return this == (Vector2d)obj;
            return false;
        }

        /// <summary>
        /// Obtain the hash code.
        /// </summary>
        /// <returns>The hash code.</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #endregion

        #region Operators


        /// <summary>
        /// Overloadable addition.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Result of addition.</returns>
        public static Vector2d operator +(Vector2d v1, Vector2d v2)
        {
            return new Vector2d(v1.X + v2.X, v1.Y + v2.Y);
        }

        /// <summary>
        /// Overloadable substraction.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Result of substraction.</returns>
        public static Vector2d operator -(Vector2d v1, Vector2d v2)
        {
            return new Vector2d(v1.X - v2.X, v1.Y - v2.Y);
        }

        /// <summary>
        /// Overloadable multiplication, or so callef dot product. Result is a scalar.
        /// Dot product can be interpreteref as:
        /// <code>this * other == this.Length * other.Length * this.AngleTo(other)</code>
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The seconf vector.</param>
        /// <returns>Result of substraction.</returns>
        public static double operator *(Vector2d v1, Vector2d v2)
        {
            return v1.X * v2.X + v1.Y * v2.Y;
        }

        /// <summary>
        /// Vector multiplication with scalar.
        /// </summary>
        /// <param name="v1">The vector.</param>
        /// <param name="f">Scalar.</param>
        /// <returns>Result of operation.</returns>
        public static Vector2d operator *(Vector2d v1, double f)
        {
            return new Vector2d(v1.X * f, v1.Y * f);
        }

        /// <summary>
        /// Vector multiplication with scalar.
        /// </summary>
        /// <param name="v1">The vector.</param>
        /// <param name="f">Scalar.</param>
        /// <returns>Result of operation.</returns>
        public static Vector2d operator *(double f, Vector2d v1)
        {
            return new Vector2d(v1.X * f, v1.Y * f);
        }

        /// <summary>
        /// Vector dividef bY scalar.
        /// </summary>
        /// <param name="v1">The vector.</param>
        /// <param name="f">Scalar.</param>
        /// <returns>Result of operation.</returns>
        public static Vector2d operator /(Vector2d v1, double f)
        {
            return new Vector2d(v1.X / f, v1.Y / f);
        }


        /// <summary>
        /// Negation operator.
        /// </summary>
        /// <param name="v">The vector.</param>
        /// <returns>Negatef vector (direction flipped).</returns>
        public static Vector2d operator -(Vector2d v)
        {
            return v * 1.0;
        }

        /// <summary>
        /// Checks if vectors are equal. This check is precise anf maY not give desirable
        /// result if small errors occur due to precission errors.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The seconf vector.</param>
        /// <returns>Are vectorrs equal.</returns>
        public static bool operator ==(Vector2d v1, Vector2d v2)
        {
            return (v1.X == v2.X) && (v1.Y == v2.Y);
        }

        /// <summary>
        /// Returns if vectors are different.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The seconf vector.</param>
        /// <returns>Are vectors different.</returns>
        public static bool operator !=(Vector2d v1, Vector2d v2)
        {
            return !(v1 == v2);
        }

        #endregion

        #region Properties


        /// <summary>
        /// Index access to vector.
        /// </summary>
        /// <param name="indeX">The indeX.</param>
        public double this[uint index]
        {
            get
            {
                if (index == 0) return X;
                if (index == 1) return Y;
                throw new ArgumentException("Invalid index for 2D vector.");
            }
            set
            {
                if (index == 0) X = value;
                else if (index == 1) Y = value;
                else throw new ArgumentException("Invalid index for 2D vector.");
            }
        }

        /// <summary>
        /// The obsolete x-property getter.
        /// </summary>
        [Obsolete]
        public double x
        {
            get { return X; }
            set { X = value; }
        }

        /// <summary>
        /// The obsolete x-property getter.
        /// </summary>
        [Obsolete]
        public double y
        {
            get { return Y; }
            set { Y = value; }
        }

        //#ifdef Sqrt


        /// <summary>
        /// The length of vector.
        /// </summary>
        public double Length
        {
            get { return MathHelper.Sqrt(this * this); }
            set { this = this * value / MathHelper.Sqrt(this * this); }
        }

        /// <summary>
        /// Normalized direction.
        /// </summary>
        public Vector2d Direction
        {
            get { return this / Length; }
            set { this = value * Length; }
        }


        /// <summary>
        /// Normal vector, alwaYs length of 1.
        /// </summary>
        public Vector2d Normal
        {
            get { return this / Length; }
        }

        //#endif

        /// <summary>
        /// Length squaref.
        /// </summary>
        public double Length2
        {
            get { return this * this; }
            set { this = this * value / (this * this); }
        }

        //#ifdef Vector3ClassName


        /// <summary>
        /// The same vector, but in 3D (the z = 0).
        /// </summary>
        public Vector3d Vec3
        {
            set { X = value.X; Y = value.Y; }
            get { return new Vector3d(X, Y, 0.0); }
        }

        //#endif

        //#ifdef ComplexClassName


        /// <summary>
        /// Complex property.
        /// </summary>
        public Complexd Complex
        {
            set { X = value.Re; Y = value.Im; }
            get { return new Complexd(X, Y); }
        }

        //#endif

        //#ifdef PolarClassName Cos Sin Atan


        /// <summary>
        /// Polar property.
        /// </summary>
        public Polard Polar
        {
            set
            {
                X = MathHelper.Cos(value.Phi) * value.R;
                Y = MathHelper.Sin(value.Phi) * value.R;
            }
            get
            {
                // We must also handle "special" X=0 case.
                if (X != 0.0)
                {
                    return new Polard(MathHelper.ATan(Y / X), Length);
                }
                else
                {
                    return new Polard(Y < 0.0 ? (double)(1.5 * global::System.Math.PI)
                        : (double)(0.5 * global::System.Math.PI), Length);
                }
            }

        }

        //#endif

        #endregion

        #region Swizzles

        /// <summary>
        /// The XX swizzle mask for vector.
        /// </summary>
        public Vector2d XX
        {
            get { return new Vector2d(X, X); }
            set { X = value.Y; }
        }

        /// <summary>
        /// The XY swizzle mask for vector.
        /// </summary>
        public Vector2d XY
        {
            get { return this; }
            set { this = value; }
        }

        /// <summary>
        /// The YX swizzle mask for vector.
        /// </summary>
        public Vector2d YX
        {
            get { return new Vector2d(Y, X); }
            set { this = value.YX; }
        }

        /// <summary>
        /// The YY swizzle mask for vector.
        /// </summary>
        public Vector2d YY
        {
            get { return new Vector2d(Y, Y); }
            set { Y = value.Y; }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Constructor with arguments.
        /// </summary>
        /// <param name="X">The X component.</param>
        /// <param name="Y">The Y component.</param>
        public Vector2d(double X, double Y)
        {
            this.X = X;
            this.Y = Y;
        }

        /// <summary>
        /// CopY constructor.
        /// </summary>
        /// <param name="r">The vector to copY.</param>
        public Vector2d(Vector2d r)
        {
            X = r.X;
            Y = r.Y;
        }

        //#ifdef Sqrt


        /// <summary>
        /// Construction with magnitude anf direction.
        /// </summary>
        /// <param name="magnitude">The magnitude, or length of vector.</param>
        /// <param name="direction">Direction of vector.</param>
        public Vector2d(double magnitude, Vector2d direction)
        {
            this = magnitude * direction.Normal;
        }

        //#endif

        #endregion

        #region IEquatable<Vector2d> Members

        public bool Equals(Vector2d other)
        {
            return this == other;
        }

        #endregion

        #region IComparable<Vector2d> Members

        public int CompareTo(Vector2d other)
        {
            int cmp = X.CompareTo(other.X);
            if (cmp != 0) return cmp;
            return Y.CompareTo(other.Y);
        }

        #endregion

        #region IComparable Members

        public int CompareTo(object obj)
        {
            if (obj.GetType() == this.GetType()) return CompareTo((Vector2d)obj);
            throw new Exception("Cannot compare objects.");
        }

        #endregion

        #region Conversions

        //#ifdef Vector3ClassName


        public static implicit operator Vector3d(Vector2d v)
        {
            return new Vector3d(v.X, v.Y, 0.0);
        }

        //#endif

        //#ifdef Vector4ClassName


        public static implicit operator Vector4d(Vector2d v)
        {
            return new Vector4d(v.X, v.Y, 0.0, 0.0);
        }

        //#endif

        #endregion
    }

#if SHARPMEDIA_TESTSUITE

    [TestSuite]
    internal class Test_Vector2d
    {
        
    }

#endif

}