// This file was generated by TemplateEngine from template source 'Polar'
// using template 'Polarf. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using SharpMedia.Testing;

namespace SharpMedia.Math
{
    /// <summary>
    /// A polar coordinate, represented by an angle and distance.
    /// </summary>
    [Serializable]
    public struct Polarf : IComparable, IComparable<Polarf>, IEquatable<Polarf>
    {
        #region Public Members

        /// <summary>
        /// The angle, in radians.
        /// </summary>
        public float Phi;

        /// <summary>
        /// The length.
        /// </summary>
        public float R;

        #endregion

        #region Static Members

        //#ifdef NearEqual


        /// <summary>
        /// Checks if polars near equal.
        /// </summary>
        /// <param name="p1">The first polar.</param>
        /// <param name="p2">The second polar.</param>
        /// <returns>Do the nearly equal.</returns>
        public static bool NearEqual(Polarf p1, Polarf p2)
        {
            if (!MathHelper.NearEqual(p1.R, p2.R)) return false;
            if (!MathHelper.NearEqual(p1.Phi, p2.Phi)) return false;
            return true;
        }

        /// <summary>
        /// Checks if polars near equal.
        /// </summary>
        /// <param name="p1">The first polar.</param>
        /// <param name="p2">The second polar.</param>
        /// <param name="eps">Epsilon, may difference.</param>
        /// <returns>Do the nearly equal.</returns>
        public static bool NearEqual(Polarf p1, Polarf p2, float eps)
        {
            if (!MathHelper.NearEqual(p1.R, p2.R, eps)) return false;
            if (!MathHelper.NearEqual(p1.Phi, p2.Phi, eps)) return false;
            return true;
        }

        //#endif

        #endregion

        #region Properties

        /// <summary>
        /// The length, the same as R.
        /// </summary>
        public float Length
        {
            get { return R; }
            set { R = value; }
        }

        /// <summary>
        /// A squared length.
        /// </summary>
        public float Length2
        {
            get { return R * R; }
            //#ifdef Sqrt

            set { R = MathHelper.Sqrt(value); }
            //#endif
        }

        //#ifdef Vector2ClassName Cos Sin Atan Sqrt


        /// <summary>
        /// A 2D vector, actually the cartesion coordinate.
        /// </summary>
        public Vector2f Vec2
        {
            get { return Cartesian; }
            set
            {
                Cartesian = value;
            }
        }

        /// <summary>
        /// A two dimensional vector.
        /// </summary>
        public Vector2f Cartesian
        {
            get { return new Vector2f(MathHelper.Cos(Phi) * R, MathHelper.Sin(Phi) * R); }
            set
            {
                R = value.Length;

                // We must also handle "special" X=0 case.
                if (value.X != 0.0f)
                {
                    Phi = MathHelper.ATan(value.Y / value.X);
                }
                else
                {
                    Phi = value.Y < 0.0f ? 
                        (float)(1.5 * global::System.Math.PI) : 
                        (float)(0.5 * global::System.Math.PI);
                }
            }
        }

        //#endif

        #endregion

        #region Operators

        /// <summary>
        /// Compares polars for equality.
        /// </summary>
        /// <param name="p1">The first point.</param>
        /// <param name="p2">The second point.</param>
        /// <returns>Result of operation.</returns>
        public static bool operator ==(Polarf p1, Polarf p2)
        {
            return (p1.Phi == p2.Phi) && (p1.R == p2.R);
        }

        /// <summary>
        /// Compares polars for difference.
        /// </summary>
        /// <param name="p1">The first point.</param>
        /// <param name="p2">The second point.</param>
        /// <returns>Result of operation.</returns>
        public static bool operator !=(Polarf p1, Polarf p2)
        {
            return !(p1 == p2);
        }

        #endregion

        #region Overrides

        /// <summary>
        /// Checks if polard are equal.
        /// </summary>
        /// <param name="obj">The object to compare to.</param>
        /// <returns>Tells if objects are equal.</returns>
        public override bool Equals(object obj)
        {
            if (obj.GetType() == this.GetType()) return (Polarf)obj == this;
            return false;
        }

        /// <summary>
        /// Outputs Polarf.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "(" + (Phi * 180.0 / global::System.Math.PI).ToString()
                + "ï¿½ ," + R.ToString() + ")";
        }

        /// <summary>
        /// Obtains hash code.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Polar construction.
        /// </summary>
        /// <param name="phi">The phi angle.</param>
        /// <param name="r">The r value.</param>
        public Polarf(float phi, float r)
        {
            this.Phi = phi;
            this.R = r;
        }

        #endregion

        #region IEquatable<Polarf> Members

        public bool Equals(Polarf other)
        {
            return this == other;
        }

        #endregion

        #region IComparable<Polarf> Members

        public int CompareTo(Polarf other)
        {
            int cmp = R.CompareTo(other.R);
            if (cmp != 0) return cmp;
            return Phi.CompareTo(other.Phi);
        }

        #endregion

        #region IComparable Members

        public int CompareTo(object obj)
        {
            if (obj.GetType() == this.GetType()) return CompareTo((Polarf)obj);
            return -1;
        }

        #endregion
    }

#if SHARPMEDIA_TESTSUITE

    /// <summary>
    /// A polar coordinate test.
    /// </summary>
    [TestSuite]
    internal class Test_Polarf 
    {

    }
#endif
}
