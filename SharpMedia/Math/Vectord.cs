// This file was generated by TemplateEngine from template source 'Vector'
// using template 'Vectord. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.AspectOriented;
using SharpMedia.Testing;

namespace SharpMedia.Math
{

    /// <summary>
    /// A general implementation of n-dimensional vector.
    /// </summary>
    [Serializable]
    public sealed class Vectord : IEquatable<Vectord>, ICloneable<Vectord>
    {
        #region Private Members
        private double[] components;
        #endregion

        #region Properties

        //#ifdef Sqrt


        /// <summary>
        /// The length of vector.
        /// </summary>
        public double Length
        {
            get { return MathHelper.Sqrt(this * this); }
        }

        //#endif

        /// <summary>
        /// The length of vector squared. It is prefered if you can use Length2 instead od Length.
        /// </summary>
        public double Length2
        {
            get { return this * this; }
        }

        /// <summary>
        /// Obtains components.
        /// </summary>
        public double[] Components
        {
            get { return components; }
        }

        /// <summary>
        /// The number of dimensions in vector.
        /// </summary>
        public uint DimensionCount
        {
            get { return (uint)components.Length; }
        }

        /// <summary>
        /// Indexer on vector.
        /// </summary>
        /// <param name="index">The index, must be smaller then Length.</param>
        /// <returns>The element at that</returns>
        public double this[uint index]
        {
            get { return components[index]; }
            set { components[index] = value; }
        }

        //#ifdef Vector2ClassName


        /// <summary>
        /// Cast to 2D vector, taking all furher dimensions away.
        /// </summary>
        public Vector2d Vector2
        {
            get
            {
                if (components.Length < 2) throw new ArgumentException("Not castable to vector 2D.");
                return new Vector2d(components[0], components[1]);
            }
        }

        //#endif
        //#ifdef Vector3ClassName


        /// <summary>
        /// Cast to 3D vector, taking all furher dimensions away.
        /// </summary>
        public Vector3d Vector3
        {
            get
            {
                if (components.Length < 3) throw new ArgumentException("Not castable to vector 3D.");
                return new Vector3d(components[0], components[1], components[2]);
            }
        }

        //#endif
        //#ifdef Vector4ClassName


        /// <summary>
        /// Cast to 4D vector, taking all furher dimensions away.
        /// </summary>
        public Vector4d Vector4
        {
            get
            {
                if (components.Length < 4) throw new ArgumentException("Not castable to vector 4D.");
                return new Vector4d(components[0], components[1], components[2], components[3]);
            }
        }

        //#endif

        #endregion

        #region Operators

        /// <summary>
        /// The generic vector adition. Vectors must be the same dimension.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Vectors added.</returns>
        public static Vectord operator +([NotNull] Vectord v1, [NotNull] Vectord v2)
        {
            // Precheck.
            if (v1.DimensionCount != v2.DimensionCount)
            {
                throw new ArithmeticException("The vectors are not compatible in size, one is " +
                    v1.ToString() + " and the other is " + v2.ToString());
            }

            // Create result.
            uint size = v1.DimensionCount;
            Vectord result = new Vectord(size);

            for (uint i = 0; i < size; ++i)
            {
                result.components[i] = v1.components[i] + v2.components[i];
            }

            // Return the result.
            return result;
        }

        /// <summary>
        /// The generic vector substraction. Vectors must be the same dimension.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Vectors added.</returns>
        public static Vectord operator -([NotNull] Vectord v1, [NotNull] Vectord v2)
        {
            // Precheck.
            if (v1.DimensionCount != v2.DimensionCount)
            {
                throw new ArithmeticException("The vectors are not compatible in size, one is " +
                    v1.ToString() + " and the other is " + v2.ToString());
            }

            // Create result.
            uint size = v1.DimensionCount;
            Vectord result = new Vectord(size);

            for (uint i = 0; i < size; ++i)
            {
                result.components[i] = v1.components[i] - v2.components[i];
            }

            // Return the result.
            return result;
        }

        /// <summary>
        /// Dot product, defined as a * b = |a| * |b| * cos(phi), where phi is the
        /// angle between vectors.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Scalar result.</returns>
        public static double operator *([NotNull] Vectord v1, [NotNull] Vectord v2)
        {
            // Precheck.
            if (v1.DimensionCount != v2.DimensionCount)
            {
                throw new ArithmeticException("The vectors are not compatible in size, one is " +
                    v1.ToString() + " and the other is " + v2.ToString());
            }

            // Create result.
            uint size = v1.DimensionCount;
            double result = 0.0;

            for (uint i = 0; i < size; ++i)
            {
                result += v1.components[i] * v2.components[i];
            }

            // Return the result.
            return result;
        }


        /// <summary>
        /// Swizzle operation on vector.
        /// </summary>
        /// <param name="mask">The mask may be any length, but indices must not exceed range.
        /// Each element represents the new offset of the element from old vector. The { 0, 2, 1 }
        /// means first element is the offset 0 in this vector, second is the offset 2 and last is
        /// the offset 1.</param>
        /// <returns>Swizzled vector.</returns>
        public Vectord Swizzle([NotNull] uint[] mask)
        {
            uint size = (uint)components.Length;
            double[] array = new double[size];

            for (uint x = 0; x < size; x++)
            {
                uint data = mask[x];
                if (data >= size)
                {
                    throw new ArithmeticException("The swizzle offset of mask out of range, vector is "
                        + ToString() + " and the mask is " + mask.ToString());
                }

                array[x] = components[data];
            }

            return new Vectord(array);
        }

        /// <summary>
        /// Compares two vectors.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Are vectors equal.</returns>
        public static bool operator ==([NotNull] Vectord v1, [NotNull] Vectord v2)
        {
            uint count = v1.DimensionCount;
            if (count != v2.DimensionCount) return false;

            for (uint i = 0; i < count; i++)
            {
                if (v1[i] != v2[i]) return false;
            }
            return true;
        }

        /// <summary>
        /// Compares two vectors.
        /// </summary>
        /// <param name="v1">The first  vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Result of operation.</returns>
        public static bool operator !=([NotNull] Vectord v1, [NotNull] Vectord v2)
        {
            return !(v1 == v2);
        }

        #endregion

        #region Overrides

        public override bool Equals([NotNull] object obj)
        {
            if (obj.GetType() == this.GetType()) return this == (Vectord)obj;
            return false;
        }

        public override string ToString()
        {
            uint dimensionsCount = DimensionCount;
            StringBuilder builder = new StringBuilder("(", (int)dimensionsCount * 2);
            for (uint i = 0; i < (dimensionsCount - 1); i++)
            {
                builder.Append(components[i]);
                builder.Append(",");
            }

            builder.Append(components[dimensionsCount - 1]);
            builder.Append(")");
            return builder.ToString();
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #endregion

        #region Static Members

        //#ifdef NearEqual


        /// <summary>
        /// Near equal.
        /// </summary>
        public static bool NearEqual([NotNull] Vectord v1, [NotNull] Vectord v2)
        {
            if (v1.DimensionCount != v2.DimensionCount) return false;

            for (uint i = 0; i < v1.DimensionCount; i++)
            {
                if (!MathHelper.NearEqual(v1[i], v2[i])) return false;
            }
            return true;
        }

        /// <summary>
        /// Near equal test.
        /// </summary>
        public static bool NearEqual([NotNull] Vectord v1, [NotNull] Vectord v2, double eps)
        {
            if (v1.DimensionCount != v2.DimensionCount) return false;

            for (uint i = 0; i < v1.DimensionCount; i++)
            {
                if (!MathHelper.NearEqual(v1[i], v2[i], eps)) return false;
            }
            return true;
        }

        //#endif

        #endregion

        #region Constructors

        /// <summary>
        /// Constructor with the vector's dimension. All data is left undefined (set to zero).
        /// </summary>
        /// <param name="n">The dimension of vector.</param>
        public Vectord(uint n)
        {
            components = new double[n];
        }

        /// <summary>
        /// Initialisation with actual array.
        /// </summary>
        /// <param name="array">The array of coefficients. The components are not cloned for
        /// performance reasons, so it is possible to change components from outside.</param>
        public Vectord([NotNull] params double[] coef)
        {
            components = coef;
        }

        #endregion

        #region IEquatable<Vectord> Members

        public bool Equals(Vectord other)
        {
            return this == other;
        }

        #endregion

        #region ICloneable<Vectord> Members

        public Vectord Clone()
        {
            return new Vectord(components.Clone() as double[]);
        }

        #endregion
    }

#if SHARPMEDIA_TESTSUITE
    /// <summary>
    /// A vectord test.
    /// </summary>
    [TestSuite]
    internal class Test_Vectord
    {
        protected Vectord v1 = new Vectord((double)0, (double)1, (double)2);
        protected Vectord v2 = new Vectord((double)1, (double)2, (double)3);

        [CorrectnessTest]
        public void Index() 
        {
            Assert.AreEqual(v1[0], (double)0);
            Assert.AreEqual(v1[1], (double)1);
            Assert.AreEqual(v1[2], (double)2); 
        }
        [CorrectnessTest]
        public void Add() { Assert.AreEqual(v1 + v2, new Vectord(new double[] { (double)1, (double)3, (double)5 })); }
        [CorrectnessTest]
        public void Sub() { Assert.AreEqual(v1 - v2, new Vectord(new double[] { (double)-1, (double)-1, (double)-1 })); }
        [CorrectnessTest]
        public void Dot() { Assert.AreEqual(v1 * v2, (double)8); }
    }
#endif
}
