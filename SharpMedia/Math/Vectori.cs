// This file was generated by TemplateEngine from template source 'Vector'
// using template 'Vectori. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.AspectOriented;
using SharpMedia.Testing;

namespace SharpMedia.Math
{

    /// <summary>
    /// A general implementation of n-dimensional vector.
    /// </summary>
    [Serializable]
    public sealed class Vectori : IEquatable<Vectori>, ICloneable<Vectori>
    {
        #region Private Members
        private int[] components;
        #endregion

        #region Properties

        

        /// <summary>
        /// The length of vector squared. It is prefered if you can use Length2 instead od Length.
        /// </summary>
        public int Length2
        {
            get { return this * this; }
        }

        /// <summary>
        /// Obtains components.
        /// </summary>
        public int[] Components
        {
            get { return components; }
        }

        /// <summary>
        /// The number of dimensions in vector.
        /// </summary>
        public uint DimensionCount
        {
            get { return (uint)components.Length; }
        }

        /// <summary>
        /// Indexer on vector.
        /// </summary>
        /// <param name="index">The index, must be smaller then Length.</param>
        /// <returns>The element at that</returns>
        public int this[uint index]
        {
            get { return components[index]; }
            set { components[index] = value; }
        }

        //#ifdef Vector2ClassName


        /// <summary>
        /// Cast to 2D vector, taking all furher dimensions away.
        /// </summary>
        public Vector2i Vector2
        {
            get
            {
                if (components.Length < 2) throw new ArgumentException("Not castable to vector 2D.");
                return new Vector2i(components[0], components[1]);
            }
        }

        //#endif
        //#ifdef Vector3ClassName


        /// <summary>
        /// Cast to 3D vector, taking all furher dimensions away.
        /// </summary>
        public Vector3i Vector3
        {
            get
            {
                if (components.Length < 3) throw new ArgumentException("Not castable to vector 3D.");
                return new Vector3i(components[0], components[1], components[2]);
            }
        }

        //#endif
        //#ifdef Vector4ClassName


        /// <summary>
        /// Cast to 4D vector, taking all furher dimensions away.
        /// </summary>
        public Vector4i Vector4
        {
            get
            {
                if (components.Length < 4) throw new ArgumentException("Not castable to vector 4D.");
                return new Vector4i(components[0], components[1], components[2], components[3]);
            }
        }

        //#endif

        #endregion

        #region Operators

        /// <summary>
        /// The generic vector adition. Vectors must be the same dimension.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Vectors added.</returns>
        public static Vectori operator +([NotNull] Vectori v1, [NotNull] Vectori v2)
        {
            // Precheck.
            if (v1.DimensionCount != v2.DimensionCount)
            {
                throw new ArithmeticException("The vectors are not compatible in size, one is " +
                    v1.ToString() + " and the other is " + v2.ToString());
            }

            // Create result.
            uint size = v1.DimensionCount;
            Vectori result = new Vectori(size);

            for (uint i = 0; i < size; ++i)
            {
                result.components[i] = v1.components[i] + v2.components[i];
            }

            // Return the result.
            return result;
        }

        /// <summary>
        /// The generic vector substraction. Vectors must be the same dimension.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Vectors added.</returns>
        public static Vectori operator -([NotNull] Vectori v1, [NotNull] Vectori v2)
        {
            // Precheck.
            if (v1.DimensionCount != v2.DimensionCount)
            {
                throw new ArithmeticException("The vectors are not compatible in size, one is " +
                    v1.ToString() + " and the other is " + v2.ToString());
            }

            // Create result.
            uint size = v1.DimensionCount;
            Vectori result = new Vectori(size);

            for (uint i = 0; i < size; ++i)
            {
                result.components[i] = v1.components[i] - v2.components[i];
            }

            // Return the result.
            return result;
        }

        /// <summary>
        /// Dot product, defined as a * b = |a| * |b| * cos(phi), where phi is the
        /// angle between vectors.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Scalar result.</returns>
        public static int operator *([NotNull] Vectori v1, [NotNull] Vectori v2)
        {
            // Precheck.
            if (v1.DimensionCount != v2.DimensionCount)
            {
                throw new ArithmeticException("The vectors are not compatible in size, one is " +
                    v1.ToString() + " and the other is " + v2.ToString());
            }

            // Create result.
            uint size = v1.DimensionCount;
            int result = 0;

            for (uint i = 0; i < size; ++i)
            {
                result += v1.components[i] * v2.components[i];
            }

            // Return the result.
            return result;
        }


        /// <summary>
        /// Swizzle operation on vector.
        /// </summary>
        /// <param name="mask">The mask may be any length, but indices must not exceed range.
        /// Each element represents the new offset of the element from old vector. The { 0, 2, 1 }
        /// means first element is the offset 0 in this vector, second is the offset 2 and last is
        /// the offset 1.</param>
        /// <returns>Swizzled vector.</returns>
        public Vectori Swizzle([NotNull] uint[] mask)
        {
            uint size = (uint)components.Length;
            int[] array = new int[size];

            for (uint x = 0; x < size; x++)
            {
                uint data = mask[x];
                if (data >= size)
                {
                    throw new ArithmeticException("The swizzle offset of mask out of range, vector is "
                        + ToString() + " and the mask is " + mask.ToString());
                }

                array[x] = components[data];
            }

            return new Vectori(array);
        }

        /// <summary>
        /// Compares two vectors.
        /// </summary>
        /// <param name="v1">The first vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Are vectors equal.</returns>
        public static bool operator ==([NotNull] Vectori v1, [NotNull] Vectori v2)
        {
            uint count = v1.DimensionCount;
            if (count != v2.DimensionCount) return false;

            for (uint i = 0; i < count; i++)
            {
                if (v1[i] != v2[i]) return false;
            }
            return true;
        }

        /// <summary>
        /// Compares two vectors.
        /// </summary>
        /// <param name="v1">The first  vector.</param>
        /// <param name="v2">The second vector.</param>
        /// <returns>Result of operation.</returns>
        public static bool operator !=([NotNull] Vectori v1, [NotNull] Vectori v2)
        {
            return !(v1 == v2);
        }

        #endregion

        #region Overrides

        public override bool Equals([NotNull] object obj)
        {
            if (obj.GetType() == this.GetType()) return this == (Vectori)obj;
            return false;
        }

        public override string ToString()
        {
            uint dimensionsCount = DimensionCount;
            StringBuilder builder = new StringBuilder("(", (int)dimensionsCount * 2);
            for (uint i = 0; i < (dimensionsCount - 1); i++)
            {
                builder.Append(components[i]);
                builder.Append(",");
            }

            builder.Append(components[dimensionsCount - 1]);
            builder.Append(")");
            return builder.ToString();
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #endregion

        #region Static Members

        

        #endregion

        #region Constructors

        /// <summary>
        /// Constructor with the vector's dimension. All data is left undefined (set to zero).
        /// </summary>
        /// <param name="n">The dimension of vector.</param>
        public Vectori(uint n)
        {
            components = new int[n];
        }

        /// <summary>
        /// Initialisation with actual array.
        /// </summary>
        /// <param name="array">The array of coefficients. The components are not cloned for
        /// performance reasons, so it is possible to change components from outside.</param>
        public Vectori([NotNull] params int[] coef)
        {
            components = coef;
        }

        #endregion

        #region IEquatable<Vectori> Members

        public bool Equals(Vectori other)
        {
            return this == other;
        }

        #endregion

        #region ICloneable<Vectori> Members

        public Vectori Clone()
        {
            return new Vectori(components.Clone() as int[]);
        }

        #endregion
    }

#if SHARPMEDIA_TESTSUITE
    /// <summary>
    /// A vectord test.
    /// </summary>
    [TestSuite]
    internal class Test_Vectori
    {
        protected Vectori v1 = new Vectori((int)0, (int)1, (int)2);
        protected Vectori v2 = new Vectori((int)1, (int)2, (int)3);

        [CorrectnessTest]
        public void Index() 
        {
            Assert.AreEqual(v1[0], (int)0);
            Assert.AreEqual(v1[1], (int)1);
            Assert.AreEqual(v1[2], (int)2); 
        }
        [CorrectnessTest]
        public void Add() { Assert.AreEqual(v1 + v2, new Vectori(new int[] { (int)1, (int)3, (int)5 })); }
        [CorrectnessTest]
        public void Sub() { Assert.AreEqual(v1 - v2, new Vectori(new int[] { (int)-1, (int)-1, (int)-1 })); }
        [CorrectnessTest]
        public void Dot() { Assert.AreEqual(v1 * v2, (int)8); }
    }
#endif
}
