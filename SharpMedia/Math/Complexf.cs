// This file was generated by TemplateEngine from template source 'Complex'
// using template 'Complexf. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;

using SharpMedia.Testing;

namespace SharpMedia.Math
{
    /// <summary>
    /// A float -based complex number.
    /// </summary>
    [Serializable]
    public struct Complexf : IComparable, IComparable<Complexf>, IEquatable<Complexf>
    {
        #region Public Members

        /// <summary>
        /// Real part of complex number.
        /// </summary>
        public float Re;

        /// <summary>
        /// Imagionary part of complex number.
        /// </summary>
        public float Im;

        #endregion

        #region Static Members

        /// <summary>
        /// A zero complex number.
        /// </summary>
        public static Complexf Zero
        {
            get
            {
                return new Complexf(0.0f, 0.0f);
            }
        }

        /// <summary>
        /// A unity complex number.
        /// </summary>
        public static Complexf One
        {
            get
            {
                return new Complexf(1.0f, 0.0f);
            }
        }

        /// <summary>
        /// Converts to the complex array (expands by filling 0.0 as imagionary component).
        /// </summary>
        /// <param name="array">The array.</param>
        /// <returns></returns>
        public static Complexf[] ToComplexArray(params float[] array)
        {
            Complexf[] result = new Complexf[array.Length];
            for (int i = 0; i < array.Length; i++)
            {
                result[i] = new Complexf(array[i], 0.0f);
            }

            return result;
        }

        /// <summary>
        /// Converts to the scalar array by ignoring imagionary components.
        /// </summary>
        /// <param name="array">The array.</param>
        /// <returns></returns>
        public static float[] ToScalarArray(params Complexf[] array)
        {
            float[] result = new float[array.Length];
            for (int i = 0; i < array.Length; i++)
            {
                result[i] = array[i].Re;
            }

            return result;
        }


        //#ifdef NearEqual


        /// <summary>
        /// Are complex numbers nearly equal.
        /// </summary>
        public static bool NearEqual(Complexf c1, Complexf c2, float eps)
        {
            return MathHelper.NearEqual(c1.Re, c2.Re, eps) && MathHelper.NearEqual(c1.Im, c2.Im, eps);
        }

        /// <summary>
        /// Are complex numbers nearly equal.
        /// </summary>
        public static bool NearEqual(Complexf c1, Complexf c2)
        {
            return MathHelper.NearEqual(c1.Re, c2.Re) && MathHelper.NearEqual(c1.Im, c2.Im);
        }

        //#endif

        //#ifdef UniformRandomSupply


        /// <summary>
        /// Unit random complex supply.
        /// </summary>
        public static Complexf UnitRandom
        {
            get
            {
                Complexf cpx = new Complexf((float)MathHelper.UniformRandom(), (float)MathHelper.UniformRandom());
                return cpx.Unit;
            }
        }

        //#endif

        #endregion

        #region Operators

        /// <summary>
        /// Complex multiplication.
        /// </summary>
        /// <param name="c1">The first complex.</param>
        /// <param name="c2">The second complex.</param>
        /// <returns>The result.</returns>
        public static Complexf operator *(Complexf c1, Complexf c2)
        {
            return new Complexf(c1.Re * c2.Re - c1.Im * c2.Im, c1.Re * c2.Im + c1.Im * c2.Re);
        }

        /// <summary>
        /// The complex-scalar multiplication.
        /// </summary>
        /// <param name="c1">The complex.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Complex scaled by f.</returns>
        public static Complexf operator *(Complexf c1, float f)
        {
            return new Complexf(c1.Re * f, c1.Im * f);
        }

        /// <summary>
        /// The complex-scalar multiplication.
        /// </summary>
        /// <param name="c1">The complex.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Complex scaled by f.</returns>
        public static Complexf operator *(float f, Complexf c1)
        {
            return new Complexf(c1.Re * f, c1.Im * f);
        }

        /// <summary>
        /// The complex divided by scalar.
        /// </summary>
        /// <param name="c1">The complex.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Complex scaled by f.</returns>
        public static Complexf operator /(Complexf c1, float f)
        {
            return new Complexf(c1.Re / f, c1.Im / f);
        }

        /// <summary>
        /// Complex division.
        /// </summary>
        public static Complexf operator /(Complexf c1, Complexf c2)
        {
            return (c1 * c2.Conjugate) / (c2.Length2);
        }

        /// <summary>
        /// Complex addition
        /// </summary>
        /// <param name="c1">The first complex.</param>
        /// <param name="c2">The second complex.</param>
        /// <returns>The result.</returns>
        public static Complexf operator +(Complexf c1, Complexf c2)
        {
            return new Complexf(c1.Re + c2.Re, c1.Im + c2.Im);
        }

        /// <summary>
        /// Complex substraction.
        /// </summary>
        /// <param name="c1">The first complex.</param>
        /// <param name="c2">The second complex.</param>
        /// <returns>The result.</returns>
        public static Complexf operator -(Complexf c1, Complexf c2)
        {
            return new Complexf(c1.Re - c2.Re, c1.Im - c2.Im);
        }

        /// <summary>
        /// Checks if complexs are equal.
        /// </summary>
        /// <param name="c1">The first complex.</param>
        /// <param name="c2">The second complex.</param>
        /// <returns></returns>
        public static bool operator ==(Complexf c1, Complexf c2)
        {
            return (c1.Re == c2.Re) && (c1.Im == c2.Im);
        }


        /// <summary>
        /// Checks complexs if they are equal.
        /// </summary>
        /// <param name="c1"></param>
        /// <param name="c2"></param>
        /// <returns></returns>
        public static bool operator !=(Complexf c1, Complexf c2)
        {
            return !(c1 == c2);
        }

        #endregion

        #region Overrides

        /// <summary>
        /// We check if two complex are equal.
        /// </summary>
        /// <param name="obj">The other.</param>
        /// <returns>Compare value.</returns>
        public override bool Equals(object obj)
        {
            if (obj.GetType() == this.GetType()) return this == (Complexf)obj;
            return false;
        }

        /// <summary>
        /// Obtains hash code, based on values.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return Re.GetHashCode() ^ Im.GetHashCode();
        }

        /// <summary>
        /// Converts complex to string.
        /// </summary>
        /// <returns>The complex string.</returns>
        public override string ToString()
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(Re);
            if (Im >= 0.0f)
            {
                builder.Append("+");
            }
            builder.Append(Im);
            builder.Append("i");

            return builder.ToString();
        }

        #endregion

        #region Properties
    
        //#ifdef Vector2ClassName


        /// <summary>
        /// 2D vector, defined as (Re, Im).
        /// </summary>
        public Vector2f Vec2
        {
            set { Re = value.X; Im = value.Y; }
            get { return new Vector2f(Re, Im); }
        }

        //#endif

        /// <summary>
        /// Is complex number real.
        /// </summary>
        public bool IsReal
        {
            get { return Im == 0.0f; }
        }

        /// <summary>
        /// The real part of complex.
        /// </summary>
        [Obsolete]
        public float re
        {
            set { Re = value; }
            get { return Re; }
        }

        /// <summary>
        /// The imagionary part of complex.
        /// </summary>
        [Obsolete]
        public float im
        {
            set { Im = value; }
            get { return Im; }
        }

        /// <summary>
        /// Conversion from quaternion.
        /// </summary>
        public Quaterniond Quaternion
        {
            get
            {
                return new Quaterniond(Re, Im, 0.0f, 0.0f);
            }
        }

        /// <summary>
        /// Conjugate of complex number.
        /// </summary>
        /// <returns>The conjugate.</returns>
        public Complexf Conjugate
        {
            get
            {
                return new Complexf(Re, -Im);
            }
        }

        /// <summary>
        /// A squared distance.
        /// </summary>
        public float Distance2
        {
            get
            {
                return Re * Re + Im * Im;
            }
        }

        /// <summary>
        /// Length of complex number.
        /// </summary>
        public float Length2
        {
            get
            {
                return Re * Re + Im * Im;
            }
        }

        /// <summary>
        /// A unit complex number.
        /// </summary>
        public Complexf Unit
        {
            get
            {
                return this / Distance;
            }
        }

        //#ifdef Sqrt


        /// <summary>
        /// A distance from origin.
        /// </summary>
        public float Distance
        {
            get
            {
                return MathHelper.Sqrt(Distance2);
            }
        }

        /// <summary>
        /// Length of complex vector.
        /// </summary>
        public float Length
        {
            get
            {
                return MathHelper.Sqrt(Length2);
            }
        }

        //#endif

        //#ifdef PolarClassName


        /// <summary>
        /// Returns a polar form of complex number.
        /// </summary>
        public Polarf Polar
        {
            get
            {
                return Vec2.Polar;
            }
        }

        //#endif

        #endregion

        #region Additional operations

        //#ifdef Pow PolarClassName


        /// <summary>
        /// Computes exponent.
        /// </summary>
        /// <param name="f"></param>
        /// <returns></returns>
        public static Complexf Pow(Complexf cmp, float f)
        {
            Polarf polar = cmp.Polar;
            return Pow(polar, f);
        }

        /// <summary>
        /// Computes exponent of already converted complex number in polar form.
        /// </summary>
        /// <param name="polar"></param>
        /// <param name="f"></param>
        /// <returns></returns>
        public static Complexf Pow(Polarf polar, float f)
        {
            return new Complexf(MathHelper.Pow(polar.R, f), polar.Phi * f);
        }

        /// <summary>
        /// A square root of complex number.
        /// </summary>
        /// <param name="cmp"></param>
        /// <returns></returns>
        public Complexf Sqrt(Complexf cmp)
        {
            return Pow(cmp, 1.0f / 2);
        }

        //#endif

        // TODO: interpolations

        #endregion

        #region Constructors

        /// <summary>
        /// Complex constructor.
        /// </summary>
        /// <param name="re">The real component.</param>
        /// <param name="im">The imaginary component.</param>
        public Complexf(float re, float im)
        {
            this.Re = re;
            this.Im = im;
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="cpx"></param>
        public Complexf(Complexf cpx)
        {
            this.Re = cpx.Re;
            this.Im = cpx.Im;
        }

        //#ifdef PolarClassName Cos Sin


        /// <summary>
        /// A polar conversion constructor.
        /// </summary>
        /// <param name="polar"></param>
        public Complexf(Polarf polar)
        {
            this.Re = polar.R * MathHelper.Cos(polar.Phi);
            this.Im = polar.R * MathHelper.Sin(polar.Phi);
        }

        //#endif

        #endregion

        #region IEquatable<Complexf> Members

        public bool Equals(Complexf other)
        {
            return this == other;
        }

        #endregion

        #region IComparable Members

        public int CompareTo(object obj)
        {
            if (obj.GetType() == GetType())
            {
                return CompareTo((Complexf)obj);
            }
            return -1;
        }

        #endregion

        #region IComparable<Complexf> Members

        public int CompareTo(Complexf other)
        {
            int cmp = Re.CompareTo(other.Re);
            if(cmp != 0) return cmp;
            return Im.CompareTo(other.Im);
        }

        #endregion
    }
}
