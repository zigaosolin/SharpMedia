// This file was generated by TemplateEngine from template source 'Matrix2x2'
// using template 'Matrix2x2d. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.Testing;
using SharpMedia.AspectOriented;

namespace SharpMedia.Math.Matrix
{
    /// <summary>
    /// A 2x2 double matrix implementation.
    /// </summary>
    public class Matrix2x2d : IMatrixd<Matrix2x2d, Matrix2x2d>, IEquatable<Matrix2x2d>
    {
        #region Public Members
        public double M00;
        public double M01;
        public double M10;
        public double M11;
        #endregion

        #region Constructors

        /// <summary>
        /// Matrix constructor with all members.
        /// </summary>
        public Matrix2x2d(double m00, double m01,
                          double m10, double m11)
        {
            M00 = m00;
            M01 = m01;
            M10 = m10;
            M11 = m11;
        }


        /// <summary>
        /// Constructor with 
        /// </summary>
        /// <param name="row1"></param>
        /// <param name="row2"></param>
        public Matrix2x2d(Vector2d row1,
                          Vector2d row2)
        {
            M00 = row1.X; M01 = row1.Y;
            M10 = row2.X; M11 = row2.Y;
        }

        /// <summary>
        /// An array based initialization.
        /// </summary>
        /// <param name="array"></param>
        public Matrix2x2d(double[,] array)
        {
            if (array == null) throw new ArgumentNullException("Array must be non null.");
            if (array.GetLength(0) != 2 || array.GetLength(1) != 2) 
                throw new ArgumentException("Array must be 2x2.");

            M00 = array[0, 0];
            M10 = array[1, 0];

            M01 = array[0, 1];
            M11 = array[1, 1];
        }

        #endregion

        #region Row/Column Accessors

        /// <summary>
        /// The first row of matrix.
        /// </summary>
        public Vector2d Row1
        {
            get { return new Vector2d(M00, M01); }
        }

        /// <summary>
        /// The second row of matrix.
        /// </summary>
        public Vector2d Row2
        {
            get { return new Vector2d(M10, M11); }
        }

        /// <summary>
        /// First column.
        /// </summary>
        public Vector2d Column1
        {
            get { return new Vector2d(M00, M10); }
        }

        /// <summary>
        /// First column.
        /// </summary>
        public Vector2d Column2
        {
            get { return new Vector2d(M01, M11); }
        }

        #endregion

        #region Matrix Operators

        /// <summary>
        /// Adds two matrices.
        /// </summary>
        /// <param name="m1">The first matrix.</param>
        /// <param name="m2">The second matrix.</param>
        /// <returns>Result of operation.</returns>
        public static Matrix2x2d operator +(Matrix2x2d m1, Matrix2x2d m2)
        {
            return new Matrix2x2d(m1.M00 + m2.M00, m1.M01 + m2.M01,
                                  m1.M10 + m2.M10, m1.M11 + m2.M11);
        }

        /// <summary>
        /// Substracts two matrices.
        /// </summary>
        /// <param name="m1">The first matrix.</param>
        /// <param name="m2">The second matrix.</param>
        /// <returns>Result of operation.</returns>
        public static Matrix2x2d operator -(Matrix2x2d m1, Matrix2x2d m2)
        {
            return new Matrix2x2d(m1.M00 - m2.M00, m1.M01 - m2.M01,
                                  m1.M10 - m2.M10, m1.M11 - m2.M11);
        }

        /// <summary>
        /// Negates matrix.
        /// </summary>
        /// <param name="m2">The matrix.</param>
        /// <returns>Result of operation.</returns>
        public static Matrix2x2d operator -(Matrix2x2d m2)
        {
            return new Matrix2x2d(-m2.M00, -m2.M01,
                                  -m2.M10, -m2.M11);
        }

        /// <summary>
        /// Multiplies two matrices.
        /// </summary>
        /// <param name="m1">The first matrix.</param>
        /// <param name="m2">The second matrix.</param>
        /// <returns>Result of operation.</returns>
        public static Matrix2x2d operator *(Matrix2x2d m1, Matrix2x2d m2)
        {
            return new Matrix2x2d(m1.M00 * m2.M00 + m1.M01 * m2.M10, m1.M00 * m2.M01 + m1.M01 * m2.M11,
                                  m1.M10 * m2.M00 + m1.M11 * m2.M10, m1.M10 * m2.M01 + m1.M11 * m2.M11);

        }

        /// <summary>
        /// Multiplies by scalar.
        /// </summary>
        /// <param name="m">The matrix.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Matrix multiplied.</returns>
        public static Matrix2x2d operator *(Matrix2x2d m, double f)
        {
            return new Matrix2x2d(m.M00 * f, m.M01 * f,
                                  m.M10 * f, m.M11 * f);
        }

        /// <summary>
        /// Multiplies by scalar.
        /// </summary>
        /// <param name="m">The matrix.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Matrix multiplied.</returns>
        public static Matrix2x2d operator *(double f, Matrix2x2d m)
        {
            return m * f;
        }


        /// <summary>
        /// Division by scalar.
        /// </summary>
        /// <param name="m">The matrix.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Matrix multiplied.</returns>
        public static Matrix2x2d operator /(Matrix2x2d m, double f)
        {
            return m * (1.0 / f);
        }

        /// <summary>
        /// Division of two matrices.
        /// </summary>
        /// <param name="m1"></param>
        /// <param name="m2"></param>
        /// <returns></returns>
        public static Matrix2x2d operator /(Matrix2x2d m1, Matrix2x2d m2)
        {
            return m1 * m2.Inverse;
        }

        /// <summary>
        /// Matrix-column vector multiplication.
        /// </summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The column vector.</param>
        /// <returns>Transformed vector.</returns>
        public static Vector2d operator *(Matrix2x2d m, Vector2d v)
        {
            return new Vector2d(m.M00 * v.X + m.M01 * v.Y,
                                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Matrix-row vector multiplication.
        /// </summary>
        /// <param name="v">The vector.</param>
        /// <param name="m">The matrix.</param>
        /// <returns>Transormed vector.</returns>
        public static Vector2d operator *(Vector2d v, Matrix2x2d m)
        {
            return new Vector2d(v.X * m.M00 + v.Y * m.M10,
                                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Static Members

        /// <summary>
        /// Identity matrix.
        /// </summary>
        public static readonly Matrix2x2d Identity = new Matrix2x2d(1.0, 0.0,
                                                                    0.0, 1.0);

        /// <summary>
        /// Zero matrix.
        /// </summary>
        public static readonly Matrix2x2d Zero = new Matrix2x2d(0.0, 0.0,
                                                                0.0, 0.0);

        //#ifdef NearEqual


        /// <summary>
        /// Matrices are nearly equal; this can be used if numeric errors are acceptable.
        /// </summary>
        /// <param name="other">The other matrix.</param>
        /// <returns>Are nearly equal.</returns>
        public static bool NearEqual(Matrix2x2d t, Matrix2x2d other)
        {
            return MathHelper.NearEqual(t.M00, other.M00) && MathHelper.NearEqual(t.M01, other.M01) &&
                   MathHelper.NearEqual(t.M10, other.M10) && MathHelper.NearEqual(t.M11, other.M11);
        }

        /// <summary>
        /// Matrices are nearly equal; this can be used if numeric errors are acceptable.
        /// </summary>
        /// <param name="other">The other matrix.</param>
        /// <returns>Are nearly equal.</returns>
        public static bool NearEqual(Matrix2x2d t, Matrix2x2d other, double eps)
        {
            return MathHelper.NearEqual(t.M00, other.M00, eps) && MathHelper.NearEqual(t.M01, other.M01, eps) &&
                   MathHelper.NearEqual(t.M10, other.M10, eps) && MathHelper.NearEqual(t.M11, other.M11, eps);
        }

        //#endif

        /// <summary>
        /// Creates a rotational matrix.
        /// </summary>
        /// <param name="angle"></param>
        /// <returns></returns>
        public static Matrix2x2d CreateRotation(double angle)
        {
            double sin, cos;
            MathHelper.SinCos(angle, out sin, out cos);

            return new Matrix2x2d(cos, -sin,
                                  sin, cos);
        }

        /// <summary>
        /// Creates a scale matrix.
        /// </summary>
        /// <param name="scale"></param>
        /// <returns></returns>
        public static Matrix2x2d CreateScale(Vector2d scale)
        {
            return new Matrix2x2d(scale.X, 0,
                                  0, scale.Y);
        }

        #endregion

        #region IEquatable<Matrix2x2d> Members

        public bool Equals(Matrix2x2d other)
        {
            return M00 == other.M00 && M01 == other.M01 &&
                   M10 == other.M10 && M11 == other.M11;
        }

        #endregion

        #region Overrides

        public override bool Equals(object obj)
        {
            if (obj is Matrix2x2d) return this.Equals((Matrix2x2d)obj);
            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            StringBuilder builder = new StringBuilder(3 * 4 + 10);
            builder.Append("( ");
            builder.Append(M00);
            builder.Append(" ,");
            builder.Append(M01);
            builder.Append(" )\n" + "( ");
            builder.Append(M10);
            builder.Append(" ,");
            builder.Append(M11);
            builder.Append(" )");
            return builder.ToString();
        }

        #endregion

        #region IMatrixd<Matrix2x2d,Matrix2x2d> Members

        public double Determinant
        {
            get { return M00 * M11 - M01 * M10; }
        }

        public Matrix2x2d Transpose
        {
            get { return new Matrix2x2d(M00, M01, M10, M11); }
        }

        public double this[uint row, uint column]
        {
            get
            {
                if (row >= 2 || column >= 2) throw new ArgumentException("Invalid index ranges.");
                switch (row * 2 + column)
                {
                    case 0:
                        return M00;
                    case 1:
                        return M01;
                    case 2:
                        return M10;
                    case 3:
                        return M11;
                    default:
                        throw new ArgumentException("Invalid indices");
                }
            }
            set
            {
                if (row >= 2 || column >= 2) throw new ArgumentException("Invalid index ranges.");
                switch (row * 2 + column)
                {
                    case 0:
                        M00 = value;
                        break;
                    case 1:
                        M01 = value;
                        break;
                    case 2:
                        M10 = value;
                        break;
                    case 3:
                        M11 = value;
                        break;
                    default:
                        throw new ArgumentException("Invalid indices");
                }
            }
        }

        public double[,] ArrayForm
        {
            get { return new double[,] { { M00, M01 }, { M10, M11 } }; }
        }

        public DenseMatrixd DenseForm
        {
            get { return new DenseMatrixd(ArrayForm); }
        }

        #endregion

        #region IMatrix<Matrix2x2d> Members

        public Matrix2x2d Inverse
        {
            get
            {
                // Optimized inverse.
                double det = Determinant;
                if (det == 0.0) throw new DivideByZeroException("Matrix is singular.");
                double det_inv = 1.0 / det;
                return new Matrix2x2d(det_inv * M11, -det_inv * M01,
                                      -det_inv * M10, det_inv * M00);
            }
        }

        public uint RowCount
        {
            get { return 2; }
        }

        public uint ColumnCount
        {
            get { return 2; }
        }

        public uint Rank
        {
            get
            {
                // We compute rank of transform.
                return Algorithms.GaussJordan.GetRank(ArrayForm);
            }
        }

        #endregion

        #region ICloneable<Matrix2x2d> Members

        public Matrix2x2d Clone()
        {
            return new Matrix2x2d(M00, M01, M10, M11);
        }

        #endregion

    }

#if SHARPMEDIA_TESTSUITE

    [TestSuite]
    internal class Test_Matrix2x2d
    {
        [CorrectnessTest]
        public void Mul()
        {
            Matrix2x2d m = new Matrix2x2d((double)2.0, (double)3.0,
                                          -1.0, (double)2.0);

            m = m * m;
            Assert.IsTrue(Matrix2x2d.NearEqual(m, 
                new Matrix2x2d(1.0, (double)12, (double)-4, (double)1)));
        }

        [CorrectnessTest]
        public void Inverse()
        {
            Matrix2x2d m = new Matrix2x2d((double)5, (double)2,
                                          1.0, (double)3);

            m = m / m;
            Assert.IsTrue(Matrix2x2d.NearEqual(m, Matrix2x2d.Identity));
        }
    }
#endif
}
