// This file was generated by TemplateEngine from template source 'QuadraticIntegrator'
// using template 'QuadraticIntegratorf. Do not modify this file directly, modify it from template source.

using System;
using System.Collections.Generic;
using System.Text;

namespace SharpMedia.Math.Integration
{

    /// <summary>
    /// A quadratic integrator (1D functions only).
    /// </summary>
    public class QuadraticIntegratorf : IIntegratorf
    {
        #region Private Members
        Functionf func;
        uint refCount = 0;
        float integral = 0.0f;
        float prevIntegral = float.PositiveInfinity;
        Intervalf range;
        #endregion

        #region Constructor

        /// <summary>
        /// Quadratic integrator.
        /// </summary>
        /// <param name="func"></param>
        /// <param name="range"></param>
        public QuadraticIntegratorf(Functionf func, Intervalf range)
        {
            this.func = func;
            this.range = range;
        }

        #endregion

        #region IIntegrator Members

        public uint RefinementCount
        {
            get { return refCount; }
        }

        public bool Refine(uint maxSamples)
        {
            // We perform refinement.
            refCount++;
            float t = integral;

            // Cannot continue with so few samples.
            if (maxSamples / 3 < (1 << (int)refCount)) return false;

            // Special case first step.
            if (refCount == 1)
            {
                integral = (float)0.5 * range.Range * (func(range.A) + func(range.B));
            }
            else
            {
                integral = 0.0f;
                float h = (range.Range / (1 << (int)refCount));
                float b, c, d;
                for (float a = range.A; a < range.B; a += h)
                {
                    // We get the c.
                    c = a + h > range.B ? range.B : a + h;
                    d = (c - a);
                    b = a + d * (float)0.5;

                    // We approximate function on interval by trepezoid.
                    integral += (float)1.0 / (float)3.0 * func(a)
                        + (float)4.0 / (float)3.0 * func(b) + (float)1.0 / (float)3.0 * func(c) * d;
                }
            }

            prevIntegral = t;
            return true;
        }

        public float IntegralApproximation
        {
            get { return integral; }
        }

        public float ErrorEstimate
        {
            get { return prevIntegral - integral; }
        }

        #endregion
    }
}
