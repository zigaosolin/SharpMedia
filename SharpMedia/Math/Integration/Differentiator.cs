// This file was generated by TemplateEngine from template source 'Differentiator'
// using template 'Differentiator. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using SharpMedia.AspectOriented;

namespace SharpMedia.Math.Integration
{
    /// <summary>
    /// Can calculate various order derivates in certain points.
    /// </summary>
    public static class Differentiator
    {
        
		//#foreach instanced to 'Double'


        #region double

        #region Point Differentiation

        /// <summary>
        /// Computes derivate at x0, using order 2 (not very precise).
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="x0">Point where derivate is to be computed.</param>
        /// <returns>Derivate (slope, tangents of angle between axis x and tangent).</returns>
        /// <param name="h">The delta.</param>
        public static double DerivateOrder2([NotNull] Functiond f, double x0, double h)
        {
            return (f(x0 + h) - f(x0 - h)) / ((double)2.0 * h);
        }


        /// <summary>
        /// Computes derivate at x0, using order 4 formulea.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="x0">Point where differentiation is needed.</param>
        /// <returns>Result.</returns>
        /// <param name="h">The delta.</param>
        public static double DerivateOrder4([NotNull] Functiond f, double x0, double h)
        {
            return ((double)8.0 * (f(x0 + h) - f(x0)) 
                    - (f(x0 + (double)2 * h) 
                    - f(x0 - (double)2 * h))) 
                       / ((double)12.0 * h);
        }


        /// <summary>
        /// A derivate of order n calculation. 
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="x0">Actual value where the function is to be differentiated.</param>
        /// <param name="order">Order of differentiation.</param>
        /// <param name="h">Delta for computation.</param>
        /// <returns>Result.</returns>
        public static double Derivate([NotNull] Functiond f, double x0, uint order, double h)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region Function Differentiation

        /// <summary>
        /// Creates a derivate function using samples.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="interval">Interval where to compute derivate.</param>
        /// <param name="samples">Number of samples.</param>
        /// <param name="h">The delta for computation.</param>
        /// <returns>Function, a polynomial in compact compiled form.</returns>
        public static Functiond Derivate([NotNull] Functiond f, Intervald interval, uint samples, double h)
        {
            return null;
        }

        /// <summary>
        /// Creates a derivate function using samples.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="interval">Interval where to compute derivate.</param>
        /// <param name="samples">Number of samples.</param>
        /// <param name="h">The delta for computation.</param>
        /// <returns>Function, a polynomial.</returns>
        public static Functions.Polynomial DerivatePolynomial([NotNull] Functiond f, Intervald interval, uint samples, double h)
        {
            return null;
        }

        /// <summary>
        /// Creates a derivate function using samples.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="interval">Interval where to compute derivate.</param>
        /// <param name="samples">Number of samples.</param>
        /// <param name="h">The delta for computation.</param>
        /// <param name="order">Order of differentiation.</param>
        /// <returns>Function, a polynomial in compact compiled form.</returns>
        public static Functiond DerivatePolynomial([NotNull] Functiond f, 
            Intervald interval, uint samples, uint order, double h)
        {
            return null;
        }

        /// <summary>
        /// Creates a derivate function using samples.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="interval">Interval where to compute derivate.</param>
        /// <param name="samples">Number of samples.</param>
        /// <param name="h">The delta for computation.</param>
        /// <param name="order">Order of differentiation.</param>
        /// <returns>Function, a polynomial.</returns>
        public static Functions.Polynomial Derivate([NotNull] Functiond f, 
            Intervald interval, uint samples, uint order, double h)
        {
            return null;
        }

        #endregion

        #endregion

        //#endfor instanced to 'Double'

		//#foreach instanced to 'Float'


        #region float

        #region Point Differentiation

        /// <summary>
        /// Computes derivate at x0, using order 2 (not very precise).
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="x0">Point where derivate is to be computed.</param>
        /// <returns>Derivate (slope, tangents of angle between axis x and tangent).</returns>
        /// <param name="h">The delta.</param>
        public static float DerivateOrder2([NotNull] Functionf f, float x0, float h)
        {
            return (f(x0 + h) - f(x0 - h)) / ((float)2.0 * h);
        }


        /// <summary>
        /// Computes derivate at x0, using order 4 formulea.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="x0">Point where differentiation is needed.</param>
        /// <returns>Result.</returns>
        /// <param name="h">The delta.</param>
        public static float DerivateOrder4([NotNull] Functionf f, float x0, float h)
        {
            return ((float)8.0 * (f(x0 + h) - f(x0)) 
                    - (f(x0 + (float)2 * h) 
                    - f(x0 - (float)2 * h))) 
                       / ((float)12.0 * h);
        }


        /// <summary>
        /// A derivate of order n calculation. 
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="x0">Actual value where the function is to be differentiated.</param>
        /// <param name="order">Order of differentiation.</param>
        /// <param name="h">Delta for computation.</param>
        /// <returns>Result.</returns>
        public static float Derivate([NotNull] Functionf f, float x0, uint order, float h)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region Function Differentiation

        /// <summary>
        /// Creates a derivate function using samples.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="interval">Interval where to compute derivate.</param>
        /// <param name="samples">Number of samples.</param>
        /// <param name="h">The delta for computation.</param>
        /// <returns>Function, a polynomial in compact compiled form.</returns>
        public static Functionf Derivate([NotNull] Functionf f, Intervalf interval, uint samples, float h)
        {
            return null;
        }

        /// <summary>
        /// Creates a derivate function using samples.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="interval">Interval where to compute derivate.</param>
        /// <param name="samples">Number of samples.</param>
        /// <param name="h">The delta for computation.</param>
        /// <returns>Function, a polynomial.</returns>
        public static Functions.Polynomial DerivatePolynomial([NotNull] Functionf f, Intervalf interval, uint samples, float h)
        {
            return null;
        }

        /// <summary>
        /// Creates a derivate function using samples.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="interval">Interval where to compute derivate.</param>
        /// <param name="samples">Number of samples.</param>
        /// <param name="h">The delta for computation.</param>
        /// <param name="order">Order of differentiation.</param>
        /// <returns>Function, a polynomial in compact compiled form.</returns>
        public static Functionf DerivatePolynomial([NotNull] Functionf f, 
            Intervalf interval, uint samples, uint order, float h)
        {
            return null;
        }

        /// <summary>
        /// Creates a derivate function using samples.
        /// </summary>
        /// <param name="f">The function.</param>
        /// <param name="interval">Interval where to compute derivate.</param>
        /// <param name="samples">Number of samples.</param>
        /// <param name="h">The delta for computation.</param>
        /// <param name="order">Order of differentiation.</param>
        /// <returns>Function, a polynomial.</returns>
        public static Functions.Polynomial Derivate([NotNull] Functionf f, 
            Intervalf interval, uint samples, uint order, float h)
        {
            return null;
        }

        #endregion

        #endregion

        //#endfor instanced to 'Float'


    }
}
