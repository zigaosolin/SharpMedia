// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Reflection.Emit;
using SharpMedia.AspectOriented;

namespace SharpMedia.Math
{
    public partial class Expression
    {

        #region Direct Eval

        /// <summary>
        /// Evaluates constant expression
        /// </summary>
        /// <returns></returns>
        public double Evald([NotNull] FunctionParams pars, FunctionSet set, Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 0) throw new ArgumentException("Too many variables are used for constant function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;
                if (pars == null) throw new ArgumentNullException("The parameters of function are null.");

                // We define method. 

                DynamicMethod method = new DynamicMethod(name + "d", typeof(double), new Type[] {  }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateDouble(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return ((ConstFunctiond)method.CreateDelegate(typeof(ConstFunctiond)))();
            }
        }

        /// <summary>
        /// Evaluates constant expression
        /// </summary>
        /// <returns></returns>
        public double Evalf([NotNull] FunctionParams pars, FunctionSet set, Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 0) throw new ArgumentException("Too many variables are used for constant function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;
                if (pars == null) throw new ArgumentNullException("The parameters of function are null.");

                // We define method. 

                DynamicMethod method = new DynamicMethod(name + "f", typeof(float), new Type[] { }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateSingle(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return ((ConstFunctionf)method.CreateDelegate(typeof(ConstFunctionf)))();
            }
        }

        #endregion

        #region Function (1/1/F)


        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="m">The module we should append this delegate to.</param>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Functionf GetFunctionf([NotNull] FunctionParams pars, FunctionSet set, Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 1) throw new ArgumentException("Too many variables are used for 1D function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;
                if (pars == null) throw new ArgumentNullException("The parameters of function are null.");

                // We define method. 

                DynamicMethod method = new DynamicMethod(name + "f", typeof(float), new Type[] { typeof(float) }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateSingle(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return (Functionf)method.CreateDelegate(typeof(Functionf));
            }
        }

        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Functionf GetFunctionf(FunctionParams p, FunctionSet set)
        {
            return GetFunctionf(p, set, typeof(Expression).Module);
        }

        #endregion

        #region Function (1/1/D)

        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="m">The module we should append this delegate to.</param>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Functiond GetFunctiond([NotNull] FunctionParams pars, FunctionSet set, [NotNull] Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 1) throw new ArgumentException("Too many variables are used for 1D function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;

                // We define method. 
                DynamicMethod method = new DynamicMethod(name + "d", typeof(double), new Type[] { typeof(double) }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateDouble(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return (Functiond)method.CreateDelegate(typeof(Functiond));
            }
        }

        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Functiond GetFunctiond(FunctionParams p, FunctionSet set)
        {
            return GetFunctiond(p, set, typeof(Expression).Module);
        }

        #endregion

        #region Function (1/2/F)


        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="m">The module we should append this delegate to.</param>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function2f GetFunction2f([NotNull] FunctionParams pars, FunctionSet set, [NotNull] Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 2) throw new ArgumentException("Too many variables are used for 2D function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;
                if (pars == null) throw new ArgumentNullException("The parameters of function are null.");

                // We define method. 
                DynamicMethod method = new DynamicMethod(name + "2f", typeof(float), new Type[] { typeof(float), typeof(float) }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateSingle(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return (Function2f)method.CreateDelegate(typeof(Function2f));
            }
        }

        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function2f GetFunction2f(FunctionParams p, FunctionSet set)
        {
            return GetFunction2f(p, set, typeof(Expression).Module);
        }

        #endregion

        #region Function (1/2/D)

        /// <summary>
        /// Obtains floating point function (64-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="m">The module we should append this delegate to.</param>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function2d GetFunction2d([NotNull] FunctionParams pars, FunctionSet set, [NotNull] Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 2) throw new ArgumentException("Too many variables are used for 2D function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;

                // We define method. 
                DynamicMethod method = new DynamicMethod(name + "2d", typeof(double), new Type[] { typeof(double), typeof(double) }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateDouble(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return (Function2d)method.CreateDelegate(typeof(Function2d));
            }
        }

        /// <summary>
        /// Obtains floating point function (64-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function2d GetFunction2d(FunctionParams p, FunctionSet set)
        {
            return GetFunction2d(p, set, typeof(Expression).Module);
        }

        #endregion

        #region Function (1/3/F)


        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="m">The module we should append this delegate to.</param>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function3f GetFunction3f([NotNull] FunctionParams pars, FunctionSet set, [NotNull] Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 3) throw new ArgumentException("Too many variables are used for 3D function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;
                if (pars == null) throw new ArgumentNullException("The parameters of function are null.");

                // We define method. 
                DynamicMethod method = new DynamicMethod(name + "3f", typeof(float), new Type[] { typeof(float), 
                    typeof(float), typeof(float) }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateSingle(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return (Function3f)method.CreateDelegate(typeof(Function3f));
            }
        }

        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function3f GetFunction3f(FunctionParams p, FunctionSet set)
        {
            return GetFunction3f(p, set, typeof(Expression).Module);
        }

        #endregion

        #region Function (1/3/D)

        /// <summary>
        /// Obtains floating point function (64-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="m">The module we should append this delegate to.</param>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function3d GetFunction3d([NotNull] FunctionParams pars, FunctionSet set, [NotNull] Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 3) throw new ArgumentException("Too many variables are used for 3D function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;

                // We define method. 
                DynamicMethod method = new DynamicMethod(name + "3d", typeof(double), new Type[] { typeof(double), 
                    typeof(double), typeof(double) }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateDouble(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return (Function3d)method.CreateDelegate(typeof(Function3d));
            }
        }

        /// <summary>
        /// Obtains floating point function (64-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function3d GetFunction3d(FunctionParams p, FunctionSet set)
        {
            return GetFunction3d(p, set, typeof(Expression).Module);
        }

        #endregion

        #region Function (1/4/F)


        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="m">The module we should append this delegate to.</param>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function4f GetFunction4f([NotNull] FunctionParams pars, FunctionSet set, [NotNull] Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 4) throw new ArgumentException("Too many variables are used for 3D function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;
                if (pars == null) throw new ArgumentNullException("The parameters of function are null.");

                // We define method. 
                DynamicMethod method = new DynamicMethod(name + "4f", typeof(float), new Type[] { typeof(float), typeof(float), 
                    typeof(float), typeof(float) }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateSingle(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return (Function4f)method.CreateDelegate(typeof(Function4f));
            }
        }

        /// <summary>
        /// Obtains floating point function (32-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function4f GetFunction4f(FunctionParams p, FunctionSet set)
        {
            return GetFunction4f(p, set, typeof(Expression).Module);
        }

        #endregion

        #region Function (1/4/D)

        /// <summary>
        /// Obtains floating point function (64-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="m">The module we should append this delegate to.</param>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function4d GetFunction4d([NotNull] FunctionParams pars, FunctionSet set, [NotNull] Module m)
        {
            if (pars.Creator != this) throw new ArgumentException("Parameters not generated by expression.");
            if (!pars.IsDefined) throw new ArgumentException("The parameters for the function are not defined fully.");
            if (pars.VariableCount > 4) throw new ArgumentException("Too many variables are used for 4D function.");
            lock (root)
            {
                if (set == null) set = FunctionSet.Default;

                // We define method. 
                DynamicMethod method = new DynamicMethod(name + "4d", typeof(double), new Type[] { typeof(double), typeof(double),
                    typeof(double), typeof(double) }, m);

                // We emit body.
                ILGenerator g = method.GetILGenerator();
                root.GenerateDouble(g, set, pars);
                g.Emit(OpCodes.Ret);

                // We create delegate.
                return (Function4d)method.CreateDelegate(typeof(Function4d));
            }
        }

        /// <summary>
        /// Obtains floating point function (64-bit). If expression is in vector form,
        /// this will return the function defined for x.
        /// </summary>
        /// <param name="set">The function set, use null or FunctionSet.Default if you do not
        /// want anything specific.</param>
        /// <param name="pars">The parameters, cannot be null.</param>
        public Function4d GetFunction4d(FunctionParams p, FunctionSet set)
        {
            return GetFunction4d(p, set, typeof(Expression).Module);
        }

        #endregion
    }
}
