// This file was generated by TemplateEngine from template source 'Quaternion'
// using template 'Quaternionf. Do not modify this file directly, modify it from template source.

// This file constitutes a part of the SharpMedia project, (c) 2007 by the SharpMedia team
// and is licensed for your use under the conditions of the NDA or other legally binding contract
// that you or a legal entity you represent has signed with the SharpMedia team.
// In an event that you have received or obtained this file without such legally binding contract
// in place, you MUST destroy all files and other content to which this lincese applies and
// contact the SharpMedia team for further instructions at the internet mail address:
//
//    legal@sharpmedia.com
//
using System;
using System.Text;
using SharpMedia.Math.Matrix;
using SharpMedia.Testing;

namespace SharpMedia.Math
{
    /// <summary>
    /// Quaternion is a class that can be used to represent rotations and
    /// scaling. It is actually a hyper complex number with one real and
    /// three imagionary coefficients.
    /// </summary>
    [Serializable]
    public struct Quaternionf : IEquatable<Quaternionf>, IComparable, IComparable<Quaternionf>
    {
        #region Public Members

        /// <summary>
        /// Real part of quaternion.
        /// </summary>
        public float Re;

        /// <summary>
        /// Imagionary part of quaternion.
        /// </summary>
        public Vector3f Im;

        #endregion

        #region Properties

        //#ifdef Vector3ClassName


        /// <summary>
        /// Is quaternion real (no imagionary part).
        /// </summary>
        public bool IsReal
        {
            get { return Im == Vector3f.Zero; }
        }

        //#endif

        /// <summary>
        /// The first imagionary part.
        /// </summary>
        public float Im1
        {
            get { return Im.X; }
            set { Im.X = value; }
        }

        /// <summary>
        /// The second imagionary part.
        /// </summary>
        public float Im2
        {
            get { return Im.Y; }
            set { Im.Y = value; }
        }

        /// <summary>
        /// The third imagionary part.
        /// </summary>
        public float Im3
        {
            get { return Im.Z; }
            set { Im.Z = value; }
        }

        /// <summary>
        /// The length squared of quaternion.
        /// </summary>
        public float Length2
        {
            get { return Re * Re + Im * Im; }
        }

        //#ifdef Sqrt


        /// <summary>
        /// Length of quaternion.
        /// </summary>
        public float Length
        {
            get { return MathHelper.Sqrt(Re * Re + Im * Im); }
        }

        /// <summary>
        /// The normal of quaternion.
        /// </summary>
        public Quaternionf Normal
        {
            get
            {
                return this / Length;
            }
        }

        //#endif

        //#ifdef NearEqual


        /// <summary>
        /// Checks if quaternion is normalized.
        /// </summary>
        public bool IsNormalized
        {
            get { return MathHelper.NearEqual(Length2, 1.0f); }
        }

        //#endif

        /// <summary>
        /// The element accessor.
        /// </summary>
        public float this[uint index]
        {
            get
            {
                switch (index)
                {
                    case 0: return Re;
                    case 1: return Im1;
                    case 2: return Im2;
                    case 3: return Im3;
                    default: throw new ArgumentException("Invalid index accessor.");
                }
            }
            set
            {
                switch (index)
                {
                    case 0: Re = value; break;
                    case 1: Im1 = value; break;
                    case 2: Im2 = value; break;
                    case 3: Im3 = value; break;
                    default: throw new ArgumentException("Invalid index accessor.");
                }
            }
        }

        /// <summary>
        /// Conjugate of quaterion.
        /// </summary>
        public Quaternionf Conjugate
        {
            get
            {
                return new Quaternionf(Re, -Im);
            }
        }

        /// <summary>
        /// Inverse of quaternion.
        /// </summary>
        public Quaternionf Inverse
        {
            get
            {
                return Conjugate / Length2;
            }
        }

        /// <summary>
        /// Inverse if quaternion is normalized.
        /// </summary>
        public Quaternionf NormInverse
        {
            get
            {
                return Conjugate;
            }
        }

        /// <summary>
        /// Exponent of quaternion.
        /// </summary>
        public Quaternionf Exp
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        /// <summary>
        /// Logarithm of quaternion.
        /// </summary>
        public Quaternionf Log
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        //#ifdef Atan


        /// <summary>
        /// Roll represented by quaternion.
        /// </summary>
        public float Roll
        {
            get
            {
                return MathHelper.ATan(
                    2 * (Im.X * Im.Y + Re * Im.Z),
                    Re * Re + Im.X * Im.X - Im.Y * Im.Y - Im.Z * Im.Z);
            }
        }

        /// <summary>
        /// Pitch represented by quaternion.
        /// </summary>
        public float Pitch
        {
            get
            {
                return MathHelper.ATan(
                    2 * (Im.Y * Im.Z + Re * Im.X),
                    Re * Re - Im.X * Im.X - Im.Y * Im.Y + Im.Z * Im.Z);
            }
        }

        //#endif

        //#ifdef Asin


        /// <summary>
        /// Yaw represented by quaternion.
        /// </summary>
        public float Yaw
        {
            get
            {
                return MathHelper.ASin((-2 * (Im.X * Im.Z - Re * Im.Y)));
            }
        }

        //#endif

        //#ifdef Vector3ClassName


        /// <summary>
        /// The X axis of quaternion.
        /// </summary>
        public Vector3f AxisX
        {
            get
            {
                float fTy = 2 * Im.Y;
                float fTz = 2 * Im.Z;
                float fTwy = fTy * Re;
                float fTwz = fTz * Re;
                float fTxy = fTy * Im.X;
                float fTxz = fTz * Im.X;
                float fTyy = fTy * Im.Y;
                float fTzz = fTz * Im.Z;

                return new Vector3f(1.0f - (fTyy + fTzz), fTxy + fTwz, fTxz - fTwy);
            }
        }

        /// <summary>
        /// The Y axis of quaternion.
        /// </summary>
        public Vector3f AxisY
        {
            get
            {
                float fTx = 2 * Im.X;
                float fTy = 2 * Im.Y;
                float fTz = 2 * Im.Z;
                float fTwx = fTx * Re;
                float fTwz = fTz * Re;
                float fTxx = fTx * Im.X;
                float fTxy = fTy * Im.X;
                float fTyz = fTz * Im.Y;
                float fTzz = fTz * Im.Z;

                return new Vector3f(fTxy - fTwz, 1.0f - (fTxx + fTzz), fTyz + fTwx);
            }
        }

        /// <summary>
        /// The Z axis of quaternion.
        /// </summary>
        public Vector3f AxisZ
        {
            get
            {
                float fTx = 2 * Im.X;
                float fTy = 2 * Im.Y;
                float fTz = 2 * Im.Z;
                float fTwx = fTx * Re;
                float fTwy = fTy * Re;
                float fTxx = fTx * Im.X;
                float fTxz = fTz * Im.X;
                float fTyy = fTy * Im.Y;
                float fTyz = fTz * Im.Y;

                return new Vector3f(fTxz + fTwy, fTyz - fTwx, 1.0f - (fTxx + fTyy));
            }
        }

        //#endif

        #endregion

        #region Overrides

        public override bool Equals(object obj)
        {
            if (obj is Quaternionf)
            {
                return this == (Quaternionf)obj;
            }
            return false;
        }

        public override string ToString()
        {
            StringBuilder builder = new StringBuilder(4 * 3 + 8);
            builder.Append("( ");
            builder.Append(Re);
            builder.Append(", ");
            builder.Append(Im.X);
            builder.Append(", ");
            builder.Append(Im.Y);
            builder.Append(", ");
            builder.Append(Im.Z);
            builder.Append(")");
            return builder.ToString();
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #endregion

        #region Constants

        /// <summary>
        /// A zero quaternion.
        /// </summary>
        public static Quaternionf Zero
        {
            get
            {
                return new Quaternionf(0.0f, 0.0f, 0.0f, 0.0f);
            }
        }

        /// <summary>
        /// A multiplication identity.
        /// </summary>
        public static Quaternionf Identity
        {
            get
            {
                return new Quaternionf(1.0f, 0.0f, 0.0f, 0.0f);
            }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Real part and imagionary part vector constructor.
        /// </summary>
        /// <param name="r">The real part.</param>
        /// <param name="i">The imagionary part.</param>
        public Quaternionf(float r, Vector3f i)
        {
            Re = r;
            Im = i;
        }

        /// <summary>
        /// Real part and imagionary part vector constructor.
        /// </summary>
        /// <param name="r">The real part.</param>
        /// <param name="i">The imagionary part.</param>
        public Quaternionf(float r, float i1, float i2, float i3)
        {
            Re = r;
            Im = new Vector3f(i1, i2, i3);
        }

        #endregion

        #region Static Members

        //#ifdef Sqrt Matrix3x3ClassName


        /// <summary>
        /// Converts quaterion from 3x3 rotational matrix.
        /// </summary>
        /// <param name="m">The matrix.</param>
        /// <returns>The quaternion representing rotations of 3x3 matrix.</returns>
        public static Quaternionf FromMatrix(Matrix3x3f m)
        {
            float m00 = m[0, 0];
            float m11 = m[1, 1];
            float m22 = m[2, 2];
            float T = 4 * (1.0f - m00 * m00 - m11 * m11 - m22 * m22);

            if (T > 0.0f)
            {
                float S = (float)0.5 / MathHelper.Sqrt(T);

                return new Quaternionf((float)0.25 / S,
                    (m[2, 1] - m[1, 2]) * S,
                    (m[0, 2] - m[2, 0]) * S,
                    (m[1, 0] - m[0, 1]) * S);
            }
            else
            {
                if (m00 > m11 && m00 > m22)
                {
                    float S = (float)2.0 * MathHelper.Sqrt(1.0f + m00 - m11 - m22);
                    float S_inv = 1.0f / S;
                    return new Quaternionf(
                        (m[1, 2] + m[2, 1]) * S_inv,
                        (float)0.5 * S_inv,
                        (m[0, 1] + m[1, 0]) * S_inv,
                        (m[0, 2] + m[2, 0]) * S_inv);


                }
                else if (m11 > m00 && m11 > m22)
                {
                    float S = (float)2.0 * MathHelper.Sqrt(1.0f + m11 - m00 - m22);
                    float S_inv = 1.0f / S;

                    return new Quaternionf(
                        (m[0, 2] + m[2, 0]) * S_inv,
                        (m[0, 1] + m[1, 0]) * S_inv,
                        (float)0.5 * S_inv,
                        (m[1, 2] + m[2, 1]) * S_inv);
                }
                else
                {
                    float S = (float)2.0 * MathHelper.Sqrt(1.0f + m22 - m00 - m11);
                    float S_inv = 1.0f / S;

                    return new Quaternionf(
                        (m[0, 1] + m[1, 0]) * S_inv,
                        (m[0, 2] + m[2, 0]) * S_inv,
                        (m[1, 2] + m[2, 1]) * S_inv,
                        (float)0.5 * S_inv);
                }
            }
        }

        //#endif

        //#ifdef Sqrt Sin


        /// <summary>
        /// Constructs quaterion from axis and angle.
        /// </summary>
        /// <param name="axis">The axis.</param>
        /// <param name="angle">The angle around axis.</param>
        /// <returns>Quaternion representing transform.</returns>
        public static Quaternionf FromAxis(Vector3f axis, float angle)
        {
            float sin = MathHelper.Sin(angle * (float)0.5);
            float cos = MathHelper.Sqrt(1.0f - sin * sin);

            return (new Quaternionf(cos, axis * sin)).Normal;
        }

        //#endif

        //#ifdef Matrix3x3ClassName


        /// <summary>
        /// Conversion of quaternion to matrix.
        /// </summary>
        /// <returns>Immutable converted matrix.</returns>
        public Matrix3x3f ToMatrix()
        {
            Vector3f im_2 = Vector3f.ComponentMultiply(Im, Im);

            return new Matrix3x3f(
                1.0f - 2 * (im_2.Y + im_2.Z), 2 * (Im.X * Im.Y - Im.Z * Re), 2 * (Im.X * Im.Z + Im.Y * Re),
                2 * (Im.X * Im.Y + Im.Z * Re), 1.0f - 2 * (im_2.X + im_2.Z), 2 * (Im.Y * Im.Z - Im.X * Re),
                2 * (Im.X * Im.Z - Im.Y * Re), 2 * (Im.Y * Im.Z + Im.Y * Re), 1.0f - 2 * (im_2.X + im_2.Y));
        }

        //#endif

        //#ifdef Acos Sqrt


        /// <summary>
        /// Conversion of quaternion to axis and angle.
        /// </summary>
        /// <param name="angle">The angle in radians.</param>
        /// <param name="axis">The axis.</param>
        public void ToAxisAngle(out float angle, out Vector3f axis)
        {
            // We calculate the imagionary length, just to make sure
            // to handle special case (0,0,0,0)
            float l2 = Im * Im;
            if (l2 > 0.0f)
            {
                angle = 2 * MathHelper.ACos(Re);
                float l_inv = 1.0f / MathHelper.Sqrt(l2);
                axis = Im * l_inv;
            }
            else
            {
                // Any axis is ok.
                angle = 0;
                axis = Vector3f.AxisX;
            }
        }

        //#endif

        //#ifdef NearEqual


        /// <summary>
        /// Are vectors nearly equal.
        /// </summary>
        /// <param name="q1">The quaternion to compare.</param>
        /// <param name="q2">The other quaternion.</param>
        public static bool NearEqual(Quaternionf q1, Quaternionf q2)
        {
            return MathHelper.NearEqual(q2.Re, q1.Re)
                   && Vector3f.NearEqual(q1.Im, q2.Im);

        }

        /// <summary>
        /// Are vectors nearly equal.
        /// </summary>
        /// <param name="q1">The quaternion to compare.</param>
        /// <param name="q2">The other quaternion.</param>
        /// <param name="eps">Maximum difference.</param>
        public static bool NearEqual(Quaternionf q1, Quaternionf q2, float eps)
        {
            return MathHelper.NearEqual(q2.Re, q1.Re, eps)
                   && Vector3f.NearEqual(q1.Im, q2.Im, eps);

        }

        //#endif


        #endregion

        #region Operations

        /// <summary>
        /// Are quaternions equal.
        /// </summary>
        public static bool operator ==(Quaternionf q1, Quaternionf q2)
        {
            return q1.Re == q2.Re && q1.Im == q2.Im;
        }

        /// <summary>
        /// Are quaternions not equal.
        /// </summary>
        public static bool operator !=(Quaternionf q1, Quaternionf q2)
        {
            return !(q1 == q2);
        }

        /// <summary>
        /// Quaternion added to real.
        /// </summary>
        public static Quaternionf operator +(Quaternionf q, float r)
        {
            return new Quaternionf(q.Re + r, q.Im);
        }

        /// <summary>
        /// Quaternion added to real.
        /// </summary>
        public static Quaternionf operator +(float r, Quaternionf q)
        {
            return q + r;
        }

        //#ifdef ComplexClassName


        /// <summary>
        /// Quaternion added to complex.
        /// </summary>
        /// <param name="q">The quaternion.</param>
        /// <param name="c">The complex.</param>
        /// <returns>Quaternion result.</returns>
        public static Quaternionf operator +(Quaternionf q, Complexf c)
        {
            return new Quaternionf(q.Re + c.Re, q.Im1 + c.Im, q.Im2, q.Im3);
        }

        /// <summary>
        /// Quaternion added to complex.
        /// </summary>
        /// <param name="q">The quaternion.</param>
        /// <param name="c">The complex.</param>
        /// <returns>Quaternion result.</returns>
        public static Quaternionf operator +(Complexf c, Quaternionf q)
        {
            return new Quaternionf(q.Re + c.Re, q.Im1 + c.Im, q.Im2, q.Im3);
        }

        //#endif

        /// <summary>
        /// Adds two quaternions.
        /// </summary>
        /// <param name="q1">First quaterion.</param>
        /// <param name="q2">Second quaterion.</param>
        /// <returns></returns>
        public static Quaternionf operator +(Quaternionf q1, Quaternionf q2)
        {
            return new Quaternionf(q1.Re + q2.Re, q1.Im + q2.Im);
        }

        /// <summary>
        /// Quaternion substracted by real.
        /// </summary>
        public static Quaternionf operator -(Quaternionf q, float r)
        {
            return new Quaternionf(q.Re - r, q.Im);
        }

        //#ifdef ComplexClassName


        /// <summary>
        /// Quaternion substracted by complex.
        /// </summary>
        /// <param name="q">The quaternion.</param>
        /// <param name="c">The complex.</param>
        /// <returns>Quaternion result.</returns>
        public static Quaternionf operator -(Quaternionf q, Complexf c)
        {
            return new Quaternionf(q.Re - c.Re, q.Im1 - c.Im, q.Im2, q.Im3);
        }

        //#endif

        /// <summary>
        /// Substracts two quaternions.
        /// </summary>
        /// <param name="q1">First quaterion.</param>
        /// <param name="q2">Second quaterion.</param>
        /// <returns></returns>
        public static Quaternionf operator -(Quaternionf q1, Quaternionf q2)
        {
            return new Quaternionf(q1.Re - q2.Re, q1.Im - q2.Im);
        }

        /// <summary>
        /// Multiplication by scalar.
        /// </summary>
        /// <param name="q">The quaternions.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Quaternion scaled.</returns>
        public static Quaternionf operator *(Quaternionf q, float f)
        {
            return new Quaternionf(q.Re * f, q.Im * f);
        }

        /// <summary>
        /// Multiplication by scalar.
        /// </summary>
        /// <param name="q">The quaternions.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Quaternion scaled.</returns>
        public static Quaternionf operator *(float f, Quaternionf q)
        {
            return q * f;
        }

        /// <summary>
        /// Division by scalar.
        /// </summary>
        /// <param name="q">The quaternions.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>Quaternion scaled.</returns>
        public static Quaternionf operator /(Quaternionf q, float f)
        {
            return q * (1.0f / f);
        }

        /// <summary>
        /// Quaternion multiplication.
        /// </summary>
        /// <param name="q1">The first quaternion.</param>
        /// <param name="q2">The second quaternion.</param>
        /// <returns>Resulting quaterion.</returns>
        public static Quaternionf operator *(Quaternionf q1, Quaternionf q2)
        {
            Vector3f d1 = q2.Re * q1.Im;
            Vector3f d2 = q1.Re * q2.Im;
            Vector3f d3 = q1.Im ^ q2.Im;

            return new Quaternionf(q1.Re * q2.Re - q1.Im * q2.Im,
                 d1 + d2 + d3);
        }

        /// <summary>
        /// Quaternion division. If quaternions aRe unit, use q1*q2.Conjugate because
        /// it is faster.
        /// </summary>
        /// <param name="q1">The first quaternion.</param>
        /// <param name="q2">The second quaternion.</param>
        /// <returns></returns>
        public static Quaternionf operator /(Quaternionf q1, Quaternionf q2)
        {
            return q1 * q2.Inverse;
        }

        /// <summary>
        /// Transforms vector as quaternion.
        /// </summary>
        /// <param name="q1">The quaternion</param>
        /// <param name="v">Vector, treatet as quaternion with real component of 0.0f
        /// and imaginary component of vector.</param>
        /// <returns>Transformed vector</returns>
        public static Vector3f operator *(Quaternionf q1, Vector3f v)
        {
            // Transformation of vector.
            Vector3f uv, uuv;
            uv = q1.Im ^ v;
            uuv = q1.Im ^ uv;
            uv *= (2 * q1.Re);
            uuv *= 2;

            return v + uv + uuv;
        }


        #endregion

        #region Interpolations

        /// <summary>
        /// Spherical interpolation between two quaternions. Both must be unit quaternions.
        /// </summary>
        /// <param name="q1">The first quaternion.</param>
        /// <param name="q2">The seconst quaternion.</param>
        /// <param name="t">The weighting factor, in range [0,1].</param>
        /// <returns>Interpolated quaternion.</returns>
        public static Quaternionf Slerp(Quaternionf q1, Quaternionf q2, float t)
        {
            // We always want the shortest path.
            throw new NotImplementedException();
        }

        /// <summary>
        /// A linear interpolation. May be a bit jerky.
        /// </summary>
        /// <param name="q1">The first quaternion.</param>
        /// <param name="q2">The second quaternion.</param>
        /// <param name="t">The path between them.</param>
        /// <returns>Quaternion in between.</returns>
        public static Quaternionf Linear(Quaternionf q1, Quaternionf q2, float t)
        {
            return (q1 * (1.0f - t) + q2 * t).Normal;
        }

        /// <summary>
        /// A cubic interpolation, using 4 rotation weights.
        /// </summary>
        /// <param name="q1">The first quaternion (t=0).</param>
        /// <param name="q2">The second quaternion (t=0.33).</param>
        /// <param name="q3">The third quaternion (t=0.66).</param>
        /// <param name="q4">The last quaternion (t=1.0f).</param>
        /// <param name="t">Position, in range [0,1].</param>
        /// <returns>Quaternion matching orientation.</returns>
        public static Quaternionf Cubic(Quaternionf q1, Quaternionf q2, Quaternionf q3, Quaternionf q4, float t)
        {
            throw new NotImplementedException();
        }


        #endregion

        #region IEquatable<Quaternionf> Members

        public bool Equals(Quaternionf other)
        {
            return this == other;
        }

        #endregion

        #region IComparable Members

        public int CompareTo(object obj)
        {
            if (obj is Quaternionf)
            {
                return this.CompareTo((Quaternionf)obj);
            }
            throw new ArgumentException("Invalid argument.");
        }

        #endregion

        #region IComparable<Quaternionf> Members

        public int CompareTo(Quaternionf other)
        {
            return (Re + Im.X + Im.Y + Im.Z).CompareTo(
                other.Re + other.Im.X + other.Im.Y + other.Im.Z);
        }

        #endregion
    }


#if SHARPMEDIA_TESTSUITE
    [TestSuite]
    internal class Test_Quaternionf
    {
        [CorrectnessTest]
        public void Properites()
        {
            Quaternionf q = new Quaternionf(1.0f, 2, 3, (float)0.5);
            Assert.IsTrue(q.Conjugate.Equals(new Quaternionf(1.0f, -2, -3, (float)-0.5)));
            Quaternionf q2 = q * Quaternionf.Identity;
            Assert.IsTrue(q2 == q);
            Assert.IsTrue(q.Im == new Vector3f(2, 3, (float)0.5));
            Assert.AreEqual(1.0f, q.Re);
            Assert.AreEqual(1.0f, q.Normal.Length);
            Assert.AreEqual(false, q.IsReal);
            Assert.IsTrue(q.NormInverse == q.Conjugate);
        }

        [CorrectnessTest]
        public void Mul()
        {
            Quaternionf q = new Quaternionf(1.0f, 2, 3, (float)15.5);
            Assert.IsTrue(Quaternionf.NearEqual(q * q.Inverse, Quaternionf.Identity));
        }

        [CorrectnessTest]
        public void Add()
        {
            Quaternionf q = new Quaternionf(3, 2, 1.0f, 7);
            Assert.IsTrue(q + Quaternionf.Zero == q);
            Assert.IsTrue(q + q == 2 * q);
        }


        [CorrectnessTest]
        public void Transform()
        {
            Quaternionf q2 = Quaternionf.FromAxis(new Vector3f(0, 1, 0), 0.0f);
            Assert.IsTrue(q2 == Quaternionf.Identity);
            Quaternionf q = Quaternionf.FromAxis(new Vector3f(0, 0, 1), (float)(global::System.Math.PI / 2.0));
            Matrix3x3f m = q.ToMatrix();
            Assert.IsTrue(Vector3f.NearEqual(m * Vector3f.AxisY, new Vector3f(-1, 0, 0)));
            Assert.IsTrue(Vector3f.NearEqual(q * Vector3f.AxisY, new Vector3f(-1, 0, 0)));
        }
        
    }
#endif
}
